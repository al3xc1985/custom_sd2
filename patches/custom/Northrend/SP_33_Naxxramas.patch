diff --git a/patches/custom/Northrend/SP_33_Naxxramas_new.patch b/patches/custom/Northrend/SP_33_Naxxramas_new.patch
deleted file mode 100644
index 24a6ae3..0000000
--- a/patches/custom/Northrend/SP_33_Naxxramas_new.patch
+++ /dev/null
@@ -1,4513 +0,0 @@
-diff --git a/scripts/northrend/naxxramas/boss_anubrekhan.cpp b/scripts/northrend/naxxramas/boss_anubrekhan.cpp
-index 3959ef7..2fac88a 100644
---- a/scripts/northrend/naxxramas/boss_anubrekhan.cpp
-+++ b/scripts/northrend/naxxramas/boss_anubrekhan.cpp
-@@ -1,4 +1,4 @@
--/* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
-+s /* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
-  * This program is free software; you can redistribute it and/or modify
-  * it under the terms of the GNU General Public License as published by
-  * the Free Software Foundation; either version 2 of the License, or
-@@ -47,9 +47,12 @@ enum
-     SPELL_SELF_SPAWN_5          = 29105,                    //This spawns 5 corpse scarabs ontop of us (most likely the pPlayer casts this on death)
-     SPELL_SELF_SPAWN_10         = 28864,                    //This is used by the crypt guards when they die
- 
--    NPC_CRYPT_GUARD             = 16573
-+    NPC_CRYPT_GUARD             = 16573,
-+    NPC_CORPSE_SCARAB           = 16698,
- };
- 
-+static const uint32 MAX_CRYPT_GUARDS = 8;
-+
- struct MANGOS_DLL_DECL boss_anubrekhanAI : public ScriptedAI
- {
-     boss_anubrekhanAI(Creature* pCreature) : ScriptedAI(pCreature)
-@@ -68,11 +71,39 @@ struct MANGOS_DLL_DECL boss_anubrekhanAI : public ScriptedAI
-     uint32 m_uiSummonTimer;
-     bool   m_bHasTaunted;
- 
-+    uint32 RiseFromCorpse_Timer;
-+
-+    uint64 guidCryptGuards[MAX_CRYPT_GUARDS];
-+    uint32 CryptGuard_count;
-+
-+    bool swarm;                        //is active spell LocustSwarm or not, when active he cannot use other spels
-+
-     void Reset()
-     {
-         m_uiImpaleTimer = 15000;                            // 15 seconds
-         m_uiLocustSwarmTimer = urand(80000, 120000);        // Random time between 80 seconds and 2 minutes for initial cast
-         m_uiSummonTimer = m_uiLocustSwarmTimer + 45000;     // 45 seconds after initial locust swarm
-+
-+        swarm = false;
-+        CryptGuard_count = 0;
-+
-+        // Remove all Crypt Guards
-+        for (int i = 0; i < MAX_CRYPT_GUARDS; i++)
-+        {
-+            //delete creature
-+            Unit* pUnit = Unit::GetUnit((*m_creature), guidCryptGuards[i]);
-+            if (pUnit)
-+                pUnit->AddObjectToRemoveList();
-+            guidCryptGuards[i] = 0;
-+        }
-+        
-+        //Remove all corpse scarabs
-+        std::list<Creature*> CorpseScarabs = GetCreaturesByEntry(NPC_CORPSE_SCARAB);
-+        if (!CorpseScarabs.empty())
-+            for(std::list<Creature*>::iterator itr = CorpseScarabs.begin(); itr != CorpseScarabs.end(); ++itr)
-+                (*itr)->AddObjectToRemoveList();
-+
-+        //if anubrekhan is alive -> this must be first time we entered Arachnid Quarter -> close all other doors
-     }
- 
-     void KilledUnit(Unit* pVictim)
-@@ -130,44 +161,128 @@ struct MANGOS_DLL_DECL boss_anubrekhanAI : public ScriptedAI
-         ScriptedAI::MoveInLineOfSight(pWho);
-     }
- 
-+    bool IsVisible(Unit* who) const
-+    {
-+        if (!who)
-+            return false;
-+        return m_creature->IsWithinDistInMap(who, 100.0f);
-+    }
-+
-+    std::list<Creature*> GetCreaturesByEntry(uint32 entry)
-+    {
-+        CellPair pair(MaNGOS::ComputeCellPair(m_creature->GetPositionX(), m_creature->GetPositionY()));
-+        Cell cell(pair);
-+        cell.data.Part.reserved = ALL_DISTRICT;
-+        cell.SetNoCreate();
-+
-+        std::list<Creature*> creatureList;
-+
-+        AllCreaturesOfEntryInRange check(m_creature, entry, 100);
-+        MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange> searcher(m_creature, creatureList, check);
-+        TypeContainerVisitor<MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange>, GridTypeMapContainer> visitor(searcher);
-+
-+        cell.Visit(pair, visitor, *(m_creature->GetMap()));
-+
-+        return creatureList;
-+    }
-+
-+    void JustSummoned(Creature* temp) 
-+    {
-+        if (!temp)
-+            return;
-+
-+        //Summoned Crypt Guard will target random player
-+        guidCryptGuards[CryptGuard_count++] = temp->GetGUID();
-+        if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
-+        {
-+            temp->AddThreat(target);
-+            m_creature->SetInCombatWithZone();
-+        }
-+
-+        switch (rand()%4)
-+        {
-+            case 0: DoScriptText(SAY_TAUNT1, m_creature); break;
-+            case 1: DoScriptText(SAY_TAUNT2, m_creature); break;
-+            case 2: DoScriptText(SAY_TAUNT3, m_creature); break;
-+            case 3: DoScriptText(SAY_TAUNT4, m_creature); break;
-+        }
-+    }
-+
-     void UpdateAI(const uint32 uiDiff)
-     {
-         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-             return;
- 
--        // Impale
--        if (m_uiImpaleTimer < uiDiff)
-+        //SumonFirstCryptGuard_Timer
-+        if (m_uiSummonTimer< uiDiff)
-         {
--            //Cast Impale on a random target
--            //Do NOT cast it when we are afflicted by locust swarm
--            if (!m_creature->HasAura(SPELL_LOCUSTSWARM) || !m_creature->HasAura(SPELL_LOCUSTSWARM_H))
--            {
--                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM,0))
--                    DoCastSpellIfCan(target, m_bIsRegularMode ? SPELL_IMPALE : SPELL_IMPALE_H);
--            }
-+            if (CryptGuard_count < MAX_CRYPT_GUARDS)
-+                DoSpawnCreature(NPC_CRYPT_GUARD,0,0,0,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,10000);
-+            m_uiSummonTimer = 2000000;
-+        }else m_uiSummonTimer -= uiDiff;
- 
--            m_uiImpaleTimer = 15000;
--        }
--        else
--            m_uiImpaleTimer -= uiDiff;
-+        //RiseFromCorpse_Timer
-+        if (RiseFromCorpse_Timer < uiDiff)
-+        {
-+            RiseFromCorpse_Timer = 60000 + (rand()%10000);
-+            std::list<Creature*> CryptGuards = GetCreaturesByEntry(NPC_CRYPT_GUARD);
-+            if (!CryptGuards.empty())
-+                for(std::list<Creature*>::iterator itr = CryptGuards.begin(); itr != CryptGuards.end(); ++itr)
-+                    if ((*itr)->isDead())
-+                    {
-+                        (*itr)->CastSpell((*itr),SPELL_SELF_SPAWN_10,true);
-+                        (*itr)->AddObjectToRemoveList();
-+                    }
-+
-+            const Map::PlayerList &players = m_creature->GetMap()->GetPlayers();
-+            if (players.isEmpty())
-+                return;
-+
-+            for(Map::PlayerList::const_iterator i = players.begin(); i != players.end(); ++i)
-+                if (Player* pPlayer = i->getSource())
-+                {
-+                    if (pPlayer->isGameMaster())
-+                        continue;
-+
-+                    if (pPlayer->isDead())
-+                        pPlayer->CastSpell(pPlayer,SPELL_SELF_SPAWN_5,true);
-+                }
-+            CryptGuards.clear();
-+        }else RiseFromCorpse_Timer -= uiDiff; 
- 
--        // Locust Swarm
--        if (m_uiLocustSwarmTimer < uiDiff)
-+        if(!swarm)
-         {
--            DoCastSpellIfCan(m_creature, m_bIsRegularMode ? SPELL_LOCUSTSWARM :SPELL_LOCUSTSWARM_H);
--            m_uiLocustSwarmTimer = 90000;
-+            //Impale_Timer
-+            if (m_uiImpaleTimer < uiDiff)
-+            {
-+                //Cast Impale on a random target
-+                //Do NOT cast it when we are afflicted by locust swarm
-+                if (!m_creature->HasAura(m_bIsRegularMode ? SPELL_LOCUSTSWARM : SPELL_LOCUSTSWARM_H, EFFECT_INDEX_1))
-+                    if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 1))
-+                        DoCast(target,m_bIsRegularMode ? SPELL_IMPALE : SPELL_IMPALE_H);
-+                m_uiImpaleTimer = 15000;
-+            }else m_uiImpaleTimer -= uiDiff;
-+
-+            //LocustSwarm_Timer
-+            if (m_uiLocustSwarmTimer < uiDiff)
-+            {
-+                //Cast Locust Swarm buff on ourselves
-+                DoCast(m_creature, m_bIsRegularMode ? SPELL_LOCUSTSWARM : SPELL_LOCUSTSWARM_H);
-+                swarm = true;
-+                //Summon Crypt Guard immidietly after Locust Swarm
-+                if (CryptGuard_count < MAX_CRYPT_GUARDS)
-+                    DoSpawnCreature(NPC_CRYPT_GUARD,0,0,0,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,10000);
-+                m_uiLocustSwarmTimer = 20000;
-+            }else m_uiLocustSwarmTimer -= uiDiff;
-         }
-         else
--            m_uiLocustSwarmTimer -= uiDiff;
--
--        // Summon
--        /*if (m_uiSummonTimer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature, SPELL_SUMMONGUARD);
--            Summon_Timer = 45000;
-+            if (m_uiLocustSwarmTimer < uiDiff)
-+            {            
-+                swarm = false;
-+                m_uiLocustSwarmTimer = 60000 + rand()%20000;
-+            }else m_uiLocustSwarmTimer -= uiDiff;
-         }
--        else
--            m_uiSummonTimer -= uiDiff;*/
- 
-         DoMeleeAttackIfReady();
-     }
-diff --git a/scripts/northrend/naxxramas/boss_faerlina.cpp b/scripts/northrend/naxxramas/boss_faerlina.cpp
-index 52499bb..95321a7 100644
---- a/scripts/northrend/naxxramas/boss_faerlina.cpp
-+++ b/scripts/northrend/naxxramas/boss_faerlina.cpp
-@@ -41,8 +41,17 @@ enum
-     H_SPELL_POSIONBOLT_VOLLEY = 54098,
-     SPELL_ENRAGE              = 28798,
-     H_SPELL_ENRAGE            = 54100,
-+    SPELL_WIDOWS_EMBRACE       = 28732,
-+    SPELL_FIREBALL            = 54095,
-+    SPELL_FIREBALL_H          = 54096,
- 
--    SPELL_RAINOFFIRE          = 28794                       //Not sure if targeted AoEs work if casted directly upon a pPlayer
-+    SPELL_RAINOFFIRE          = 28794,                       //Not sure if targeted AoEs work if casted directly upon a pPlayer
-+
-+    NPC_NAXX_FOLLOWER           = 16505,
-+    NPC_NAXX_WORSHIPER          = 16506,
-+
-+    ACHIEV_KNOCK_YOU_OUT        = 1997,
-+    ACHIEV_KNOCK_YOU_OUT_H      = 2140,
- };
- struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
- {
-@@ -62,11 +71,38 @@ struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
-     uint32 m_uiEnrageTimer;
-     bool   m_bHasTaunted;
- 
-+    bool m_bHasFrenzy;
-+
-+    std::list<Creature*> lFollowers;
-+    std::list<Creature*> lWorshipers;
-+
-     void Reset()
-     {
-         m_uiPoisonBoltVolleyTimer = 8000;
-         m_uiRainOfFireTimer = 16000;
-         m_uiEnrageTimer = 60000;
-+
-+        m_bHasFrenzy = false;
-+
-+        GetCreatureListWithEntryInGrid(lFollowers, m_creature, NPC_NAXX_FOLLOWER, DEFAULT_VISIBILITY_INSTANCE);
-+        if (!lFollowers.empty())
-+        {
-+            for(std::list<Creature*>::iterator iter = lFollowers.begin(); iter != lFollowers.end(); ++iter)
-+            {
-+                if ((*iter) && !(*iter)->isAlive())
-+                    (*iter)->Respawn();
-+            }
-+        }
-+
-+        GetCreatureListWithEntryInGrid(lWorshipers, m_creature, NPC_NAXX_WORSHIPER, DEFAULT_VISIBILITY_INSTANCE);
-+        if (!lWorshipers.empty())
-+        {
-+            for(std::list<Creature*>::iterator iter = lWorshipers.begin(); iter != lWorshipers.end(); ++iter)
-+            {
-+                if ((*iter) && !(*iter)->isAlive())
-+                    (*iter)->Respawn();
-+            }
-+        }
-     }
- 
-     void Aggro(Unit* pWho)
-@@ -105,6 +141,12 @@ struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
- 
-         if (m_pInstance)
-             m_pInstance->SetData(TYPE_FAERLINA, DONE);
-+
-+        if(!m_bHasFrenzy)
-+        {
-+            if(m_pInstance)
-+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_KNOCK_YOU_OUT : ACHIEV_KNOCK_YOU_OUT_H);
-+        }
-     }
- 
-     void JustReachedHome()
-@@ -121,7 +163,7 @@ struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
-         // Poison Bolt Volley
-         if (m_uiPoisonBoltVolleyTimer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature->getVictim(), SPELL_POSIONBOLT_VOLLEY);
-+            DoCastSpellIfCan(m_creature->getVictim(), !m_bIsRegularMode ? H_SPELL_POSIONBOLT_VOLLEY : SPELL_POSIONBOLT_VOLLEY);
-             m_uiPoisonBoltVolleyTimer = 11000;
-         }
-         else
-@@ -141,7 +183,8 @@ struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
-         //Enrage_Timer
-         if (m_uiEnrageTimer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature, SPELL_ENRAGE);
-+            m_bHasFrenzy = true;
-+            DoCastSpellIfCan(m_creature, m_bIsRegularMode ? SPELL_ENRAGE : H_SPELL_ENRAGE);
-             m_uiEnrageTimer = 61000;
-         }
-         else 
-@@ -151,6 +194,93 @@ struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
-     }
- };
- 
-+struct MANGOS_DLL_DECL mob_worshippersAI : public ScriptedAI
-+{
-+    mob_worshippersAI(Creature* pCreature) : ScriptedAI(pCreature)
-+    {
-+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
-+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
-+        Reset();
-+    }
-+
-+    ScriptedInstance* m_pInstance;
-+    bool m_bIsRegularMode;
-+    bool m_bIsDead;
-+
-+    uint32 m_uiFireball_Timer;
-+    uint32 m_uiDeathDelay_Timer;
-+
-+    void Reset()
-+    {
-+        m_bIsDead = false;
-+        m_uiFireball_Timer = 0;
-+        m_uiDeathDelay_Timer = 0;
-+    }
-+
-+    void DamageTaken(Unit* pDoneBy, uint32 &uiDamage)
-+    {
-+        if (m_bIsDead)
-+        {
-+            uiDamage = 0;
-+            return;
-+        }
-+
-+        if (uiDamage > m_creature->GetHealth())
-+        {
-+            if (m_creature->IsNonMeleeSpellCasted(false))
-+                m_creature->InterruptNonMeleeSpells(false);
-+
-+            m_creature->RemoveAllAuras();
-+            m_creature->AttackStop();
-+
-+            //DoCast(m_creature, SPELL_WIDOWS_EMBRACE);
-+
-+            if (m_pInstance)
-+                if (Creature* pFaerlina = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(NPC_FAERLINA))))
-+                {
-+                    if (m_creature->GetDistance2d(pFaerlina) <= 5 && pFaerlina->HasAura(m_bIsRegularMode ? H_SPELL_ENRAGE : SPELL_ENRAGE))
-+                        pFaerlina->RemoveAurasDueToSpell(m_bIsRegularMode ? H_SPELL_ENRAGE : SPELL_ENRAGE);
-+
-+                    //pFaerlina->CastSpell(pFaerlina, SPELL_WIDOWS_EMBRACE, false);
-+                }
-+
-+            m_bIsDead = true;
-+            m_uiDeathDelay_Timer = 500;
-+
-+            uiDamage = 0;
-+            return;
-+        }
-+    }
-+
-+    void UpdateAI(const uint32 uiDiff)
-+    {
-+        if (m_bIsDead)
-+            if (m_uiDeathDelay_Timer < uiDiff)
-+            {
-+                m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
-+                m_uiDeathDelay_Timer = 0;
-+            }
-+            else m_uiDeathDelay_Timer -= uiDiff;
-+
-+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim() || m_bIsDead)
-+            return;
-+
-+        if (m_uiFireball_Timer < uiDiff)
-+        {
-+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_FIREBALL_H : SPELL_FIREBALL);
-+            m_uiFireball_Timer = 7000 + rand()%4000;
-+        }
-+        else m_uiFireball_Timer -= uiDiff;
-+
-+        DoMeleeAttackIfReady();
-+    }
-+};
-+
-+CreatureAI* GetAI_mob_worshippers(Creature* pCreature)
-+{
-+    return new mob_worshippersAI(pCreature);
-+}
-+
- CreatureAI* GetAI_boss_faerlina(Creature* pCreature)
- {
-     return new boss_faerlinaAI(pCreature);
-@@ -163,4 +293,9 @@ void AddSC_boss_faerlina()
-     NewScript->Name = "boss_faerlina";
-     NewScript->GetAI = &GetAI_boss_faerlina;
-     NewScript->RegisterSelf();
-+
-+    NewScript = new Script;
-+    NewScript->Name = "mob_worshippers";
-+    NewScript->GetAI = &GetAI_mob_worshippers;
-+    NewScript->RegisterSelf();
- }
-diff --git a/scripts/northrend/naxxramas/boss_four_horsemen.cpp b/scripts/northrend/naxxramas/boss_four_horsemen.cpp
-index ca50c0a..d1a70ea 100644
---- a/scripts/northrend/naxxramas/boss_four_horsemen.cpp
-+++ b/scripts/northrend/naxxramas/boss_four_horsemen.cpp
-@@ -38,7 +38,7 @@ enum
-     SAY_BLAU_SPECIAL        = -1533048,
-     SAY_BLAU_SLAY           = -1533049,
-     SAY_BLAU_DEATH          = -1533050,
--
-+    // spells
-     SPELL_MARK_OF_BLAUMEUX  = 28833,
-     SPELL_UNYILDING_PAIN    = 57381,
-     SPELL_VOIDZONE          = 28863,
-@@ -57,7 +57,7 @@ enum
-     SAY_RIVE_TAUNT2         = -1533072,
-     SAY_RIVE_TAUNT3         = -1533073,
-     SAY_RIVE_DEATH          = -1533074,
--
-+    // spells
-     SPELL_MARK_OF_RIVENDARE = 28834,
-     SPELL_UNHOLY_SHADOW     = 28882,
-     H_SPELL_UNHOLY_SHADOW   = 57369,
-@@ -70,8 +70,9 @@ enum
-     SAY_KORT_SPECIAL        = -1533055,
-     SAY_KORT_SLAY           = -1533056,
-     SAY_KORT_DEATH          = -1533057,
--
-+    // spells
-     SPELL_MARK_OF_KORTHAZZ  = 28832,
-+    H_SPELL_METEOR          = 57467,
-     SPELL_METEOR            = 26558,                        // m_creature->getVictim() auto-area spell but with a core problem
- 
-     //sir zeliek
-@@ -82,12 +83,13 @@ enum
-     SAY_ZELI_SPECIAL        = -1533062,
-     SAY_ZELI_SLAY           = -1533063,
-     SAY_ZELI_DEATH          = -1533064,
--
-+    // spells
-     SPELL_MARK_OF_ZELIEK    = 28835,
-     SPELL_HOLY_WRATH        = 28883,
-     H_SPELL_HOLY_WRATH      = 57466,
-     SPELL_HOLY_BOLT         = 57376,
-     H_SPELL_HOLY_BOLT       = 57465,
-+    SPELL_CONDEMNATION      = 57377, 
- 
-     // horseman spirits
-     NPC_SPIRIT_OF_BLAUMEUX    = 16776,
-@@ -96,14 +98,42 @@ enum
-     NPC_SPIRIT_OF_ZELIREK     = 16777
- };
- 
-+/*walk coords*/
-+#define WALKX_BLAU                2462.112f
-+#define WALKY_BLAU                -2956.598f
-+#define WALKZ_BLAU                241.276f
-+
-+#define WALKX_RIVE                2579.571f
-+#define WALKY_RIVE                -2960.945f
-+#define WALKZ_RIVE                241.32f
-+
-+#define WALKX_KORT                2529.108f
-+#define WALKY_KORT                -3015.303f
-+#define WALKZ_KORT                241.32f
-+    
-+#define WALKX_ZELI                2521.039f
-+#define WALKY_ZELI                -2891.633f
-+#define WALKZ_ZELI                241.276f
-+
- struct MANGOS_DLL_DECL boss_lady_blaumeuxAI : public ScriptedAI
- {
--    boss_lady_blaumeuxAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
-+    boss_lady_blaumeuxAI(Creature* pCreature) : ScriptedAI(pCreature) 
-+    {
-+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
-+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
-+        Reset();
-+    }
- 
-+    bool m_bIsRegularMode;
-+    ScriptedInstance* m_pInstance;
-     uint32 Mark_Timer;
-     uint32 VoidZone_Timer;
-+    uint32 ShadowboltTimer;
-+    uint32 Cast_Timer;
-     bool ShieldWall1;
-     bool ShieldWall2;
-+    bool Move_Check;
-+    bool Attack_Check;
- 
-     void Reset()
-     {
-@@ -111,11 +141,34 @@ struct MANGOS_DLL_DECL boss_lady_blaumeuxAI : public ScriptedAI
-         VoidZone_Timer = 12000;                             // right
-         ShieldWall1 = true;
-         ShieldWall2 = true;
-+        Move_Check = true;
-+        ShadowboltTimer = 3000;
-+        Cast_Timer = 15000;
-+
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_BLAUMEAUX, NOT_STARTED);
-     }
- 
-     void Aggro(Unit *who)
-     {
-         DoScriptText(SAY_BLAU_AGGRO, m_creature);
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, IN_PROGRESS);
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_BLAUMEAUX, IN_PROGRESS);
-+    }
-+
-+    void AttackStart(Unit* pWho)
-+    {
-+        if (!pWho)
-+            return;
-+
-+        if (m_creature->Attack(pWho, true))
-+        {
-+            m_creature->AddThreat(pWho);
-+            m_creature->SetInCombatWith(pWho);
-+            pWho->SetInCombatWith(m_creature);
-+        }
-     }
- 
-     void KilledUnit(Unit* Victim)
-@@ -126,6 +179,8 @@ struct MANGOS_DLL_DECL boss_lady_blaumeuxAI : public ScriptedAI
-     void JustDied(Unit* Killer)
-     {
-         DoScriptText(SAY_BLAU_DEATH, m_creature);
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_BLAUMEAUX, DONE);
-     }
- 
-     void UpdateAI(const uint32 uiDiff)
-@@ -133,27 +188,52 @@ struct MANGOS_DLL_DECL boss_lady_blaumeuxAI : public ScriptedAI
-         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-             return;
- 
-+        //run on aggro
-+        if (m_creature->getVictim() && Move_Check)
-+        {
-+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+            m_creature->GetMotionMaster()->MovePoint(0, WALKX_BLAU, WALKY_BLAU, WALKZ_BLAU);
-+            Move_Check = false;
-+        }
-+
-+        // Cast
-+        if (Cast_Timer < uiDiff)
-+        {
-+            if (m_creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
-+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+            if(m_creature->getVictim()->IsWithinDist(m_creature, 40))
-+            {
-+                DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_SHADOW_BOLT : H_SPELL_SHADOW_BOLT);
-+                Cast_Timer = 5000;
-+            }
-+            else
-+            {
-+                DoCast(m_creature->getVictim(), SPELL_UNYILDING_PAIN);
-+                Cast_Timer = 2050;
-+            }   
-+        }else Cast_Timer -= uiDiff;
-+
-         // Mark of Blaumeux
-         if (Mark_Timer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature->getVictim(),SPELL_MARK_OF_BLAUMEUX);
-+            DoCast(m_creature->getVictim(),SPELL_MARK_OF_BLAUMEUX);
-             Mark_Timer = 12000;
-         }else Mark_Timer -= uiDiff;
- 
-         // Shield Wall - All 4 horsemen will shield wall at 50% hp and 20% hp for 20 seconds
--        if (ShieldWall1 && m_creature->GetHealthPercent() < 50.0f)
-+        if (ShieldWall1 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 50)
-         {
-             if (ShieldWall1)
-             {
--                DoCastSpellIfCan(m_creature,SPELL_SHIELDWALL);
-+                DoCast(m_creature,SPELL_SHIELDWALL);
-                 ShieldWall1 = false;
-             }
-         }
--        if (ShieldWall2 && m_creature->GetHealthPercent() < 20.0f)
-+        if (ShieldWall2 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 20)
-         {
-             if (ShieldWall2)
-             {
--                DoCastSpellIfCan(m_creature,SPELL_SHIELDWALL);
-+                DoCast(m_creature,SPELL_SHIELDWALL);
-                 ShieldWall2 = false;
-             }
-         }
-@@ -161,7 +241,7 @@ struct MANGOS_DLL_DECL boss_lady_blaumeuxAI : public ScriptedAI
-         // Void Zone
-         if (VoidZone_Timer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature->getVictim(),SPELL_VOIDZONE);
-+            DoCast(m_creature->getVictim(),m_bIsRegularMode ? SPELL_VOIDZONE : H_SPELL_VOIDZONE);
-             VoidZone_Timer = 12000;
-         }else VoidZone_Timer -= uiDiff;
- 
-@@ -176,10 +256,35 @@ CreatureAI* GetAI_boss_lady_blaumeux(Creature* pCreature)
- 
- struct MANGOS_DLL_DECL boss_rivendare_naxxAI : public ScriptedAI
- {
--    boss_rivendare_naxxAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
-+    boss_rivendare_naxxAI(Creature* pCreature) : ScriptedAI(pCreature) 
-+    {
-+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
-+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
-+        Reset();
-+    }
-+
-+    ScriptedInstance* m_pInstance;
-+    bool m_bIsRegularMode;
-+    uint32 UnholyShadowTimer;
-+    uint32 Mark_Timer;
-+    bool ShieldWall1;
-+    bool ShieldWall2;
-+
-+    bool Move_Check;
-+    bool Attack_Check;
- 
-     void Reset()
-     {
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_RIVENDARE, NOT_STARTED);
-+
-+        UnholyShadowTimer = 15000;
-+        ShieldWall1 = true;
-+        ShieldWall2 = true;
-+        Mark_Timer = 20000;
-+
-+        Move_Check = true;
-+        Attack_Check = true;
-     }
- 
-     void Aggro(Unit *who)
-@@ -190,6 +295,11 @@ struct MANGOS_DLL_DECL boss_rivendare_naxxAI : public ScriptedAI
-             case 1: DoScriptText(SAY_RIVE_AGGRO2, m_creature); break;
-             case 2: DoScriptText(SAY_RIVE_AGGRO3, m_creature); break;
-         }
-+
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, IN_PROGRESS);
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_RIVENDARE, IN_PROGRESS);
-     }
- 
-     void KilledUnit(Unit* Victim)
-@@ -200,6 +310,9 @@ struct MANGOS_DLL_DECL boss_rivendare_naxxAI : public ScriptedAI
-     void JustDied(Unit* Killer)
-     {
-         DoScriptText(SAY_RIVE_DEATH, m_creature);
-+
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_RIVENDARE, DONE);
-     }
- 
-     void UpdateAI(const uint32 uiDiff)
-@@ -207,6 +320,55 @@ struct MANGOS_DLL_DECL boss_rivendare_naxxAI : public ScriptedAI
-         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-             return;
- 
-+        //run on aggro
-+        if (m_creature->getVictim() && Move_Check)
-+        {
-+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+            m_creature->GetMotionMaster()->MovePoint(0, WALKX_RIVE, WALKY_RIVE, WALKZ_RIVE);
-+            Move_Check = false;
-+        }
-+        
-+        //when reach position, set possible to attack
-+        if (m_creature->GetDistance2d(WALKX_RIVE, WALKY_RIVE) <= 2 && Attack_Check)
-+        {
-+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+            m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
-+            Attack_Check = false;
-+        }
-+
-+        // Mark of Rivendare
-+        if (Mark_Timer < uiDiff)
-+        {
-+            DoCast(m_creature->getVictim(),SPELL_MARK_OF_RIVENDARE);
-+            Mark_Timer = 12000;
-+        }else Mark_Timer -= uiDiff;
-+
-+        // Shield Wall - All 4 horsemen will shield wall at 50% hp and 20% hp for 20 seconds
-+        if (ShieldWall1 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 50)
-+        {
-+            if (ShieldWall1)
-+            {
-+                DoCast(m_creature,SPELL_SHIELDWALL);
-+                ShieldWall1 = false;
-+            }
-+        }
-+        if (ShieldWall2 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 20)
-+        {
-+            if (ShieldWall2)
-+            {
-+                DoCast(m_creature,SPELL_SHIELDWALL);
-+                ShieldWall2 = false;
-+            }
-+        }
-+
-+        //Unholy Shadow
-+        if(UnholyShadowTimer < uiDiff)
-+        {
-+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_UNHOLY_SHADOW : H_SPELL_UNHOLY_SHADOW);
-+            UnholyShadowTimer = 15000;
-+        }
-+        else UnholyShadowTimer -= uiDiff;
-+
-         DoMeleeAttackIfReady();
-     }
- };
-@@ -218,24 +380,45 @@ CreatureAI* GetAI_boss_rivendare_naxx(Creature* pCreature)
- 
- struct MANGOS_DLL_DECL boss_thane_korthazzAI : public ScriptedAI
- {
--    boss_thane_korthazzAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
-+    boss_thane_korthazzAI(Creature* pCreature) : ScriptedAI(pCreature) 
-+    {
-+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
-+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
-+        Reset();
-+    }
- 
-+    ScriptedInstance* m_pInstance;
-+    bool m_bIsRegularMode;
-     uint32 Mark_Timer;
-     uint32 Meteor_Timer;
-     bool ShieldWall1;
-     bool ShieldWall2;
- 
-+    bool Move_Check;
-+    bool Attack_Check;
-+
-     void Reset()
-     {
-         Mark_Timer = 20000;                                 // First Horsemen Mark is applied at 20 sec.
-         Meteor_Timer = 30000;                               // wrong
-         ShieldWall1 = true;
-         ShieldWall2 = true;
-+
-+        Move_Check = true;
-+        Attack_Check = true;
-+
-+        if(m_pInstance) 
-+             m_pInstance->SetData(TYPE_KORTHAZZ, NOT_STARTED);
-     }
- 
-     void Aggro(Unit *who)
-     {
-         DoScriptText(SAY_KORT_AGGRO, m_creature);
-+
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, IN_PROGRESS);
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_KORTHAZZ, IN_PROGRESS);
-     }
- 
-     void KilledUnit(Unit* Victim)
-@@ -246,6 +429,9 @@ struct MANGOS_DLL_DECL boss_thane_korthazzAI : public ScriptedAI
-     void JustDied(Unit* Killer)
-     {
-         DoScriptText(SAY_KORT_DEATH, m_creature);
-+
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_KORTHAZZ, DONE);
-     }
- 
-     void UpdateAI(const uint32 uiDiff)
-@@ -253,27 +439,43 @@ struct MANGOS_DLL_DECL boss_thane_korthazzAI : public ScriptedAI
-         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-             return;
- 
-+        //run on aggro
-+        if (m_creature->getVictim() && Move_Check)
-+        {
-+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+            m_creature->GetMotionMaster()->MovePoint(0, WALKX_KORT, WALKY_KORT, WALKZ_KORT);
-+            Move_Check = false;
-+        }
-+        
-+        //when reach position, set possible to attack
-+        if (m_creature->GetDistance2d(WALKX_KORT, WALKY_KORT) <= 2 && Attack_Check)
-+        {
-+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+            m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
-+            Attack_Check = false;
-+        }
-+
-         // Mark of Korthazz
-         if (Mark_Timer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature->getVictim(),SPELL_MARK_OF_KORTHAZZ);
-+            DoCast(m_creature->getVictim(),SPELL_MARK_OF_KORTHAZZ);
-             Mark_Timer = 12000;
-         }else Mark_Timer -= uiDiff;
- 
-         // Shield Wall - All 4 horsemen will shield wall at 50% hp and 20% hp for 20 seconds
--        if (ShieldWall1 && m_creature->GetHealthPercent() < 50.0f)
-+        if (ShieldWall1 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 50)
-         {
-             if (ShieldWall1)
-             {
--                DoCastSpellIfCan(m_creature,SPELL_SHIELDWALL);
-+                DoCast(m_creature,SPELL_SHIELDWALL);
-                 ShieldWall1 = false;
-             }
-         }
--        if (ShieldWall2 && m_creature->GetHealthPercent() < 20.0f)
-+        if (ShieldWall2 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 20)
-         {
-             if (ShieldWall2)
-             {
--                DoCastSpellIfCan(m_creature,SPELL_SHIELDWALL);
-+                DoCast(m_creature,SPELL_SHIELDWALL);
-                 ShieldWall2 = false;
-             }
-         }
-@@ -281,7 +483,7 @@ struct MANGOS_DLL_DECL boss_thane_korthazzAI : public ScriptedAI
-         // Meteor
-         if (Meteor_Timer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature->getVictim(),SPELL_METEOR);
-+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_METEOR : H_SPELL_METEOR);
-             Meteor_Timer = 20000;                           // wrong
-         }else Meteor_Timer -= uiDiff;
- 
-@@ -296,12 +498,22 @@ CreatureAI* GetAI_boss_thane_korthazz(Creature* pCreature)
- 
- struct MANGOS_DLL_DECL boss_sir_zeliekAI : public ScriptedAI
- {
--    boss_sir_zeliekAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
-+    boss_sir_zeliekAI(Creature* pCreature) : ScriptedAI(pCreature) 
-+    {
-+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
-+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
-+        Reset();
-+    }
- 
-+    ScriptedInstance* m_pInstance;
-+    bool m_bIsRegularMode;
-     uint32 Mark_Timer;
-     uint32 HolyWrath_Timer;
-     bool ShieldWall1;
-     bool ShieldWall2;
-+    bool Move_Check;
-+    bool Attack_Check;
-+    uint32 Cast_Timer;
- 
-     void Reset()
-     {
-@@ -309,11 +521,21 @@ struct MANGOS_DLL_DECL boss_sir_zeliekAI : public ScriptedAI
-         HolyWrath_Timer = 12000;                            // right
-         ShieldWall1 = true;
-         ShieldWall2 = true;
-+        Move_Check = true;
-+        Cast_Timer = 15000;
-+
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_ZELIEK, NOT_STARTED);
-     }
- 
-     void Aggro(Unit *who)
-     {
-         DoScriptText(SAY_ZELI_AGGRO, m_creature);
-+
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, IN_PROGRESS);
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_ZELIEK, IN_PROGRESS);
-     }
- 
-     void KilledUnit(Unit* Victim)
-@@ -324,6 +546,22 @@ struct MANGOS_DLL_DECL boss_sir_zeliekAI : public ScriptedAI
-     void JustDied(Unit* Killer)
-     {
-         DoScriptText(SAY_ZELI_DEATH, m_creature);
-+
-+        if(m_pInstance) 
-+            m_pInstance->SetData(TYPE_ZELIEK, DONE);
-+    }
-+
-+    void AttackStart(Unit* pWho)
-+    {
-+        if (!pWho)
-+            return;
-+
-+        if (m_creature->Attack(pWho, true))
-+        {
-+            m_creature->AddThreat(pWho);
-+            m_creature->SetInCombatWith(pWho);
-+            pWho->SetInCombatWith(m_creature);
-+        }
-     }
- 
-     void UpdateAI(const uint32 uiDiff)
-@@ -332,27 +570,52 @@ struct MANGOS_DLL_DECL boss_sir_zeliekAI : public ScriptedAI
-         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-             return;
- 
-+           //run on aggro
-+        if (m_creature->getVictim() && Move_Check)
-+        {
-+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+            m_creature->GetMotionMaster()->MovePoint(0, WALKX_ZELI, WALKY_ZELI, WALKZ_ZELI);
-+            Move_Check = false;
-+        }
-+        
-+        // Cast
-+        if (Cast_Timer < uiDiff)
-+        {
-+            if (m_creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
-+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+            if(m_creature->getVictim()->IsWithinDist(m_creature, 40))
-+            {
-+                DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_HOLY_BOLT : H_SPELL_HOLY_BOLT);
-+                Cast_Timer = 5000;
-+            }
-+            else
-+            {
-+                DoCast(m_creature->getVictim(), SPELL_CONDEMNATION);
-+                Cast_Timer = 2050;
-+            }
-+        }else Cast_Timer -= uiDiff;
-+
-         // Mark of Zeliek
-         if (Mark_Timer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature->getVictim(),SPELL_MARK_OF_ZELIEK);
-+            DoCast(m_creature->getVictim(),SPELL_MARK_OF_ZELIEK);
-             Mark_Timer = 12000;
-         }else Mark_Timer -= uiDiff;
- 
-         // Shield Wall - All 4 horsemen will shield wall at 50% hp and 20% hp for 20 seconds
--        if (ShieldWall1 && m_creature->GetHealthPercent() < 50.0f)
-+        if (ShieldWall1 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 50)
-         {
-             if (ShieldWall1)
-             {
--                DoCastSpellIfCan(m_creature,SPELL_SHIELDWALL);
-+                DoCast(m_creature,SPELL_SHIELDWALL);
-                 ShieldWall1 = false;
-             }
-         }
--        if (ShieldWall2 && m_creature->GetHealthPercent() < 20.0f)
-+        if (ShieldWall2 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 20)
-         {
-             if (ShieldWall2)
-             {
--                DoCastSpellIfCan(m_creature,SPELL_SHIELDWALL);
-+                DoCast(m_creature,SPELL_SHIELDWALL);
-                 ShieldWall2 = false;
-             }
-         }
-@@ -360,7 +623,7 @@ struct MANGOS_DLL_DECL boss_sir_zeliekAI : public ScriptedAI
-         // Holy Wrath
-         if (HolyWrath_Timer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature->getVictim(),SPELL_HOLY_WRATH);
-+            DoCast(m_creature->getVictim(),m_bIsRegularMode ? SPELL_HOLY_WRATH : H_SPELL_HOLY_WRATH);
-             HolyWrath_Timer = 12000;
-         }else HolyWrath_Timer -= uiDiff;
- 
-diff --git a/scripts/northrend/naxxramas/boss_gluth.cpp b/scripts/northrend/naxxramas/boss_gluth.cpp
-index 2e0016e..8f1ddee 100644
---- a/scripts/northrend/naxxramas/boss_gluth.cpp
-+++ b/scripts/northrend/naxxramas/boss_gluth.cpp
-@@ -34,7 +34,8 @@ enum
-     SPELL_ENRAGE_H    = 54427,
-     SPELL_BERSERK     = 26662,
- 
--    NPC_ZOMBIE_CHOW   = 16360
-+    NPC_ZOMBIE_CHOW   = 16360,
-+    SPELL_INFECTED_WOUND = 29306
- };
- 
- #define ADD_1X 3269.590f
-@@ -73,6 +74,45 @@ enum
- #define ADD_9Y -3180.766f
- #define ADD_9Z 297.423f
- 
-+struct MANGOS_DLL_DECL mob_zombie_chowsAI : public ScriptedAI
-+{
-+    mob_zombie_chowsAI(Creature* pCreature) : ScriptedAI(pCreature)
-+    {
-+        Reset();
-+    }
-+
-+    bool bIsForceMove;
-+
-+    void Reset()
-+    {
-+        bIsForceMove = false;
-+    }
-+    void JustDied(Unit* Killer) {}
-+
-+    void DoMeleeAttackIfReady()
-+    {
-+        //If we are within range melee the target
-+        if (m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
-+        {
-+            //Make sure our attack is ready and we aren't currently casting
-+            if (m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
-+            {
-+                DoCast(m_creature->getVictim(), SPELL_INFECTED_WOUND, true);
-+                m_creature->AttackerStateUpdate(m_creature->getVictim());
-+                m_creature->resetAttackTimer();
-+            }
-+        }
-+    }
-+
-+    void UpdateAI(const uint32 diff)
-+    {
-+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim() || bIsForceMove)
-+            return;
-+
-+        DoMeleeAttackIfReady();
-+    }
-+};
-+
- struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
- {
-     boss_gluthAI(Creature* pCreature) : ScriptedAI(pCreature)
-@@ -92,6 +132,9 @@ struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
- 
-     uint32 m_uiBerserkTimer;
- 
-+    uint32 RangeCheck_Timer;
-+    std::list<uint64> m_lZombieGUIDList;
-+
-     void Reset()
-     {
-         m_uiMortalWoundTimer = 8000;
-@@ -100,6 +143,9 @@ struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
-         m_uiSummonTimer = 10000;
- 
-         m_uiBerserkTimer = MINUTE*8*IN_MILLISECONDS;
-+
-+        RangeCheck_Timer = 1000;
-+        m_lZombieGUIDList.clear();
-     }
- 
-     void JustDied(Unit* pKiller)
-@@ -120,6 +166,11 @@ struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
-             m_pInstance->SetData(TYPE_GLUTH, FAIL);
-     }
- 
-+    void JustSummoned(Creature* summoned)
-+    {
-+        summoned->SetSpeedRate(MOVE_RUN, 0.8f);
-+    }
-+
-     void UpdateAI(const uint32 uiDiff)
-     {
-         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-@@ -134,39 +185,88 @@ struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
-         else
-             m_uiMortalWoundTimer -= uiDiff;
- 
--        // Decimate
-+         //Decimate_Timer
-         if (m_uiDecimateTimer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature->getVictim(), SPELL_DECIMATE);
--            m_uiDecimateTimer = 100000;
--        }
--        else
--            m_uiDecimateTimer -= uiDiff;
-+            DoCast(m_creature->getVictim(),SPELL_DECIMATE); // need core support
-+
-+            // workaround below
-+            std::list<HostileReference*> t_list = m_creature->getThreatManager().getThreatList();
-+            if (t_list.size())
-+            {
-+                //begin + 1 , so we don't target the one with the highest threat
-+                std::list<HostileReference*>::iterator itr = t_list.begin();
-+                std::advance(itr, 1);
-+                for(; itr!= t_list.end(); ++itr)
-+                {
-+                    Unit *target = Unit::GetUnit(*m_creature, (*itr)->getUnitGuid());
-+                    if (target && target->isAlive() && target->GetTypeId() == TYPEID_PLAYER &&
-+                        (target->GetHealth() > target->GetMaxHealth() * 0.05))
-+                        target->SetHealth(target->GetMaxHealth() * 0.05);
-+                }
-+            }
-+            // Move Zombies
-+            if (!m_lZombieGUIDList.empty())
-+            {
-+                for(std::list<uint64>::iterator itr = m_lZombieGUIDList.begin(); itr != m_lZombieGUIDList.end(); ++itr)
-+                    if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
-+                        if (pTemp->isAlive())
-+                        {
-+                            ((mob_zombie_chowsAI*)pTemp->AI())->bIsForceMove = true;
-+                            if (m_creature->GetHealth() > m_creature->GetMaxHealth() * 0.05) // remove when SPELL_DECIMATE is working
-+                                pTemp->SetHealth(pTemp->GetMaxHealth() * 0.02);
-+                            pTemp->AddThreat(m_creature, 1000000000.0f); // force move toward to Gluth
-+                        }
-+            }
-+            m_uiDecimateTimer = (m_bIsRegularMode ? 100000 : 120000);
-+        }else m_uiDecimateTimer -= uiDiff;
- 
-         // Enrage
-         if (m_uiEnrageTimer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature, m_bIsRegularMode ? SPELL_ENRAGE : SPELL_ENRAGE_H);
-+            DoCast(m_creature, m_bIsRegularMode ? SPELL_ENRAGE : SPELL_ENRAGE_H);
-             m_uiEnrageTimer = 60000;
-         }
-         else
-             m_uiEnrageTimer -= uiDiff;
- 
-+        if (RangeCheck_Timer < uiDiff)
-+        {
-+            if (!m_lZombieGUIDList.empty())
-+            {
-+                for(std::list<uint64>::iterator itr = m_lZombieGUIDList.begin(); itr != m_lZombieGUIDList.end(); ++itr)
-+                    if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
-+                        if (pTemp->isAlive() && m_creature->IsWithinDistInMap(pTemp, ATTACK_DISTANCE))
-+                        {
-+                            DoScriptText(EMOTE_ZOMBIE, m_creature);
-+                            m_creature->SetHealth(m_creature->GetHealth() + m_creature->GetMaxHealth() * 0.05);
-+                            pTemp->ForcedDespawn();
-+                        }
-+            }
-+            RangeCheck_Timer = 1000;
-+        }else RangeCheck_Timer -= uiDiff;
-+
-         // Summon
-         if (m_uiSummonTimer < uiDiff)
-         {
--            if (Creature* pZombie = m_creature->SummonCreature(NPC_ZOMBIE_CHOW, ADD_1X, ADD_1Y, ADD_1Z, 0.0f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 80000))
-+            if (Creature* pZombie = m_creature->SummonCreature(NPC_ZOMBIE_CHOW, ADD_5X, ADD_5Y, ADD_5Z, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 80000))
-             {
-                 if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
-+                {
-+                    m_lZombieGUIDList.push_back(pZombie->GetGUID());
-                     pZombie->AddThreat(pTarget);
-+                }
-             }
- 
-             if (!m_bIsRegularMode)
-             {
--                if (Creature* pZombie = m_creature->SummonCreature(NPC_ZOMBIE_CHOW, ADD_1X, ADD_1Y, ADD_1Z, 0.0f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 80000))
-+                if (Creature* pZombie = m_creature->SummonCreature(NPC_ZOMBIE_CHOW, ADD_9X, ADD_9Y, ADD_9Z, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 80000))
-                 {
-                     if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
-+                    {
-                         pZombie->AddThreat(pTarget);
-+                        m_lZombieGUIDList.push_back(pZombie->GetGUID());
-+                    }
-                 }
-             }
- 
-@@ -178,7 +278,7 @@ struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
-         // Berserk
-         if (m_uiBerserkTimer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature, SPELL_BERSERK, CAST_TRIGGERED);
-+            DoCast(m_creature, SPELL_BERSERK, true);
-             m_uiBerserkTimer = MINUTE*5*IN_MILLISECONDS;
-         }
-         else
-@@ -193,6 +293,11 @@ CreatureAI* GetAI_boss_gluth(Creature* pCreature)
-     return new boss_gluthAI(pCreature);
- }
- 
-+CreatureAI* GetAI_mob_zombie_chows(Creature* pCreature)
-+{
-+    return new mob_zombie_chowsAI(pCreature);
-+}
-+
- void AddSC_boss_gluth()
- {
-     Script* NewScript;
-@@ -200,4 +305,9 @@ void AddSC_boss_gluth()
-     NewScript->Name = "boss_gluth";
-     NewScript->GetAI = &GetAI_boss_gluth;
-     NewScript->RegisterSelf();
-+
-+    NewScript = new Script;
-+    NewScript->Name = "mob_zombie_chows";
-+    NewScript->GetAI = &GetAI_mob_zombie_chows;
-+    NewScript->RegisterSelf();
- }
-diff --git a/scripts/northrend/naxxramas/boss_gothik.cpp b/scripts/northrend/naxxramas/boss_gothik.cpp
-index 155043d..525b3c6 100644
---- a/scripts/northrend/naxxramas/boss_gothik.cpp
-+++ b/scripts/northrend/naxxramas/boss_gothik.cpp
-@@ -68,6 +68,10 @@ enum eSpellDummy
-     SPELL_C_TO_SKULL        = 27937
- };
- 
-+const float PosPlatform[4] = {2640.5f, -3360.6f, 285.26f, 0};
-+const float PosGroundLive[4] = {2692.174f, -3400.963f, 267.680f, 1.7f};
-+const float PosGroundDeath[4] = {2690.378f, -3328.279f, 267.681f, 1.7f};
-+
- struct MANGOS_DLL_DECL boss_gothikAI : public ScriptedAI
- {
-     boss_gothikAI(Creature* pCreature) : ScriptedAI(pCreature)
-@@ -157,6 +161,7 @@ struct MANGOS_DLL_DECL boss_gothikAI : public ScriptedAI
-     {
-         if (m_pInstance)
-             m_pInstance->SetData(TYPE_GOTHIK, FAIL);
-+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-     }
- 
-     void SummonAdds(bool bRightSide, uint32 uiSummonEntry)
-@@ -210,11 +215,21 @@ struct MANGOS_DLL_DECL boss_gothikAI : public ScriptedAI
-         }
-     }
- 
-+    void JustSummoned(Creature* pSummoned)
-+    {
-+        if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
-+            pSummoned->AI()->AttackStart(pTarget);
-+    }
-+
-     void UpdateAI(const uint32 uiDiff)
-     {
-         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-             return;
- 
-+        // remove for debug!
-+        if(!HasPlayersInLeftSide())
-+            m_creature->AI()->EnterEvadeMode();
-+
-         switch(m_uiPhase)
-         {
-             case PHASE_SPEECH:
-@@ -235,6 +250,8 @@ struct MANGOS_DLL_DECL boss_gothikAI : public ScriptedAI
-                 else
-                     m_uiSpeechTimer -= uiDiff;
- 
-+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+
-                 break;
-             }
-             case PHASE_BALCONY:
-@@ -332,6 +349,8 @@ struct MANGOS_DLL_DECL boss_gothikAI : public ScriptedAI
-                 else
-                     m_uiShadowboltTimer -= uiDiff;
- 
-+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+
-                 DoMeleeAttackIfReady();                     // possibly no melee at all
-                 break;
-             }
-diff --git a/scripts/northrend/naxxramas/boss_grobbulus.cpp b/scripts/northrend/naxxramas/boss_grobbulus.cpp
-index 5270203..64a234b 100644
---- a/scripts/northrend/naxxramas/boss_grobbulus.cpp
-+++ b/scripts/northrend/naxxramas/boss_grobbulus.cpp
-@@ -29,3 +29,172 @@ Enrages 26527*/
- 
- #include "precompiled.h"
- #include "naxxramas.h"
-+
-+#define SPELL_BOMBARD_SLIME         28280
-+
-+#define SPELL_POISON_CLOUD          28240
-+#define SPELL_MUTATING_INJECTION    28169
-+#define SPELL_SLIME_SPRAY           28157
-+#define H_SPELL_SLIME_SPRAY         54364
-+#define SPELL_BERSERK               26662
-+
-+#define MOB_FALLOUT_SLIME       16290
-+#define MOB_GROBBOLUS_CLOUD     16363
-+
-+struct MANGOS_DLL_DECL boss_grobbulusAI : public ScriptedAI
-+{
-+    boss_grobbulusAI(Creature* pCreature) : ScriptedAI(pCreature)
-+    {
-+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
-+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
-+        Reset();
-+    }
-+
-+    ScriptedInstance* m_pInstance;
-+    bool m_bIsRegularMode;
-+
-+    uint32 PoisonCloud_Timer;
-+    uint32 MutatingInjection_Timer;
-+    uint32 SlimeSpary_Timer;
-+    uint32 Enrage_Timer;
-+    std::list<Creature*> lClouds;
-+
-+    void Reset()
-+    {
-+        PoisonCloud_Timer = 15000;
-+        MutatingInjection_Timer = 20000;
-+        SlimeSpary_Timer = 15000+rand()%15000;
-+        Enrage_Timer = 720000;
-+
-+        DespawnAdds();
-+        lClouds.clear();
-+
-+        if (m_pInstance)
-+            m_pInstance->SetData(TYPE_GROBBULUS, NOT_STARTED);
-+    }
-+
-+    void JustDied(Unit* Killer)
-+    {
-+        if (m_pInstance)
-+            m_pInstance->SetData(TYPE_GROBBULUS, DONE);
-+        DespawnAdds();        
-+    }
-+
-+    void Aggro(Unit *who)
-+    {
-+        if (m_pInstance)
-+            m_pInstance->SetData(TYPE_GROBBULUS, IN_PROGRESS);
-+    }
-+
-+    void DespawnAdds()
-+    {
-+        GetCreatureListWithEntryInGrid(lClouds, m_creature, MOB_GROBBOLUS_CLOUD, DEFAULT_VISIBILITY_INSTANCE);
-+        if (!lClouds.empty())
-+        {
-+            for(std::list<Creature*>::iterator iter = lClouds.begin(); iter != lClouds.end(); ++iter)
-+            {
-+                if ((*iter) && (*iter)->isAlive())
-+                    (*iter)->ForcedDespawn();
-+            }
-+        }
-+    }
-+
-+    void SpellHitTarget(Unit *target, const SpellEntry *spell)
-+    {
-+        if(spell->Id == SPELL_SLIME_SPRAY || spell->Id == H_SPELL_SLIME_SPRAY)
-+        {
-+            if (Creature* pTemp = m_creature->SummonCreature(MOB_FALLOUT_SLIME, target->GetPositionX(), target->GetPositionY(), target->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 1000))
-+                if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
-+                {
-+                    pTemp->AddThreat(pTarget,0.0f);
-+                    pTemp->AI()->AttackStart(pTarget);
-+                }
-+        }
-+    }
-+
-+    void UpdateAI(const uint32 diff)
-+    {
-+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-+            return;
-+
-+        if (PoisonCloud_Timer < diff)
-+        {
-+            //DoCast(m_creature, SPELL_POISON_CLOUD);
-+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
-+                    m_creature->SummonCreature(MOB_GROBBOLUS_CLOUD, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 75000);
-+            PoisonCloud_Timer = 15000;
-+        }else PoisonCloud_Timer -= diff;
-+
-+        if (MutatingInjection_Timer < diff)
-+        {
-+            if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
-+                DoCast(target, SPELL_MUTATING_INJECTION);
-+
-+            MutatingInjection_Timer = 20000;
-+        }else MutatingInjection_Timer -= diff;
-+
-+        if (SlimeSpary_Timer < diff)
-+        {
-+            DoCast(m_creature, m_bIsRegularMode ? SPELL_SLIME_SPRAY : H_SPELL_SLIME_SPRAY);
-+            SlimeSpary_Timer = 15000+rand()%15000;
-+        }else SlimeSpary_Timer -= diff;
-+
-+        if (Enrage_Timer < diff)
-+        {
-+            DoCast(m_creature, SPELL_BERSERK);
-+            Enrage_Timer = 300000;
-+        }else Enrage_Timer -= diff;
-+
-+        DoMeleeAttackIfReady();
-+    }
-+};
-+
-+struct MANGOS_DLL_DECL npc_grobbulus_poison_cloudAI : public Scripted_NoMovementAI
-+{
-+    npc_grobbulus_poison_cloudAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
-+    {
-+        Reset();
-+    }
-+
-+    uint32 Cloud_Timer;
-+
-+    void Reset()
-+    {
-+        Cloud_Timer = 1000;
-+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+    }
-+
-+    void UpdateAI(const uint32 diff)
-+    {
-+        if (Cloud_Timer < diff)
-+        {
-+            DoCast(m_creature, 59116);
-+            Cloud_Timer = 10000;
-+        }else Cloud_Timer -= diff;
-+    }
-+};
-+
-+CreatureAI* GetAI_boss_grobbulus(Creature* pCreature)
-+{
-+    return new boss_grobbulusAI(pCreature);
-+}
-+
-+CreatureAI* GetAI_npc_grobbulus_poison_cloud(Creature* pCreature)
-+{
-+    return new npc_grobbulus_poison_cloudAI(pCreature);
-+}
-+
-+void AddSC_boss_grobbulus()
-+{
-+    Script *newscript;
-+    newscript = new Script;
-+    newscript->Name = "boss_grobbulus";
-+    newscript->GetAI = &GetAI_boss_grobbulus;
-+    newscript->RegisterSelf();
-+
-+    newscript = new Script;
-+    newscript->Name = "npc_grobbulus_poison_cloud";
-+    newscript->GetAI = &GetAI_npc_grobbulus_poison_cloud;
-+    newscript->RegisterSelf();
-+}
-+
-diff --git a/scripts/northrend/naxxramas/boss_kelthuzad.cpp b/scripts/northrend/naxxramas/boss_kelthuzad.cpp
-index b016b8b..8795a59 100644
---- a/scripts/northrend/naxxramas/boss_kelthuzad.cpp
-+++ b/scripts/northrend/naxxramas/boss_kelthuzad.cpp
-@@ -82,13 +82,25 @@ enum
- 
-     SPELL_MANA_DETONATION               = 27819,
-     SPELL_SHADOW_FISSURE                = 27810,
--    SPELL_FROST_BLAST                   = 27808
-+    SPELL_FROST_BLAST                   = 27808,
-+
-+    // abomination
-+    SPELL_FRENZY                        = 28468,
-+    SPELL_MORTAL_WOUND                  = 28467,
-+
-+    ACHIEV_JUST_CANT_GET_ENOUGH         = 2184,
-+    ACHIEV_JUST_CANT_GET_ENOUGH_H       = 2185,
- };
- 
- static float M_F_ANGLE = 0.2f;                              // to adjust for map rotation
- static float M_F_HEIGHT = 2.0f;                             // adjust for height difference
- static float M_F_RANGE = 55.0f;                             // ~ range from center of chamber to center of alcove
- 
-+#define HOME_X                      3748.0f
-+#define HOME_Y                      -5113.0f
-+
-+uint8 m_uiAbominationsDead;
-+
- struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
- {
-     boss_kelthuzadAI(Creature* pCreature) : ScriptedAI(pCreature)
-@@ -158,6 +170,8 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
- 
-         // it may be some spell should be used instead, to control the intro phase
-         m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-+
-+        m_uiAbominationsDead = 0;
-     }
- 
-     void KilledUnit(Unit* pVictim)
-@@ -179,11 +193,18 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
-                     continue;
- 
-                 pGuardian->AI()->EnterEvadeMode();
-+                pGuardian->ForcedDespawn();
-             }
-         }
- 
-         if (m_pInstance)
-             m_pInstance->SetData(TYPE_KELTHUZAD, DONE);
-+
-+        if(m_uiAbominationsDead >= 18)
-+        {
-+            if(m_pInstance)
-+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_JUST_CANT_GET_ENOUGH : ACHIEV_JUST_CANT_GET_ENOUGH_H);
-+        }
-     }
- 
-     void MoveInLineOfSight(Unit* pWho)
-@@ -221,7 +242,8 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
-             for(std::set<uint64>::iterator itr = m_lSoldierSet.begin(); itr != m_lSoldierSet.end(); ++itr)
-             {
-                 if (Creature* pSoldier = m_pInstance->instance->GetCreature(*itr))
--                    pSoldier->ForcedDespawn();
-+                    if(!pSoldier->getVictim())
-+                        pSoldier->ForcedDespawn();
-             }
-         }
- 
-@@ -230,7 +252,8 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
-             for(std::set<uint64>::iterator itr = m_lUndeadSet.begin(); itr != m_lUndeadSet.end(); ++itr)
-             {
-                 if (Creature* pSoldier = m_pInstance->instance->GetCreature(*itr))
--                    pSoldier->ForcedDespawn();
-+                    if(!pSoldier->getVictim())
-+                        pSoldier->ForcedDespawn();
-             }
-         }
- 
-@@ -422,6 +445,9 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
- 
-     void UpdateAI(const uint32 uiDiff)
-     {
-+        if (m_creature->GetDistance2d(HOME_X, HOME_Y) > 80)
-+            EnterEvadeMode();
-+
-         if (m_creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
-         {
-             if (!m_pInstance)
-@@ -443,6 +469,7 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
-                 float fx, fy, fz;
-                 m_pInstance->GetChamberCenterCoords(fx, fy, fz);
-                 m_creature->GetMotionMaster()->MovePoint(0, fx, fy, fz);
-+                DespawnAllIntroCreatures();
- 
-                 DoScriptText(EMOTE_PHASE2, m_creature);
-                 return;
-@@ -566,6 +593,61 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
-     }
- };
- 
-+struct MANGOS_DLL_DECL mob_unstoppable_abominationAI : public ScriptedAI
-+{
-+    mob_unstoppable_abominationAI(Creature* pCreature) : ScriptedAI(pCreature)
-+    {
-+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
-+        Reset();
-+    }
-+
-+    ScriptedInstance* m_pInstance;
-+
-+    uint32 m_uiMortalWoundTimer;
-+    uint32 m_uiFrenzyTimer;
-+    bool m_bHasFrenzy;
-+
-+    void Reset()
-+    {
-+        m_uiMortalWoundTimer = 5000;
-+        m_uiFrenzyTimer = 15000;
-+        m_bHasFrenzy = false;
-+    }
-+
-+    void JustDied(Unit* pKiller)
-+    {
-+        ++m_uiAbominationsDead;
-+    }
-+
-+    void UpdateAI(const uint32 uiDiff)
-+    {
-+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-+            return;
-+
-+        if (m_uiMortalWoundTimer < uiDiff)
-+        {
-+            DoCast(m_creature->getVictim(), SPELL_MORTAL_WOUND);
-+            m_uiMortalWoundTimer = urand(5000, 7000);
-+        }
-+        else m_uiMortalWoundTimer -= uiDiff;
-+
-+        if (m_uiFrenzyTimer < uiDiff && !m_bHasFrenzy)
-+        {
-+            DoCast(m_creature, SPELL_FRENZY);
-+            m_bHasFrenzy = true;
-+            m_uiFrenzyTimer = 0;
-+        }
-+        else m_uiFrenzyTimer -= uiDiff;
-+
-+        DoMeleeAttackIfReady();
-+    }
-+};
-+
-+CreatureAI* GetAI_mob_unstoppable_abomination(Creature* pCreature)
-+{
-+    return new mob_unstoppable_abominationAI(pCreature);
-+}
-+
- CreatureAI* GetAI_boss_kelthuzad(Creature* pCreature)
- {
-     return new boss_kelthuzadAI(pCreature);
-@@ -579,4 +661,9 @@ void AddSC_boss_kelthuzad()
-     NewScript->Name = "boss_kelthuzad";
-     NewScript->GetAI = &GetAI_boss_kelthuzad;
-     NewScript->RegisterSelf();
-+
-+    NewScript = new Script;
-+    NewScript->Name = "mob_unstoppable_abomination";
-+    NewScript->GetAI = &GetAI_mob_unstoppable_abomination;
-+    NewScript->RegisterSelf();
- }
-diff --git a/scripts/northrend/naxxramas/boss_loatheb.cpp b/scripts/northrend/naxxramas/boss_loatheb.cpp
-index 853941b..707b5c7 100644
---- a/scripts/northrend/naxxramas/boss_loatheb.cpp
-+++ b/scripts/northrend/naxxramas/boss_loatheb.cpp
-@@ -38,9 +38,15 @@ enum
-     SPELL_SUMMON_SPORE      = 29234,
-     SPELL_BERSERK           = 26662,
- 
--    NPC_SPORE               = 16286
-+    SPELL_FUNGAL_CREEP      = 29232,
-+    NPC_SPORE               = 16286,
-+
-+    ACHIEV_SPORE_LOSER      = 2182,
-+    ACHIEV_SPORE_LOSER_H    = 2183,
- };
- 
-+bool m_bHasSporeDied;
-+
- struct MANGOS_DLL_DECL boss_loathebAI : public ScriptedAI
- {
-     boss_loathebAI(Creature* pCreature) : ScriptedAI(pCreature)
-@@ -68,6 +74,7 @@ struct MANGOS_DLL_DECL boss_loathebAI : public ScriptedAI
-         m_uiSummonTimer = urand(10000, 15000);              // first seen in vid after approx 12s
-         m_uiBerserkTimer = MINUTE*12*IN_MILLISECONDS;       // only in heroic, after 12min
-         m_uiNecroticAuraCount = 0;
-+        m_bHasSporeDied = false;
-     }
- 
-     void Aggro(Unit* pWho)
-@@ -80,6 +87,12 @@ struct MANGOS_DLL_DECL boss_loathebAI : public ScriptedAI
-     {
-         if (m_pInstance)
-             m_pInstance->SetData(TYPE_LOATHEB, DONE);
-+
-+        if (!m_bHasSporeDied)
-+        {
-+            if(m_pInstance)
-+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_SPORE_LOSER : ACHIEV_SPORE_LOSER_H);
-+        }
-     }
- 
-     void JustReachedHome()
-@@ -172,11 +185,67 @@ struct MANGOS_DLL_DECL boss_loathebAI : public ScriptedAI
-     }
- };
- 
-+struct MANGOS_DLL_DECL npc_loatheb_sporesAI : public ScriptedAI
-+{
-+    npc_loatheb_sporesAI(Creature* pCreature) : ScriptedAI(pCreature)
-+    {
-+        Reset();
-+    }
-+
-+    uint32 DieDelay_Timer;
-+
-+    void Reset()
-+    {
-+        DieDelay_Timer = 0;
-+    }
-+
-+    void DamageTaken(Unit* done_by, uint32 &damage)
-+    {
-+        if (damage > m_creature->GetHealth() && !DieDelay_Timer)
-+        {
-+            m_creature->CastSpell(m_creature, SPELL_FUNGAL_CREEP, true);
-+            m_creature->SetHealth(m_creature->GetMaxHealth());
-+            DieDelay_Timer = 500;
-+        }
-+        if (DieDelay_Timer)
-+        {
-+            damage = 0;
-+            return;
-+        }
-+    }
-+
-+    void JustDied(Unit* Killer) 
-+    {
-+        if(Killer != GetClosestCreatureWithEntry(m_creature, NPC_LOATHEB, 80.0f))
-+            m_bHasSporeDied = true;
-+    }
-+
-+    void UpdateAI(const uint32 diff)
-+    {
-+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-+            return;
-+
-+        if (DieDelay_Timer)
-+            if (DieDelay_Timer < diff)
-+            {
-+                m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
-+                DieDelay_Timer = 0;
-+            }else DieDelay_Timer -= diff;
-+
-+        DoMeleeAttackIfReady();
-+    }
-+};
-+
- CreatureAI* GetAI_boss_loatheb(Creature* pCreature)
- {
-     return new boss_loathebAI(pCreature);
- }
- 
-+CreatureAI* GetAI_npc_loatheb_spores(Creature* pCreature)
-+{
-+    return new npc_loatheb_sporesAI(pCreature);
-+}
-+
- void AddSC_boss_loatheb()
- {
-     Script* NewScript;
-@@ -184,4 +253,9 @@ void AddSC_boss_loatheb()
-     NewScript->Name = "boss_loatheb";
-     NewScript->GetAI = &GetAI_boss_loatheb;
-     NewScript->RegisterSelf();
-+
-+    NewScript = new Script;
-+    NewScript->Name = "npc_loatheb_spores";
-+    NewScript->GetAI = &GetAI_npc_loatheb_spores;
-+    NewScript->RegisterSelf();
- }
-diff --git a/scripts/northrend/naxxramas/boss_maexxna.cpp b/scripts/northrend/naxxramas/boss_maexxna.cpp
-index eb9a525..3416213 100644
---- a/scripts/northrend/naxxramas/boss_maexxna.cpp
-+++ b/scripts/northrend/naxxramas/boss_maexxna.cpp
-@@ -39,6 +39,7 @@ enum
- 
-     //spellId invalid
-     SPELL_SUMMON_SPIDERLING = 29434,
-+    NPC_SPIDERLING          = 17055
- };
- 
- #define LOC_X1    3546.796f
-@@ -189,6 +190,24 @@ struct MANGOS_DLL_DECL boss_maexxnaAI : public ScriptedAI
-         }
-     }
- 
-+    void SummonSpiderling()
-+    {
-+        uint8 number = 9;
-+        float x,y,z;
-+        for(uint8 i = 0; number >= i; i++)
-+        {
-+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
-+            {
-+                m_creature->GetRandomPoint(m_creature->GetPositionX(),m_creature->GetPositionY(),m_creature->GetPositionZ(),7.0f,x,y,z);
-+                if(Creature* spiderling = m_creature->SummonCreature(NPC_SPIDERLING, x, y, z,0, TEMPSUMMON_DEAD_DESPAWN, 0))
-+                {
-+                    spiderling->AddThreat(pTarget, 0.0f);
-+                    spiderling->AI()->AttackStart(pTarget);
-+                }
-+            }
-+        }
-+    }
-+
-     void UpdateAI(const uint32 uiDiff)
-     {
-         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-@@ -233,7 +252,8 @@ struct MANGOS_DLL_DECL boss_maexxnaAI : public ScriptedAI
-         // Summon Spiderling
-         if (m_uiSummonSpiderlingTimer < uiDiff)
-         {
--            DoCastSpellIfCan(m_creature, SPELL_SUMMON_SPIDERLING);
-+            //DoCastSpellIfCan(m_creature, SPELL_SUMMON_SPIDERLING);
-+            SummonSpiderling();
-             m_uiSummonSpiderlingTimer = 40000;
-         }
-         else
-diff --git a/scripts/northrend/naxxramas/boss_noth.cpp b/scripts/northrend/naxxramas/boss_noth.cpp
-index a1e8349..41ae5d4 100644
---- a/scripts/northrend/naxxramas/boss_noth.cpp
-+++ b/scripts/northrend/naxxramas/boss_noth.cpp
-@@ -111,6 +111,9 @@ struct MANGOS_DLL_DECL boss_nothAI : public ScriptedAI
-         m_uiBlinkTimer = 25000;
-         m_uiCurseTimer = 4000;
-         m_uiSummonTimer = 30000;
-+
-+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-     }
- 
-     void Aggro(Unit* pWho)
-@@ -173,6 +176,8 @@ struct MANGOS_DLL_DECL boss_nothAI : public ScriptedAI
-                 {
-                     DoScriptText(EMOTE_TELEPORT, m_creature);
-                     m_creature->GetMotionMaster()->MoveIdle();
-+                    m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-+                    m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                     m_uiPhaseTimer = 70000;
-                     m_uiPhase = PHASE_BALCONY;
-                     ++m_uiPhaseSub;
-@@ -243,6 +248,8 @@ struct MANGOS_DLL_DECL boss_nothAI : public ScriptedAI
-                 if (DoCastSpellIfCan(m_creature, SPELL_TELEPORT_RETURN) == CAST_OK)
-                 {
-                     DoScriptText(EMOTE_TELEPORT_RETURN, m_creature);
-+                    m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-+                    m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
-                     m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
-                     m_uiPhaseTimer = 90000;
-                     m_uiPhase = PHASE_GROUND;
-diff --git a/scripts/northrend/naxxramas/boss_patchwerk.cpp b/scripts/northrend/naxxramas/boss_patchwerk.cpp
-index 3e7a23e..95e0b98 100644
---- a/scripts/northrend/naxxramas/boss_patchwerk.cpp
-+++ b/scripts/northrend/naxxramas/boss_patchwerk.cpp
-@@ -38,7 +38,10 @@ enum
-     SPELL_HATEFULSTRIKE_H = 59192,
-     SPELL_ENRAGE          = 28131,
-     SPELL_BERSERK         = 26662,
--    SPELL_SLIMEBOLT       = 32309
-+    SPELL_SLIMEBOLT       = 32309,
-+
-+    ACHIEV_QUICK_WERK       = 1856,
-+    ACHIEV_QUICK_WERK_H     = 1857,
- };
- 
- struct MANGOS_DLL_DECL boss_patchwerkAI : public ScriptedAI
-@@ -59,6 +62,8 @@ struct MANGOS_DLL_DECL boss_patchwerkAI : public ScriptedAI
-     bool   m_bEnraged;
-     bool   m_bBerserk;
- 
-+    uint32 uiEncounterTimer;
-+
-     void Reset()
-     {
-         m_uiHatefulStrikeTimer = 1000;                      //1 second
-@@ -66,6 +71,7 @@ struct MANGOS_DLL_DECL boss_patchwerkAI : public ScriptedAI
-         m_uiSlimeboltTimer = 10000;
-         m_bEnraged = false;
-         m_bBerserk = false;
-+        uiEncounterTimer = 0;
-     }
- 
-     void KilledUnit(Unit* pVictim)
-@@ -82,6 +88,12 @@ struct MANGOS_DLL_DECL boss_patchwerkAI : public ScriptedAI
- 
-         if (m_pInstance)
-             m_pInstance->SetData(TYPE_PATCHWERK, DONE);
-+
-+        if (uiEncounterTimer < 180000)
-+        {
-+            if(m_pInstance)
-+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_QUICK_WERK : ACHIEV_QUICK_WERK_H);
-+        }
-     }
- 
-     void Aggro(Unit* pWho)
-@@ -132,6 +144,8 @@ struct MANGOS_DLL_DECL boss_patchwerkAI : public ScriptedAI
-         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-             return;
- 
-+        uiEncounterTimer += uiDiff;
-+
-         // Hateful Strike
-         if (m_uiHatefulStrikeTimer < uiDiff)
-         {
-diff --git a/scripts/northrend/naxxramas/boss_razuvious.cpp b/scripts/northrend/naxxramas/boss_razuvious.cpp
-index fe732ce..142725a 100644
---- a/scripts/northrend/naxxramas/boss_razuvious.cpp
-+++ b/scripts/northrend/naxxramas/boss_razuvious.cpp
-@@ -41,9 +41,33 @@ enum
-     SPELL_DISRUPTING_SHOUT   = 55543,
-     SPELL_DISRUPTING_SHOUT_H = 29107,
-     SPELL_JAGGED_KNIFE       = 55550,
--    SPELL_HOPELESS           = 29125
-+    SPELL_HOPELESS           = 29125,
-+
-+    SPELL_FORCE_OBEDIENCE   = 55479,
-+    NPC_DEATH_KNIGHT_UNDERSTUDY = 16803
- };
- 
-+bool GossipHello_npc_obedience_crystal(Player* pPlayer, Creature* pCreature)
-+{
-+    ScriptedInstance *pInstance = (ScriptedInstance *) pCreature->GetInstanceData();
-+    if(pInstance->GetData(TYPE_RAZUVIOUS) != DONE)
-+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "To use Mind Control click here !", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
-+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
-+    return true;
-+}
-+
-+bool GossipSelect_npc_obedience_crystal(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
-+{
-+    if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
-+    {
-+        if (Unit* target = GetClosestCreatureWithEntry(pCreature, NPC_DEATH_KNIGHT_UNDERSTUDY, 100.0f))
-+            pPlayer->CastSpell(target, SPELL_FORCE_OBEDIENCE, true);
-+        pPlayer->CLOSE_GOSSIP_MENU();
-+        pPlayer->TalkedToCreature(pCreature->GetEntry(), pCreature->GetGUID());
-+    }
-+    return true;
-+}
-+
- struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
- {
-     boss_razuviousAI(Creature* pCreature) : ScriptedAI(pCreature)
-@@ -60,6 +84,9 @@ struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
-     uint32 m_uiDisruptingShoutTimer;
-     uint32 m_uiJaggedKnifeTimer;
-     uint32 m_uiCommandSoundTimer;
-+    uint32 m_uiAggroCheckTimer;
-+
-+    std::list<Creature*> lUnderstudies;
- 
-     void Reset()
-     {
-@@ -67,6 +94,17 @@ struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
-         m_uiDisruptingShoutTimer   = 15000;                 // 15 seconds
-         m_uiJaggedKnifeTimer       = urand(10000, 15000);
-         m_uiCommandSoundTimer      = 40000;                 // 40 seconds
-+        m_uiAggroCheckTimer         = 1000;
-+
-+        GetCreatureListWithEntryInGrid(lUnderstudies, m_creature, NPC_DEATH_KNIGHT_UNDERSTUDY, DEFAULT_VISIBILITY_INSTANCE);
-+        if (!lUnderstudies.empty())
-+        {
-+            for(std::list<Creature*>::iterator iter = lUnderstudies.begin(); iter != lUnderstudies.end(); ++iter)
-+            {
-+                if ((*iter) && !(*iter)->isAlive())
-+                    (*iter)->Respawn();
-+            }
-+        }
-     }
- 
-     void KilledUnit(Unit* Victim)
-@@ -87,6 +125,16 @@ struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
- 
-         if (m_pInstance)
-             m_pInstance->SetData(TYPE_RAZUVIOUS, DONE);
-+
-+        GetCreatureListWithEntryInGrid(lUnderstudies, m_creature, NPC_DEATH_KNIGHT_UNDERSTUDY, DEFAULT_VISIBILITY_INSTANCE);
-+        if (!lUnderstudies.empty())
-+        {
-+            for(std::list<Creature*>::iterator iter = lUnderstudies.begin(); iter != lUnderstudies.end(); ++iter)
-+            {
-+                if ((*iter) && (*iter)->isAlive())
-+                    (*iter)->ForcedDespawn();
-+            }
-+        }
-     }
- 
-     void Aggro(Unit* pWho)
-@@ -100,6 +148,16 @@ struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
- 
-         if (m_pInstance)
-             m_pInstance->SetData(TYPE_RAZUVIOUS, IN_PROGRESS);
-+
-+        GetCreatureListWithEntryInGrid(lUnderstudies, m_creature, NPC_DEATH_KNIGHT_UNDERSTUDY, DEFAULT_VISIBILITY_INSTANCE);
-+        if (!lUnderstudies.empty())
-+        {
-+            for(std::list<Creature*>::iterator iter = lUnderstudies.begin(); iter != lUnderstudies.end(); ++iter)
-+            {
-+                if ((*iter) && (*iter)->isAlive())
-+                    (*iter)->AI()->AttackStart(m_creature->getVictim());
-+            }
-+        }
-     }
- 
-     void JustReachedHome()
-@@ -110,6 +168,22 @@ struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
- 
-     void UpdateAI(const uint32 uiDiff)
-     {
-+        if (m_uiAggroCheckTimer < uiDiff && m_pInstance->GetData(TYPE_RAZUVIOUS) != IN_PROGRESS)
-+        {
-+            GetCreatureListWithEntryInGrid(lUnderstudies, m_creature, NPC_DEATH_KNIGHT_UNDERSTUDY, DEFAULT_VISIBILITY_INSTANCE);
-+            if (!lUnderstudies.empty())
-+            {
-+                for(std::list<Creature*>::iterator iter = lUnderstudies.begin(); iter != lUnderstudies.end(); ++iter)
-+                {
-+                    if ((*iter) && (*iter)->isAlive() && (*iter)->getVictim())
-+                        m_creature->AI()->AttackStart((*iter)->getVictim());
-+                }
-+            }
-+            m_uiAggroCheckTimer = 1000;
-+        }
-+        else
-+            m_uiAggroCheckTimer -= uiDiff;
-+
-         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-             return;
- 
-@@ -172,4 +246,10 @@ void AddSC_boss_razuvious()
-     NewScript->Name = "boss_razuvious";
-     NewScript->GetAI = &GetAI_boss_razuvious;
-     NewScript->RegisterSelf();
-+
-+    NewScript = new Script;
-+    NewScript->Name = "npc_obedience_crystal";
-+    NewScript->pGossipHello =  &GossipHello_npc_obedience_crystal;
-+    NewScript->pGossipSelect = &GossipSelect_npc_obedience_crystal;
-+    NewScript->RegisterSelf();
- }
-diff --git a/scripts/northrend/naxxramas/boss_sapphiron.cpp b/scripts/northrend/naxxramas/boss_sapphiron.cpp
-index 3ceb9af..57ea12c 100644
---- a/scripts/northrend/naxxramas/boss_sapphiron.cpp
-+++ b/scripts/northrend/naxxramas/boss_sapphiron.cpp
-@@ -29,12 +29,24 @@ enum
-     EMOTE_BREATH       = -1533082,
-     EMOTE_ENRAGE       = -1533083,
- 
--    SPELL_ICEBOLT      = 28522,
--    SPELL_FROST_BREATH = 29318,
--    SPELL_FROST_AURA   = 28531,
--    SPELL_LIFE_DRAIN   = 28542,
--    SPELL_BLIZZARD     = 28547,
--    SPELL_BESERK       = 26662
-+    SPELL_ICEBOLT           = 28522,
-+    SPELL_FROST_BREATH      = 29318,
-+    SPELL_FROST_BREATH_H    = 28524,
-+    SPELL_FROST_AURA        = 28531,
-+    SPELL_LIFE_DRAIN        = 28542,
-+    SPELL_LIFE_DRAIN_H      = 55665,
-+    SPELL_BLIZZARD          = 28547,
-+    SPELL_BESERK            = 26662,
-+    SPELL_CLEAVE           = 19983,
-+    SPELL_TAIL_LASH        = 55697,
-+    SPELL_TAIL_LASH_H      = 55696,
-+
-+    SAPPHIRON_X            = 3522,
-+    SAPPHIRON_Y            = -5236,
-+    SAPPHIRON_Z            = 137, 
-+
-+    ACHIEV_THE_HUNDRED_CLUB     = 2146,
-+    ACHIEV_THE_HUNDRED_CLUB_H   = 2147,
- };
- 
- struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
-@@ -57,10 +69,19 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
-     uint32 Blizzard_Timer;
-     uint32 Fly_Timer;
-     uint32 Beserk_Timer;
-+    uint32 m_uiCleaveTimer;
-+    uint32 m_uiTailSweepTimer;
-     uint32 phase;
-     bool landoff;
-     uint32 land_Timer;
- 
-+    bool isAtGround;
-+    std::vector<Unit*> targets;
-+    uint32 land_time;
-+
-+    bool m_bHasResistance;
-+    uint32 m_uiResistanceCheckTimer;
-+
-     void Reset()
-     {
-         FrostAura_Timer = 2000;
-@@ -70,24 +91,42 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
-         Fly_Timer = 45000;
-         Icebolt_Timer = 4000;
-         land_Timer = 2000;
--        Beserk_Timer = 0;
-+        Beserk_Timer = 900000;
-+        m_uiCleaveTimer = 7000;
-+        m_uiTailSweepTimer = 20000;
-         phase = 1;
-         Icebolt_Count = 0;
-         landoff = false;
-+        isAtGround = true;
-+        targets.clear();
-+        land_time = 0;
-+
-+        m_bHasResistance = false;
-+        m_uiResistanceCheckTimer = 1000;
- 
-         //m_creature->ApplySpellMod(SPELL_FROST_AURA, SPELLMOD_DURATION, -1);
-+
-+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 0);
-+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
-     }
- 
-     void Aggro(Unit* pWho)
-     {
-         if (m_pInstance)
-             m_pInstance->SetData(TYPE_SAPPHIRON, IN_PROGRESS);
-+        CheckResistance();
-     }
- 
-     void JustDied(Unit* pKiller)
-     {
-         if (m_pInstance)
-             m_pInstance->SetData(TYPE_SAPPHIRON, DONE);
-+
-+        if (!m_bHasResistance)
-+        {
-+            if(m_pInstance)
-+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_THE_HUNDRED_CLUB : ACHIEV_THE_HUNDRED_CLUB_H);
-+        }
-     }
- 
-     void JustReachedHome()
-@@ -96,11 +135,56 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
-             m_pInstance->SetData(TYPE_SAPPHIRON, FAIL);
-     }
- 
-+    void CheckResistance()
-+    {
-+        Map* pMap = m_creature->GetMap();
-+        if (!m_bHasResistance && pMap && pMap->IsDungeon())
-+        {
-+            Map::PlayerList const &players = pMap->GetPlayers();
-+            for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
-+                if(itr->getSource()->GetResistance(SPELL_SCHOOL_FROST) > 100)
-+                    m_bHasResistance = true;
-+        }
-+    }
-+
-+    void SpellHitTarget(Unit *target, const SpellEntry *spell)
-+    {
-+        if(spell->Id == SPELL_ICEBOLT)
-+        {
-+            if (target->isAlive() && target->HasAura(SPELL_ICEBOLT))
-+            {
-+                target->CastSpell(target, 62766, true);
-+                target->ApplySpellImmune(0, IMMUNITY_SCHOOL, SPELL_SCHOOL_MASK_FROST, true);
-+            }
-+            return;
-+        }
-+
-+        if(spell->Id == SPELL_FROST_BREATH || spell->Id == SPELL_FROST_BREATH_H)
-+        {
-+            if (target->GetTypeId() != TYPEID_PLAYER)
-+                return;
-+
-+            if (target->HasAura(SPELL_ICEBOLT))
-+            {
-+                target->RemoveAurasDueToSpell(62766);
-+                target->RemoveAurasDueToSpell(SPELL_ICEBOLT);
-+                target->ApplySpellImmune(0, IMMUNITY_SCHOOL, SPELL_SCHOOL_MASK_FROST, false);
-+                return;
-+            }
-+        }
-+    }
-+
-     void UpdateAI(const uint32 uiDiff)
-     {
-         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-             return;
- 
-+         if (m_uiResistanceCheckTimer < uiDiff && !m_bHasResistance)
-+        {
-+            CheckResistance();
-+            m_uiResistanceCheckTimer = 1000;
-+        }else m_uiResistanceCheckTimer -= uiDiff;
-+
-         if (phase == 1)
-         {
-             if (FrostAura_Timer < uiDiff)
-@@ -111,35 +195,55 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
- 
-             if (LifeDrain_Timer < uiDiff)
-             {
--                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM,0))
--                    DoCastSpellIfCan(target,SPELL_LIFE_DRAIN);
-+                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
-+                    DoCastSpellIfCan(target,m_bIsRegularMode ? SPELL_LIFE_DRAIN : SPELL_LIFE_DRAIN_H);
- 
-                 LifeDrain_Timer = 24000;
-             }else LifeDrain_Timer -= uiDiff;
- 
-             if (Blizzard_Timer < uiDiff)
-             {
--                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM,0))
-+                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
-                     DoCastSpellIfCan(target,SPELL_BLIZZARD);
- 
-                 Blizzard_Timer = 20000;
-             }else Blizzard_Timer -= uiDiff;
- 
-+            // Cleave
-+            if (m_uiCleaveTimer < uiDiff)
-+            {
-+                DoCast(m_creature->getVictim(), SPELL_CLEAVE);
-+                m_uiCleaveTimer = 7000 + rand()%3000;
-+            }
-+            else
-+                m_uiCleaveTimer -= uiDiff;
-+
-+            // Tail Sweep
-+            if (m_uiTailSweepTimer < uiDiff)
-+            {
-+                DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_TAIL_LASH : SPELL_TAIL_LASH_H);
-+                m_uiTailSweepTimer = 15000 + rand()%5000;
-+            }
-+            else
-+                m_uiTailSweepTimer -= uiDiff;
-+
-             if (m_creature->GetHealthPercent() > 10.0f)
-             {
-                 if (Fly_Timer < uiDiff)
-                 {
-                     phase = 2;
-                     m_creature->InterruptNonMeleeSpells(false);
-+                    m_creature->StopMoving();
-                     m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
-                     m_creature->GetMotionMaster()->Clear(false);
-                     m_creature->GetMotionMaster()->MoveIdle();
--                    DoCastSpellIfCan(m_creature,11010);
--                    m_creature->SetHover(true);
--                    DoCastSpellIfCan(m_creature,18430);
-+                    m_creature->GetMap()->CreatureRelocation(m_creature, SAPPHIRON_X, SAPPHIRON_Y, SAPPHIRON_Z + 20, m_creature->GetOrientation()); 
-+                    m_creature->SendMonsterMove(SAPPHIRON_X, SAPPHIRON_Y, SAPPHIRON_Z + 20, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
-                     Icebolt_Timer = 4000;
-                     Icebolt_Count = 0;
-                     landoff = false;
-+                    m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 50331648);
-+                    m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 50331648);
-                 }else Fly_Timer -= uiDiff;
-             }
-         }
-@@ -148,7 +252,7 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
-         {
-             if (Icebolt_Timer < uiDiff && Icebolt_Count < 5)
-             {
--                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM,0))
-+                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
-                     DoCastSpellIfCan(target,SPELL_ICEBOLT);
- 
-                 ++Icebolt_Count;
-@@ -176,11 +280,22 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
-                     m_creature->SetHover(false);
-                     m_creature->GetMotionMaster()->Clear(false);
-                     m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
-+                    m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 0);
-+                    m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
-                     Fly_Timer = 67000;
-                 }else land_Timer -= uiDiff;
-             }
-         }
- 
-+        if(phase == 1 && isAtGround == false)
-+        {
-+            if(land_time < uiDiff)
-+            {
-+                isAtGround = true;
-+                DoStartMovement(m_creature->getVictim());
-+            }else land_time -=uiDiff;
-+        }
-+
-         if (m_creature->GetHealthPercent() <= 10.0f)
-         {
-             if (Beserk_Timer < uiDiff)
-@@ -191,7 +306,7 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
-             }else Beserk_Timer -= uiDiff;
-         }
- 
--        if (phase!=2)
-+        if (phase!=2 && isAtGround == true)
-             DoMeleeAttackIfReady();
-     }
- };
-diff --git a/scripts/northrend/naxxramas/boss_thaddius.cpp b/scripts/northrend/naxxramas/boss_thaddius.cpp
-index 3c31172..9d71285 100644
---- a/scripts/northrend/naxxramas/boss_thaddius.cpp
-+++ b/scripts/northrend/naxxramas/boss_thaddius.cpp
-@@ -31,13 +31,17 @@ enum
-     SAY_STAL_SLAY                 = -1533024,
-     SAY_STAL_DEATH                = -1533025,
- 
--    SPELL_POWERSURGE              = 28134,
-+    SPELL_POWERSURGE                = 28134,
-+    SPELL_POWERSURGE_H              = 54529,
- 
-     //Feugen
-     SAY_FEUG_AGGRO                = -1533026,
-     SAY_FEUG_SLAY                 = -1533027,
-     SAY_FEUG_DEATH                = -1533028,
- 
-+    SPELL_STATIC_FIELD              = 28135,
-+    SPELL_STATIC_FIELD_H            = 54528,
-+
-     SPELL_MANABURN                = 28135,
- 
-     //both
-@@ -55,20 +59,880 @@ enum
-     SAY_SCREAM2                   = -1533037,
-     SAY_SCREAM3                   = -1533038,
-     SAY_SCREAM4                   = -1533039,
-+    EMOTE_POLARITY_SHIFT            = -1533149,
-+ 
-+    SPELL_THADIUS_STUN              = 28160,
-+    SPELL_THADIUS_LIGHTNING_VISUAL  = 28136,
-+    SPELL_BALL_LIGHTNING            = 28299,
-+    SPELL_CHAIN_LIGHTNING           = 28167,
-+    SPELL_CHAIN_LIGHTNING_H         = 54531,
-+    SPELL_POLARITY_SHIFT            = 28089,
-+    SPELL_BESERK                    = 27680,
-+ 
-+    // Tesla Coils
-+    EMOTE_LOSING_LINK               = -1533147,
-+    EMOTE_TESLA_OVERLOAD            = -1533148,
-+ 
-+    SPELL_FEUGEN_CHAIN              = 28111,
-+    SPELL_STALAGG_CHAIN             = 28096,
-+    SPELL_SHOCK_OVERLOAD            = 28159,
-+    SPELL_SHOCK                     = 28099,
-+    SPELL_BREAK_CHANNEL             = 28087,
-+
-+    SPELL_POSITIVE_CHARGE           = 28059,
-+    SPELL_NEGATIVE_CHARGE           = 28084,
-+
-+    ACHIEV_SUBSTRACTION             = 2180,
-+    ACHIEV_SUBSTRACTION_H           = 2181,
-+
-+    ACHIEV_SHOCKING                 = 2178,     // needs advanced script support
-+    ACHIEV_SHOCKING_H               = 2179,
-+ 
-+    PHASE_TESLA_DO_NOTHING          = 0,
-+    PHASE_TESLA_SETUP_CHAINS        = 1,
-+    PHASE_TESLA_SHOCK_OR_REAPPLY    = 2,
-+    PHASE_TESLA_OVERLOAD            = 3
-+};
-+ 
-+static const float MAX_CHAIN_RANGE = 60.0;
-+
-+/************
-+** npc_tesla_coil
-+************/
-+struct MANGOS_DLL_DECL npc_tesla_coilAI : public ScriptedAI
-+{
-+    npc_tesla_coilAI(Creature* pCreature) : ScriptedAI(pCreature)
-+    {
-+        m_pInstance = (instance_naxxramas*)pCreature->GetInstanceData();
-+        Reset();
-+    }
-+
-+    instance_naxxramas* m_pInstance;
-+    bool m_bToFeugen;
-+
-+    uint32 m_uiPhaseTimer;
-+    uint8 m_uiPhase;
-+    uint64 m_uiThadAddGUID;
-+    uint64 m_uiNoxTeslaGUID;
-+
-+    void Reset()
-+    {
-+        m_uiPhase = PHASE_TESLA_SETUP_CHAINS;
-+        m_uiPhaseTimer = 1*IN_MILLISECONDS;;
-+        m_uiThadAddGUID = 0;
-+        m_uiNoxTeslaGUID = 0;
-+    }
-+
-+    bool SetupChain()
-+    {
-+        if (!m_pInstance)
-+            return false;
-+        if (m_pInstance->GetData(TYPE_THADDIUS) == DONE)
-+            return true; // Do nothing more, if encounter finished
-+
-+        GameObject* pNoxTeslaFeugen  = m_pInstance->instance->GetGameObject(m_pInstance->GetData64(GO_CONS_NOX_TESLA_FEUGEN));
-+        GameObject* pNoxTeslaStalagg = m_pInstance->instance->GetGameObject(m_pInstance->GetData64(GO_CONS_NOX_TESLA_STALAGG));
-+
-+        if (!pNoxTeslaFeugen || !pNoxTeslaStalagg)
-+            return false;
-+        if (m_creature->GetDistanceOrder(pNoxTeslaFeugen, pNoxTeslaStalagg))
-+        {
-+            m_uiNoxTeslaGUID = pNoxTeslaFeugen->GetGUID();
-+            m_uiThadAddGUID = m_pInstance->GetData64(NPC_FEUGEN);
-+            m_bToFeugen = true;
-+        }
-+        else
-+        {
-+            m_uiNoxTeslaGUID = pNoxTeslaStalagg->GetGUID();
-+            m_uiThadAddGUID = m_pInstance->GetData64(NPC_STALAGG);
-+            m_bToFeugen = false;
-+        }
-+
-+        if (Creature* pTarget = m_pInstance->instance->GetCreature(m_uiThadAddGUID))
-+        {
-+            m_pInstance->DoUseDoorOrButton(m_uiNoxTeslaGUID);
-+            if (DoCastSpellIfCan(pTarget, m_bToFeugen ? SPELL_FEUGEN_CHAIN : SPELL_STALAGG_CHAIN) == CAST_OK)
-+                return true;
-+        }
-+        return false;
-+    }
-+
-+    void ReApplyChain()
-+    {
-+        Creature* pTarget = m_pInstance->instance->GetCreature(m_uiThadAddGUID);
-+        GameObject* pGo = m_pInstance->instance->GetGameObject(m_uiNoxTeslaGUID);
-+
-+        if (pGo && pGo->GetGoType() == GAMEOBJECT_TYPE_BUTTON && pGo->getLootState() == GO_READY)
-+            pGo->UseDoorOrButton(0, false);
-+        if (pTarget)
-+            (DoCastSpellIfCan(pTarget, m_bToFeugen ? SPELL_FEUGEN_CHAIN : SPELL_STALAGG_CHAIN, CAST_INTERRUPT_PREVIOUS));
-+    }
-+
-+    void LinkLost()
-+    {
-+        DoScriptText(EMOTE_LOSING_LINK, m_creature);
-+        m_uiPhaseTimer = 2*IN_MILLISECONDS;
-+        m_uiPhase = PHASE_TESLA_SHOCK_OR_REAPPLY;
-+    }
-+
-+    void SetOverloading()
-+    {
-+        m_uiPhaseTimer = 14*IN_MILLISECONDS;
-+        m_uiPhase = PHASE_TESLA_OVERLOAD;
-+    }
-+
-+    void UpdateAI(const uint32 uiDiff)
-+    {
-+        if (!m_pInstance)
-+            return;
-+        
-+        switch (m_uiPhase)
-+        {
-+            case PHASE_TESLA_SETUP_CHAINS:
-+                if (m_uiPhaseTimer < uiDiff)
-+                    if (SetupChain())
-+                        m_uiPhase = PHASE_TESLA_DO_NOTHING;
-+                    else
-+                        m_uiPhaseTimer = 5*IN_MILLISECONDS;
-+                else
-+                    m_uiPhaseTimer -= uiDiff;
-+                break;
-+            case PHASE_TESLA_SHOCK_OR_REAPPLY:
-+                if (m_uiPhaseTimer < uiDiff)
-+                {
-+                    if (Creature* pTarget = m_pInstance->instance->GetCreature(m_uiThadAddGUID))
-+                        if (m_creature->GetDistance(pTarget)  > MAX_CHAIN_RANGE)
-+                        {
-+                            m_uiPhaseTimer = 1*IN_MILLISECONDS;
-+                            if (pTarget && pTarget->getVictim())
-+                                DoCastSpellIfCan(pTarget->getVictim(), SPELL_SHOCK);
-+                        }
-+                        else
-+                        {
-+                            ReApplyChain();
-+                            m_uiPhase = PHASE_TESLA_DO_NOTHING;
-+                        }
-+                }
-+                else
-+                    m_uiPhaseTimer -= uiDiff;
-+                break;
-+            case PHASE_TESLA_OVERLOAD:
-+                if (m_uiPhaseTimer <  uiDiff)
-+                {
-+                    m_uiPhase = PHASE_TESLA_DO_NOTHING;
-+                    if (Creature* pThaddius = m_pInstance->instance->GetCreature(m_pInstance->GetData64(NPC_THADDIUS)))
-+                    {
-+                        DoCastSpellIfCan(pThaddius,  SPELL_SHOCK_OVERLOAD, CAST_INTERRUPT_PREVIOUS);
-+                        DoScriptText(EMOTE_TESLA_OVERLOAD, m_creature);
-+                    }
-+                    m_pInstance->DoUseDoorOrButton(m_uiNoxTeslaGUID);
-+                }
-+                else
-+                    m_uiPhaseTimer -= uiDiff;
-+                break;
-+        }
-+    }
-+};
-+
-+CreatureAI* GetAI_npc_tesla_coil(Creature* pCreature)
-+{
-+    return new npc_tesla_coilAI(pCreature);
-+}
-+
-+/************
-+** npc_thaddiusAddsAI - Super'class' for Feugen&Stalagg
-+************/
-+
-+struct MANGOS_DLL_DECL npc_thaddiusAddsAI : public ScriptedAI
-+{
-+    npc_thaddiusAddsAI(Creature* pCreature) : ScriptedAI(pCreature)
-+    {
-+        m_pInstance = (instance_naxxramas*)pCreature->GetInstanceData();
-+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
-+
-+        m_uiThaddiusGUID = 0;
-+        m_uiStalaggGUID = 0;
-+        m_uiFeugenGUID = 0;
-+
-+        Reset();
-+    }
-+
-+    instance_naxxramas* m_pInstance;
-+    bool m_bIsRegularMode;
-+
-+    bool m_bFakeDeath;
-+    bool m_bBothDead;
-+
-+    uint32 m_uiHoldTimer;
-+    uint32 m_uiWarStompTimer;
-+    uint32 m_uiReviveTimer;
-+
-+    uint64 m_uiThaddiusGUID;
-+    uint64 m_uiStalaggGUID;
-+    uint64 m_uiFeugenGUID;
-+
-+    void Reset()
-+    {
-+        m_bFakeDeath = false;
-+        m_bBothDead = false;
-+        m_uiReviveTimer = 5*IN_MILLISECONDS;
-+        m_uiHoldTimer = 2*IN_MILLISECONDS;
-+        m_uiWarStompTimer = urand(8*IN_MILLISECONDS, 10*IN_MILLISECONDS);
-+
-+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-+        m_creature->SetHealth(m_creature->GetMaxHealth());
-+        m_creature->SetStandState(UNIT_STAND_STATE_STAND);
-+    }
- 
--    SPELL_BALL_LIGHTNING          = 28299,
-+    Creature* GetOtherAdd()
-+    {
-+        switch (m_creature->GetEntry())
-+        {
-+            case NPC_FEUGEN:  return m_pInstance->instance->GetCreature(m_uiStalaggGUID);
-+            case NPC_STALAGG: return m_pInstance->instance->GetCreature(m_uiFeugenGUID);
-+        }
-+        return NULL;
-+    }
- 
--    SPELL_CHARGE_POSITIVE_DMGBUFF = 29659,
--    SPELL_CHARGE_POSITIVE_NEARDMG = 28059,
-+    void JustRespawned()
-+    {
-+        Reset();
- 
--    SPELL_CHARGE_NEGATIVE_DMGBUFF = 29660,
--    SPELL_CHARGE_NEGATIVE_NEARDMG = 28084,
-+        std::list<uint64> lTeslaGUIDList;
-+        if (!m_pInstance)
-+            return;
- 
--    SPELL_CHAIN_LIGHTNING         = 28167,
--    H_SPELL_CHAIN_LIGHTNING       = 54531,
-+        m_pInstance->GetThadTeslaCreatures(lTeslaGUIDList);
-+        if (lTeslaGUIDList.empty())
-+            return;
-+        
-+        for (std::list<uint64>::const_iterator itr = lTeslaGUIDList.begin(); itr != lTeslaGUIDList.end(); itr++)
-+            if (Creature* pTesla = m_pInstance->instance->GetCreature(*itr))
-+                if (npc_tesla_coilAI* pTeslaAI = dynamic_cast<npc_tesla_coilAI*> (pTesla->AI()))
-+                    pTeslaAI->ReApplyChain();
-+    }
- 
--    SPELL_BESERK                  = 26662,
-+    void JustReachedHome()
-+    {
-+        if (!m_pInstance)
-+            return;
-+        m_pInstance->SetData(TYPE_THADDIUS, FAIL);
-+        if (Creature* pOther = GetOtherAdd())
-+            if (npc_thaddiusAddsAI* pOtherAI = dynamic_cast<npc_thaddiusAddsAI*> (pOther->AI()))
-+                if (pOtherAI->isCountingDead())
-+                {
-+                    pOther->ForcedDespawn();
-+                    pOther->Respawn();
-+                }
-+    }
- 
--    //generic
--    C_TESLA_COIL                  = 16218                   //the coils (emotes "Tesla Coil overloads!")
-+    void KilledUnit(Unit *pVictim)
-+    {
-+        switch (m_creature->GetEntry())
-+        {
-+            case NPC_STALAGG:   DoScriptText(SAY_STAL_SLAY, m_creature); break;
-+            case NPC_FEUGEN:    DoScriptText(SAY_FEUG_SLAY, m_creature); break;
-+        }
-+    }
-+
-+    void Revive()
-+    {
-+        DoResetThreat();
-+        PauseCombatMovement();
-+        Reset();
-+    }
-+
-+    bool isCountingDead()
-+    {
-+        return m_bFakeDeath || m_creature->isDead();
-+    }
-+
-+    void PauseCombatMovement()
-+    {
-+        SetCombatMovement(false);
-+        m_uiHoldTimer = 2*IN_MILLISECONDS;
-+    }
-+
-+    void Aggro(Unit* pWho)
-+    {
-+        if(m_pInstance)
-+            m_pInstance->SetData(TYPE_THADDIUS, IN_PROGRESS);
-+    }
-+
-+    virtual void UpdateAddAI(const uint32 uiDiff){}
-+
-+    void UpdateAI(const uint32 uiDiff)
-+    {
-+        if (m_bBothDead)
-+            return;
-+        
-+        if (m_bFakeDeath)
-+        {
-+            if (m_uiReviveTimer < uiDiff)
-+            {
-+                if (Creature* pOther = GetOtherAdd())
-+                    if (npc_thaddiusAddsAI* pOtherAI = (npc_thaddiusAddsAI*) pOther->AI())
-+                    {
-+                        if (!pOtherAI->isCountingDead())
-+                            Revive();
-+                        else
-+                        {
-+                            m_bBothDead = true;
-+                            pOtherAI->m_bBothDead = true;
-+                            // Set Teslas
-+                            std::list<uint64> lTeslaGUIDList;
-+                            m_pInstance->GetThadTeslaCreatures(lTeslaGUIDList);
-+                            for (std::list<uint64>::const_iterator itr = lTeslaGUIDList.begin(); itr != lTeslaGUIDList.end(); itr++)
-+                                if (Creature* pTesla = m_pInstance->instance->GetCreature(*itr))
-+                                    if (npc_tesla_coilAI* pTeslaAI = dynamic_cast<npc_tesla_coilAI*> (pTesla->AI()))
-+                                        pTeslaAI->SetOverloading();
-+                        }
-+                    }
-+            }
-+            else
-+                m_uiReviveTimer -= uiDiff;
-+            return;
-+        }
-+        
-+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-+            return;
-+
-+        if (m_uiHoldTimer)
-+        {
-+            if (m_uiHoldTimer <= uiDiff)
-+            {
-+                SetCombatMovement(true);
-+                AttackStart(m_creature->getVictim());
-+                m_creature->GetMotionMaster()->Clear();
-+                m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
-+                m_uiHoldTimer = 0;
-+            }
-+            else
-+                m_uiHoldTimer -= uiDiff;
-+        }
-+
-+        if (m_uiWarStompTimer < uiDiff)
-+        {
-+            if (DoCastSpellIfCan(m_creature, SPELL_WARSTOMP) == CAST_OK)
-+            m_uiWarStompTimer = urand(8*IN_MILLISECONDS, 10*IN_MILLISECONDS);
-+        }
-+        else
-+            m_uiWarStompTimer -= uiDiff;
-+
-+        UpdateAddAI(uiDiff);                    // For Add Specific Abilities
-+
-+        DoMeleeAttackIfReady();
-+    }
-+
-+    void DamageTaken(Unit* pKiller, uint32 &damage)
-+    {
-+        if (damage < m_creature->GetHealth())
-+            return;
-+        
-+        if (!m_pInstance)
-+            return;
-+
-+        //Prevent glitch if in fake death
-+        if (m_bFakeDeath)
-+        {
-+            damage = 0;
-+            return;
-+        }
-+
-+        //prevent death
-+        damage = 0;
-+        m_bFakeDeath = true;
-+
-+        m_creature->InterruptNonMeleeSpells(false);
-+        m_creature->SetHealth(0);
-+        m_creature->StopMoving();
-+        m_creature->ClearComboPointHolders();
-+        m_creature->RemoveAllAurasOnDeath();
-+        m_creature->ModifyAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, false);
-+        m_creature->ModifyAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, false);
-+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-+        m_creature->ClearAllReactives();
-+        m_creature->GetMotionMaster()->Clear();
-+        m_creature->GetMotionMaster()->MoveIdle();
-+        m_creature->SetStandState(UNIT_STAND_STATE_DEAD);
-+
-+        JustDied(pKiller);
-+    }
- };
-+
-+/************
-+** boss_thaddius
-+************/
-+
-+struct MANGOS_DLL_DECL boss_thaddiusAI : public Scripted_NoMovementAI
-+{
-+    boss_thaddiusAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
-+    {
-+        m_pInstance = (instance_naxxramas*)pCreature->GetInstanceData();
-+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
-+
-+        m_uiStalaggGUID = 0;
-+        m_uiFeugenGUID = 0;
-+
-+        Reset();
-+    }
-+
-+    instance_naxxramas* m_pInstance;
-+    bool m_bIsRegularMode;
-+
-+    uint32 m_uiResetFlagsTimer;
-+    uint32 m_uiPolarityShiftTimer;
-+    uint32 m_uiChainLightningTimer;
-+    uint32 m_uiBallLightningTimer;
-+    uint32 m_uiBerserkTimer;
-+
-+    uint64 m_uiStalaggGUID;
-+    uint64 m_uiFeugenGUID;
-+
-+    uint32 m_uiPlayerCheckTimer;
-+    uint8 m_uiMaxRaidPlayers;
-+    bool m_bSubstraction;
-+
-+    void Reset()
-+    {
-+        m_uiResetFlagsTimer = 5*IN_MILLISECONDS;
-+        m_uiPolarityShiftTimer = 15*IN_MILLISECONDS;
-+        m_uiChainLightningTimer = 8*IN_MILLISECONDS;
-+        m_uiBallLightningTimer = 1*IN_MILLISECONDS;
-+        m_uiBerserkTimer = 6*MINUTE*IN_MILLISECONDS;
-+
-+        m_bSubstraction = true;
-+        m_uiPlayerCheckTimer = 1000;
-+        m_uiMaxRaidPlayers = m_bIsRegularMode ? 8 : 20;
-+    }
-+
-+    void Aggro(Unit* pWho)
-+    {
-+        switch (urand(0,2))
-+        {
-+            case 0: DoScriptText(SAY_AGGRO1, m_creature); break;
-+            case 1: DoScriptText(SAY_AGGRO2, m_creature); break;
-+            case 2: DoScriptText(SAY_AGGRO3, m_creature); break;
-+        }
-+    }
-+
-+    void StartEvent()
-+    {
-+        if (m_pInstance && m_pInstance->GetData(TYPE_THADDIUS) != IN_PROGRESS)
-+        {
-+            m_pInstance->SetData(TYPE_THADDIUS, IN_PROGRESS);
-+            // Make Attackable
-+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-+
-+            m_creature->SetInCombatWithZone();
-+            m_uiStalaggGUID = m_pInstance->GetData64(NPC_STALAGG);
-+            m_uiFeugenGUID = m_pInstance->GetData64(NPC_FEUGEN);
-+        }
-+    }
-+
-+    void JustReachedHome()
-+    {
-+        if (!m_pInstance)
-+            return;
-+
-+        m_pInstance->SetData(TYPE_THADDIUS, FAIL);
-+        RemoveAllAuras();
-+        // Respawn Adds:
-+        Creature* pFeugen  = m_pInstance->instance->GetCreature(m_uiFeugenGUID);
-+        Creature* pStalagg = m_pInstance->instance->GetCreature(m_uiStalaggGUID);
-+        if (pFeugen)
-+        {
-+            pFeugen->ForcedDespawn();
-+            pFeugen->Respawn();
-+        }
-+        if (pStalagg)
-+        {
-+            pStalagg->ForcedDespawn();
-+            pStalagg->Respawn();
-+        }
-+        Reset();
-+    }
-+
-+    void KilledUnit(Unit *pVictim)
-+    {
-+        DoScriptText(SAY_SLAY, m_creature);
-+    }
-+
-+    void JustDied(Unit* pKiller)
-+    {
-+        DoScriptText(SAY_DEATH, m_creature);
-+        RemoveAllAuras();
-+        
-+        if (m_pInstance)
-+        {
-+            m_pInstance->SetData(TYPE_THADDIUS, DONE);
-+
-+            if(m_bSubstraction)
-+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_SUBSTRACTION : ACHIEV_SUBSTRACTION_H);
-+
-+            // Force Despawn of Adds
-+            Creature* pFeugen  = ((Creature*)Unit::GetUnit(*m_creature, m_pInstance->GetData64(NPC_FEUGEN)));
-+            Creature* pStalagg = ((Creature*)Unit::GetUnit(*m_creature, m_pInstance->GetData64(NPC_STALAGG)));
-+
-+            if (pFeugen)
-+                pFeugen->DealDamage(pFeugen, pFeugen->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
-+            if (pStalagg)
-+                pStalagg->DealDamage(pStalagg, pStalagg->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
-+        }
-+    }
-+
-+    void DoCastPolarityShift()
-+    {
-+        Map *map = m_creature->GetMap();
-+        if (map->IsDungeon())
-+        {
-+            Map::PlayerList const &PlayerList = map->GetPlayers();
-+
-+            if (PlayerList.isEmpty())
-+                return;
-+
-+            for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
-+            {
-+                uint32 SpellId = 0;
-+                switch (urand(0, 1))
-+                {
-+                case 0:
-+                    SpellId = SPELL_POSITIVE_CHARGE;
-+                    break;
-+                case 1:
-+                    SpellId = SPELL_NEGATIVE_CHARGE;
-+                    break;
-+                }
-+                if (i->getSource()->isAlive())
-+                {
-+                    if(SpellId == SPELL_POSITIVE_CHARGE)
-+                    {
-+                        if(i->getSource()->HasAura(SPELL_NEGATIVE_CHARGE, EFFECT_INDEX_0))
-+                            i->getSource()->RemoveAurasDueToSpell(SPELL_NEGATIVE_CHARGE);
-+                        i->getSource()->CastSpell(i->getSource(), SpellId, false);
-+                    }
-+                    else if(SpellId == SPELL_NEGATIVE_CHARGE)
-+                    {
-+                        if(i->getSource()->HasAura(SPELL_POSITIVE_CHARGE, EFFECT_INDEX_0))
-+                            i->getSource()->RemoveAurasDueToSpell(SPELL_POSITIVE_CHARGE);
-+                        i->getSource()->CastSpell(i->getSource(), SpellId, false);
-+                    }
-+                }
-+            }
-+        } 
-+    }
-+
-+    void RemoveAllAuras()
-+    {
-+        Map *map = m_creature->GetMap();
-+        if (map->IsDungeon())
-+        {
-+            Map::PlayerList const &PlayerList = map->GetPlayers();
-+
-+            if (PlayerList.isEmpty())
-+                return;
-+
-+            for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
-+            {
-+                if (i->getSource()->isAlive())
-+                {
-+                    if(i->getSource()->HasAura(SPELL_POSITIVE_CHARGE, EFFECT_INDEX_0))
-+                        i->getSource()->RemoveAurasDueToSpell(SPELL_POSITIVE_CHARGE);
-+                    if(i->getSource()->HasAura(SPELL_NEGATIVE_CHARGE, EFFECT_INDEX_0))
-+                        i->getSource()->RemoveAurasDueToSpell(SPELL_NEGATIVE_CHARGE);
-+                }
-+            }
-+        } 
-+    }
-+
-+    void UpdateAI(const uint32 uiDiff)
-+    {
-+        if (!m_pInstance)
-+            return;
-+
-+        if (m_uiResetFlagsTimer)
-+        {
-+            if (m_uiResetFlagsTimer < uiDiff)
-+            {
-+                DoCastSpellIfCan(m_creature, SPELL_THADIUS_STUN);
-+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
-+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
-+                m_uiResetFlagsTimer = 0;
-+            }
-+            else
-+                m_uiResetFlagsTimer = (m_uiResetFlagsTimer == uiDiff) ? 1 : m_uiResetFlagsTimer - uiDiff;
-+        }
-+
-+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
-+            return;
-+
-+        if(m_pInstance)
-+            if(m_pInstance->GetData(TYPE_FEUGEN) != DONE && m_pInstance->GetData(TYPE_STALAGG) != DONE)
-+                return;
-+
-+        // Players check
-+        if (m_uiPlayerCheckTimer < uiDiff && m_bSubstraction)
-+        {
-+            Map *map = m_creature->GetMap();
-+            if (map->IsDungeon())
-+            {
-+                Map::PlayerList const &PlayerList = map->GetPlayers();
-+
-+                if (PlayerList.isEmpty())
-+                    return;
-+
-+                if(PlayerList.getSize() > m_uiMaxRaidPlayers)
-+                    m_bSubstraction = false;
-+            } 
-+            m_uiPlayerCheckTimer = 1000;
-+        }
-+        else
-+            m_uiPlayerCheckTimer -= uiDiff;
-+
-+        // Berserk
-+        if (m_uiBerserkTimer < uiDiff)
-+        {
-+            if (DoCastSpellIfCan(m_creature, SPELL_BESERK) == CAST_OK)                  // allow combat movement?
-+                m_uiBerserkTimer = 10*MINUTE*IN_MILLISECONDS;
-+        }
-+        else
-+            m_uiBerserkTimer -= uiDiff;
-+
-+        // Ball Lightning if target not in melee range
-+        if (!m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
-+        {
-+            if (m_uiBallLightningTimer < uiDiff)
-+            {
-+                if (DoCastSpellIfCan(m_creature->getVictim(), SPELL_BALL_LIGHTNING) == CAST_OK)
-+                    m_uiBallLightningTimer = 1*IN_MILLISECONDS;
-+            }
-+            else
-+                m_uiBallLightningTimer -= uiDiff;
-+        }
-+
-+        // Polarity Shift
-+        if (m_uiPolarityShiftTimer < uiDiff)
-+        {
-+            if (DoCastSpellIfCan(m_creature, SPELL_POLARITY_SHIFT, CAST_INTERRUPT_PREVIOUS) == CAST_OK)
-+            {
-+                DoCastPolarityShift();
-+                DoScriptText(SAY_ELECT, m_creature);
-+                DoScriptText(EMOTE_POLARITY_SHIFT, m_creature);
-+                m_uiPolarityShiftTimer = 30*IN_MILLISECONDS;
-+            }
-+        }
-+        else
-+            m_uiPolarityShiftTimer -= uiDiff;
-+
-+        // ChainLightning
-+        if (m_uiChainLightningTimer < uiDiff)
-+        {
-+            Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0);
-+            if (pTarget && DoCastSpellIfCan(pTarget, m_bIsRegularMode ? SPELL_CHAIN_LIGHTNING : SPELL_CHAIN_LIGHTNING_H) == CAST_OK)
-+                m_uiChainLightningTimer = 15*IN_MILLISECONDS;
-+        }
-+        else
-+            m_uiChainLightningTimer -= uiDiff;
-+
-+        DoMeleeAttackIfReady();
-+    }
-+};
-+
-+CreatureAI* GetAI_boss_thaddius(Creature* pCreature)
-+{
-+    return new boss_thaddiusAI(pCreature);
-+}
-+
-+bool EffectDummyCreature_spell_thaddius_encounter(Unit* pCaster, uint32 uiSpellId, SpellEffectIndex uiEffIndex, Creature* pCreatureTarget)
-+{
-+    if (uiEffIndex != EFFECT_INDEX_0)
-+        return true;
-+
-+    switch (uiSpellId)
-+    {
-+        case SPELL_BREAK_CHANNEL:
-+            if (pCreatureTarget->GetEntry() != NPC_TESLA_COIL)
-+                return false;
-+            if (npc_tesla_coilAI* pTeslaAI = dynamic_cast<npc_tesla_coilAI*>(pCreatureTarget->AI()))
-+                pTeslaAI->LinkLost();
-+            break;
-+        case SPELL_SHOCK_OVERLOAD:
-+            if (pCreatureTarget->GetEntry() != NPC_THADDIUS)
-+                return false;
-+            // remove Stun and then Cast
-+            pCreatureTarget->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);    // needed? (in UDB set).
-+            pCreatureTarget->RemoveAurasDueToSpell(SPELL_THADIUS_STUN);
-+            pCreatureTarget->CastSpell(pCreatureTarget, SPELL_THADIUS_LIGHTNING_VISUAL, false);
-+            break;
-+        case SPELL_THADIUS_LIGHTNING_VISUAL:
-+            if (pCreatureTarget->GetEntry() != NPC_THADDIUS)
-+                return false;
-+            if (boss_thaddiusAI* pThaddiusAI = dynamic_cast<boss_thaddiusAI*> (pCreatureTarget->AI()))
-+                pThaddiusAI->StartEvent();
-+            break;
-+    }
-+    return true;
-+}
-+
-+/************
-+** npc_stalagg
-+************/
-+
-+struct MANGOS_DLL_DECL npc_stalaggAI : public npc_thaddiusAddsAI
-+{
-+    npc_stalaggAI(Creature* pCreature) : npc_thaddiusAddsAI(pCreature)
-+    {
-+        Reset();
-+    }
-+    uint32 m_uiPowerSurgeTimer;
-+
-+    void Reset()
-+    {
-+        npc_thaddiusAddsAI::Reset();
-+        m_uiPowerSurgeTimer = urand(10*IN_MILLISECONDS, 15*IN_MILLISECONDS);
-+
-+        if(m_pInstance)
-+            m_pInstance->SetData(TYPE_STALAGG, NOT_STARTED);
-+    }
-+
-+    void Aggro(Unit* pWho)
-+    {
-+        DoScriptText(SAY_STAL_AGGRO, m_creature);
-+
-+        if (!m_pInstance)
-+            return;
-+
-+        m_uiFeugenGUID   = m_pInstance->GetData64(NPC_FEUGEN);
-+        m_uiStalaggGUID  = m_creature->GetGUID();
-+
-+        if (Creature* pFeugen = GetOtherAdd())
-+            if (!pFeugen->isInCombat())
-+                pFeugen->SetInCombatWithZone();
-+
-+        m_creature->SetInCombatWithZone();
-+    }
-+
-+    void JustDied(Unit* pKiller)
-+    {
-+        DoScriptText(SAY_STAL_DEATH, m_creature);
-+
-+        if(m_pInstance)
-+            m_pInstance->SetData(TYPE_STALAGG, DONE);
-+    }
-+
-+    void UpdateAddAI(const uint32 uiDiff)
-+    {
-+        if (m_uiPowerSurgeTimer < uiDiff)
-+        {
-+            if (DoCastSpellIfCan(m_creature, m_bIsRegularMode ? SPELL_POWERSURGE : SPELL_POWERSURGE_H) == CAST_OK)
-+                m_uiPowerSurgeTimer = urand(10*IN_MILLISECONDS, 15*IN_MILLISECONDS);
-+        }
-+        else
-+            m_uiPowerSurgeTimer -= uiDiff;
-+    }
-+
-+    void DamageTaken(Unit* pKiller, uint32 &damage)
-+    {
-+        npc_thaddiusAddsAI::DamageTaken(pKiller, damage);
-+    }
-+};
-+
-+CreatureAI* GetAI_npc_stalagg(Creature* pCreature)
-+{
-+    return new npc_stalaggAI(pCreature);
-+}
-+
-+/************
-+** npc_feugen
-+************/
-+
-+struct MANGOS_DLL_DECL npc_feugenAI : public npc_thaddiusAddsAI
-+{
-+    npc_feugenAI(Creature* pCreature) : npc_thaddiusAddsAI(pCreature)
-+    {
-+        Reset();
-+    }
-+    uint32 m_uiStaticFieldTimer;
-+    uint32 m_uiMagneticPullTimer;                                       // TODO, missing
-+
-+    void Reset()
-+    {
-+        npc_thaddiusAddsAI::Reset();
-+        m_uiStaticFieldTimer = urand(10*IN_MILLISECONDS, 15*IN_MILLISECONDS);
-+        m_uiMagneticPullTimer = 20*IN_MILLISECONDS;
-+
-+        if(m_pInstance)
-+            m_pInstance->SetData(TYPE_FEUGEN, NOT_STARTED);
-+    }
-+
-+    void Aggro(Unit* pWho)
-+    {
-+        DoScriptText(SAY_FEUG_AGGRO, m_creature);
-+
-+        if (!m_pInstance)
-+            return;
-+
-+        m_uiStalaggGUID = m_pInstance->GetData64(NPC_STALAGG);
-+        m_uiFeugenGUID  = m_creature->GetGUID();
-+
-+        if (Creature* pStalagg = GetOtherAdd())
-+            if (pStalagg && !pStalagg->isInCombat())
-+                pStalagg->SetInCombatWithZone();
-+
-+        m_creature->SetInCombatWithZone();
-+    }
-+
-+    void JustDied(Unit* pKiller)
-+    {
-+        DoScriptText(SAY_FEUG_DEATH, m_creature);
-+        if(m_pInstance)
-+            m_pInstance->SetData(TYPE_FEUGEN, DONE);
-+    }
-+
-+    void UpdateAddAI(const uint32 uiDiff)
-+    {
-+        if (m_uiStaticFieldTimer < uiDiff)
-+        {
-+            if (DoCastSpellIfCan(m_creature, m_bIsRegularMode ? SPELL_STATIC_FIELD : SPELL_STATIC_FIELD_H) == CAST_OK)
-+                m_uiStaticFieldTimer = urand(10*IN_MILLISECONDS, 15*IN_MILLISECONDS);
-+        }
-+        else
-+            m_uiStaticFieldTimer -= uiDiff;
-+    }
-+
-+    void DamageTaken(Unit* pKiller, uint32 &damage)
-+    {
-+        npc_thaddiusAddsAI::DamageTaken(pKiller, damage);
-+    }
-+};
-+
-+CreatureAI* GetAI_npc_feugen(Creature* pCreature)
-+{
-+    return new npc_feugenAI(pCreature);
-+}
-+
-+void AddSC_boss_thaddius()
-+{
-+    Script* NewScript;
-+    NewScript = new Script;
-+    NewScript->Name = "boss_thaddius";
-+    NewScript->GetAI = &GetAI_boss_thaddius;
-+    NewScript->pEffectDummyCreature = &EffectDummyCreature_spell_thaddius_encounter;
-+    NewScript->RegisterSelf();
-+
-+    NewScript = new Script;
-+    NewScript->Name = "npc_stalagg";
-+    NewScript->GetAI = &GetAI_npc_stalagg;
-+    NewScript->RegisterSelf();
-+
-+    NewScript = new Script;
-+    NewScript->Name = "npc_feugen";
-+    NewScript->GetAI = &GetAI_npc_feugen;
-+    NewScript->RegisterSelf();
-+
-+    NewScript = new Script;
-+    NewScript->Name = "npc_tesla_coil";
-+    NewScript->GetAI = &GetAI_npc_tesla_coil;
-+    NewScript->pEffectDummyCreature = &EffectDummyCreature_spell_thaddius_encounter;
-+    NewScript->RegisterSelf();
-+}
-\ No newline at end of file
-diff --git a/scripts/northrend/naxxramas/instance_naxxramas.cpp b/scripts/northrend/naxxramas/instance_naxxramas.cpp
-index e628c7c..92efd0a 100644
---- a/scripts/northrend/naxxramas/instance_naxxramas.cpp
-+++ b/scripts/northrend/naxxramas/instance_naxxramas.cpp
-@@ -1,18 +1,18 @@
- /* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
-- * This program is free software; you can redistribute it and/or modify
-- * it under the terms of the GNU General Public License as published by
-- * the Free Software Foundation; either version 2 of the License, or
-- * (at your option) any later version.
-- *
-- * This program is distributed in the hope that it will be useful,
-- * but WITHOUT ANY WARRANTY; without even the implied warranty of
-- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- * GNU General Public License for more details.
-- *
-- * You should have received a copy of the GNU General Public License
-- * along with this program; if not, write to the Free Software
-- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-- */
-+* This program is free software; you can redistribute it and/or modify
-+* it under the terms of the GNU General Public License as published by
-+* the Free Software Foundation; either version 2 of the License, or
-+* (at your option) any later version.
-+*
-+* This program is distributed in the hope that it will be useful,
-+* but WITHOUT ANY WARRANTY; without even the implied warranty of
-+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-+* GNU General Public License for more details.
-+*
-+* You should have received a copy of the GNU General Public License
-+* along with this program; if not, write to the Free Software
-+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-+*/
- 
- /* ScriptData
- SDName: Instance_Naxxramas
-@@ -24,12 +24,63 @@ EndScriptData */
- #include "precompiled.h"
- #include "naxxramas.h"
- 
-+const float PosAracTele[4] = {3020.08f, -3448.65f, 300.97f, 3.14f};
-+const float PosConsTele[4] = {3019.93f, -3420.31f, 300.97f, 3.14f};
-+const float PosPlagTele[4] = {2991.58f, -3448.51f, 300.97f, 3.14f};
-+const float PosMiliTele[4] = {2991.71f, -3420.18f, 300.97f, 3.14f};
-+
-+bool GOHello_go_naxxTeleporter(Player* pPlayer, GameObject* pGo)
-+{
-+    ScriptedInstance* pInstance = (ScriptedInstance*)pGo->GetInstanceData();
-+
-+    if (!pInstance)
-+        return false;
-+
-+    switch(pGo->GetEntry())
-+    {
-+    case GO_ARAC_PORTAL:
-+        if(pInstance->GetData(TYPE_MAEXXNA) == DONE)
-+        {
-+            if(pGo->GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) < 2)
-+                pPlayer->TeleportTo(pPlayer->GetMapId(), PosAracTele[0], PosAracTele[1], PosAracTele[2], PosAracTele[3]);
-+        }
-+        break;
-+    case GO_CONS_PORTAL:
-+        if(pInstance->GetData(TYPE_THADDIUS) == DONE)
-+        {
-+            if(pGo->GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) < 2)
-+                pPlayer->TeleportTo(pPlayer->GetMapId(), PosConsTele[0], PosConsTele[1], PosConsTele[2], PosConsTele[3]);
-+        }
-+        break;
-+    case GO_MILI_PORTAL:
-+        if(pInstance->GetData(TYPE_FOUR_HORSEMEN) == DONE)
-+        {
-+            if(pGo->GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) < 2)
-+                pPlayer->TeleportTo(pPlayer->GetMapId(), PosMiliTele[0], PosMiliTele[1], PosMiliTele[2], PosMiliTele[3]);
-+        }
-+        break;
-+    case GO_PLAG_PORTAL:
-+        if(pInstance->GetData(TYPE_LOATHEB) == DONE)
-+        {
-+            if(pGo->GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) < 2)
-+                pPlayer->TeleportTo(pPlayer->GetMapId(), PosPlagTele[0], PosPlagTele[1], PosPlagTele[2], PosPlagTele[3]);
-+        }
-+        break;
-+    }
-+    return false;
-+}
-+
- instance_naxxramas::instance_naxxramas(Map* pMap) : ScriptedInstance(pMap),
-     m_uiAracEyeRampGUID(0),
-     m_uiPlagEyeRampGUID(0),
-     m_uiMiliEyeRampGUID(0),
-     m_uiConsEyeRampGUID(0),
- 
-+    m_uiAracEyeGUID(0),
-+    m_uiPlagEyeGUID(0),
-+    m_uiMiliEyeGUID(0),
-+    m_uiConsEyeGUID(0),
-+
-     m_uiAracPortalGUID(0),
-     m_uiPlagPortalGUID(0),
-     m_uiMiliPortalGUID(0),
-@@ -50,6 +101,8 @@ instance_naxxramas::instance_naxxramas(Map* pMap) : ScriptedInstance(pMap),
-     m_uiPathExitDoorGUID(0),
-     m_uiGlutExitDoorGUID(0),
-     m_uiThadDoorGUID(0),
-+    m_uiThadNoxTeslaFeugenGUID(0),
-+    m_uiThadNoxTeslaStalaggGUID(0),
- 
-     m_uiAnubDoorGUID(0),
-     m_uiAnubGateGUID(0),
-@@ -71,10 +124,28 @@ instance_naxxramas::instance_naxxramas(Map* pMap) : ScriptedInstance(pMap),
-     m_uiHeigExitDoorGUID(0),
-     m_uiLoathebDoorGUID(0),
- 
-+    m_uiKelthuzadWaterfallDoorGUID(0),
-     m_uiKelthuzadDoorGUID(0),
-     m_fChamberCenterX(0.0f),
-     m_fChamberCenterY(0.0f),
--    m_fChamberCenterZ(0.0f)
-+    m_fChamberCenterZ(0.0f),
-+
-+    BlaumeuxDead(false),
-+    RivendareDead(false),
-+    ZeliekDead(false), 
-+    KorthazzDead(false),
-+
-+    m_auiStalaggEncounter(0),
-+    m_auiFeugenEncouter(0),
-+
-+    DeadTimer(0),            
-+    UpdateCheck(false),
-+
-+    m_uiArachnofobiaTimer(0),
-+    m_bIsArachnofobia (false),
-+
-+    m_uiImmortaCheck(1000)
-+
- {
-     Initialize();
- }
-@@ -88,17 +159,18 @@ void instance_naxxramas::OnCreatureCreate(Creature* pCreature)
- {
-     switch(pCreature->GetEntry())
-     {
--        case NPC_ANUB_REKHAN:       m_uiAnubRekhanGUID = pCreature->GetGUID();  break;
--        case NPC_FAERLINA:          m_uiFaerlinanGUID = pCreature->GetGUID();   break;
--        case NPC_THADDIUS:          m_uiThaddiusGUID = pCreature->GetGUID();    break;
--        case NPC_STALAGG:           m_uiStalaggGUID = pCreature->GetGUID();     break;
--        case NPC_FEUGEN:            m_uiFeugenGUID = pCreature->GetGUID();      break;
--        case NPC_ZELIEK:            m_uiZeliekGUID = pCreature->GetGUID();      break;
--        case NPC_THANE:             m_uiThaneGUID = pCreature->GetGUID();       break;
--        case NPC_BLAUMEUX:          m_uiBlaumeuxGUID = pCreature->GetGUID();    break;
--        case NPC_RIVENDARE:         m_uiRivendareGUID = pCreature->GetGUID();   break;
--        case NPC_GOTHIK:            m_uiGothikGUID = pCreature->GetGUID();      break;
--        case NPC_SUB_BOSS_TRIGGER:  m_lGothTriggerList.push_back(pCreature->GetGUID()); break;
-+    case NPC_ANUB_REKHAN:       m_uiAnubRekhanGUID = pCreature->GetGUID();  break;
-+    case NPC_FAERLINA:          m_uiFaerlinanGUID = pCreature->GetGUID();   break;
-+    case NPC_THADDIUS:          m_uiThaddiusGUID = pCreature->GetGUID();    break;
-+    case NPC_STALAGG:           m_uiStalaggGUID = pCreature->GetGUID();     break;
-+    case NPC_FEUGEN:            m_uiFeugenGUID = pCreature->GetGUID();      break;
-+    case NPC_ZELIEK:            m_uiZeliekGUID = pCreature->GetGUID();      break;
-+    case NPC_THANE:             m_uiThaneGUID = pCreature->GetGUID();       break;
-+    case NPC_BLAUMEUX:          m_uiBlaumeuxGUID = pCreature->GetGUID();    break;
-+    case NPC_RIVENDARE:         m_uiRivendareGUID = pCreature->GetGUID();   break;
-+    case NPC_GOTHIK:            m_uiGothikGUID = pCreature->GetGUID();      break;
-+    case NPC_SUB_BOSS_TRIGGER:  m_lGothTriggerList.push_back(pCreature->GetGUID()); break;
-+    case NPC_TESLA_COIL:        m_lThadTeslaCoilList.push_back(pCreature->GetGUID()); break;
-     }
- }
- 
-@@ -106,131 +178,187 @@ void instance_naxxramas::OnObjectCreate(GameObject* pGo)
- {
-     switch(pGo->GetEntry())
-     {
--        case GO_ARAC_ANUB_DOOR:
--            m_uiAnubDoorGUID = pGo->GetGUID();
--            break;
--        case GO_ARAC_ANUB_GATE:
--            m_uiAnubGateGUID = pGo->GetGUID();
--            if (m_auiEncounter[0] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--        case GO_ARAC_FAER_WEB:
--            m_uiFaerWebGUID = pGo->GetGUID();
--            break;
--        case GO_ARAC_FAER_DOOR:
--            m_uiFaerDoorGUID = pGo->GetGUID();
--            if (m_auiEncounter[1] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--        case GO_ARAC_MAEX_INNER_DOOR:
--            m_uiMaexInnerGUID = pGo->GetGUID();
--            break;
--        case GO_ARAC_MAEX_OUTER_DOOR:
--            m_uiMaexOuterGUID = pGo->GetGUID();
--            if (m_auiEncounter[1] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--
--        case GO_PLAG_NOTH_ENTRY_DOOR:
--            m_uiNothEntryDoorGUID = pGo->GetGUID();
--            break;
--        case GO_PLAG_NOTH_EXIT_DOOR:
--            m_uiNothExitDoorGUID = pGo->GetGUID();
--            if (m_auiEncounter[3] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--        case GO_PLAG_HEIG_ENTRY_DOOR:
--            m_uiHeigEntryDoorGUID = pGo->GetGUID();
--            if (m_auiEncounter[3] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--        case GO_PLAG_HEIG_EXIT_DOOR:
--            m_uiHeigExitDoorGUID = pGo->GetGUID();
--            if (m_auiEncounter[4] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--        case GO_PLAG_LOAT_DOOR:
--            m_uiLoathebDoorGUID = pGo->GetGUID();
--            break;
--
--        case GO_MILI_GOTH_ENTRY_GATE:
--            m_uiGothikEntryDoorGUID = pGo->GetGUID();
--            break;
--        case GO_MILI_GOTH_EXIT_GATE:
--            m_uiGothikExitDoorGUID = pGo->GetGUID();
--            if (m_auiEncounter[7] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--        case GO_MILI_GOTH_COMBAT_GATE:
--            m_uiGothCombatGateGUID = pGo->GetGUID();
--            break;
--        case GO_MILI_HORSEMEN_DOOR:
--            m_uiHorsemenDoorGUID  = pGo->GetGUID();
--            if (m_auiEncounter[7] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--
--        case GO_CHEST_HORSEMEN_NORM:
--        case GO_CHEST_HORSEMEN_HERO:
-+    case GO_ARAC_ANUB_DOOR:
-+        m_uiAnubDoorGUID = pGo->GetGUID();
-+        break;
-+    case GO_ARAC_ANUB_GATE:
-+        m_uiAnubGateGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_READY);
-+        if (m_auiEncounter[0] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_ARAC_FAER_WEB:
-+        m_uiFaerWebGUID = pGo->GetGUID();
-+        break;
-+    case GO_ARAC_FAER_DOOR:
-+        m_uiFaerDoorGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_READY);
-+        if (m_auiEncounter[1] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_ARAC_MAEX_INNER_DOOR:
-+        m_uiMaexInnerGUID = pGo->GetGUID();
-+        break;
-+    case GO_ARAC_MAEX_OUTER_DOOR:
-+        m_uiMaexOuterGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_READY);
-+        if (m_auiEncounter[1] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+
-+    case GO_PLAG_NOTH_ENTRY_DOOR:
-+        m_uiNothEntryDoorGUID = pGo->GetGUID();
-+        break;
-+    case GO_PLAG_NOTH_EXIT_DOOR:
-+        m_uiNothExitDoorGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_READY);
-+        if (m_auiEncounter[3] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_PLAG_HEIG_ENTRY_DOOR:
-+        m_uiHeigEntryDoorGUID = pGo->GetGUID();
-+        //pGo->SetGoState(GO_STATE_READY);
-+        if (m_auiEncounter[3] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_PLAG_HEIG_EXIT_DOOR:
-+        m_uiHeigExitDoorGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_READY);
-+        if (m_auiEncounter[4] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_PLAG_LOAT_DOOR:
-+        m_uiLoathebDoorGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_READY);
-+        break;
-+
-+    case GO_MILI_GOTH_ENTRY_GATE:
-+        pGo->SetGoState(GO_STATE_READY);
-+        m_uiGothikEntryDoorGUID = pGo->GetGUID();
-+        break;
-+    case GO_MILI_GOTH_EXIT_GATE:
-+        m_uiGothikExitDoorGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_READY);
-+        if (m_auiEncounter[7] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_MILI_GOTH_COMBAT_GATE:
-+        m_uiGothCombatGateGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_MILI_HORSEMEN_DOOR:
-+        m_uiHorsemenDoorGUID  = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_READY);
-+        if (m_auiEncounter[7] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+
-+    case GO_CHEST_HORSEMEN_NORM:
-+        if(instance->IsRegularDifficulty())
-+            m_uiHorsemenChestGUID = pGo->GetGUID();
-+        break;
-+    case GO_CHEST_HORSEMEN_HERO:
-+        if(!instance->IsRegularDifficulty())
-             m_uiHorsemenChestGUID = pGo->GetGUID();
--            break;
--
--        case GO_CONS_PATH_EXIT_DOOR:
--            m_uiPathExitDoorGUID = pGo->GetGUID();
--            if (m_auiEncounter[9] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--        case GO_CONS_GLUT_EXIT_DOOR:
--            m_uiGlutExitDoorGUID = pGo->GetGUID();
--            if (m_auiEncounter[11] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--        case GO_CONS_THAD_DOOR:
--            m_uiThadDoorGUID = pGo->GetGUID();
--            if (m_auiEncounter[11] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
- 
--        case GO_KELTHUZAD_WATERFALL_DOOR:
--            m_uiKelthuzadDoorGUID = pGo->GetGUID();
--            if (m_auiEncounter[13] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
-+    case GO_CONS_PATH_EXIT_DOOR:
-+        m_uiPathExitDoorGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_READY);
-+        if (m_auiEncounter[9] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_CONS_GLUT_EXIT_DOOR:
-+        m_uiGlutExitDoorGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_READY);
-+        if (m_auiEncounter[11] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_CONS_THAD_DOOR:
-+        m_uiThadDoorGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_READY);
-+        if (m_auiEncounter[11] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_CONS_NOX_TESLA_FEUGEN:
-+        m_uiThadNoxTeslaFeugenGUID = pGo->GetGUID();
-+        break;
-+    case GO_CONS_NOX_TESLA_STALAGG:
-+        m_uiThadNoxTeslaStalaggGUID = pGo->GetGUID();
-+        break;
-+
-+    case GO_KELTHUZAD_WATERFALL_DOOR:
-+        m_uiKelthuzadWaterfallDoorGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_READY);
-+        if (m_auiEncounter[13] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_KELTHUZAD_COMBAT_GATE: 
-+        pGo->SetGoState(GO_STATE_READY);
-+        m_uiKelthuzadDoorGUID = pGo->GetGUID();
-+        pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+
-+    case GO_ARAC_EYE_RAMP:
-+        m_uiAracEyeRampGUID = pGo->GetGUID();
-+        if (m_auiEncounter[2] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_PLAG_EYE_RAMP:
-+        m_uiPlagEyeRampGUID = pGo->GetGUID();
-+        if (m_auiEncounter[5] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_MILI_EYE_RAMP:
-+        m_uiMiliEyeRampGUID = pGo->GetGUID();
-+        if (m_auiEncounter[8] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+    case GO_CONS_EYE_RAMP:
-+        m_uiConsEyeRampGUID = pGo->GetGUID();
-+        if (m_auiEncounter[12] == DONE)
-+            pGo->SetGoState(GO_STATE_ACTIVE);
-+        break;
-+
-+    case GO_ARAC_PORTAL:
-+        m_uiAracPortalGUID = pGo->GetGUID();
-+        break;
-+    case GO_PLAG_PORTAL:
-+        m_uiPlagPortalGUID = pGo->GetGUID();
-+        break;
-+    case GO_MILI_PORTAL:
-+        m_uiMiliPortalGUID = pGo->GetGUID();
-+        break;
-+    case GO_CONS_PORTAL:
-+        m_uiConsPortalGUID = pGo->GetGUID();
-+        break;
-+
-+    case GO_ARAC_EYE: 
-+        m_uiAracEyeGUID = pGo->GetGUID(); 
-+        break;
-+    case GO_PLAG_EYE: 
-+        m_uiPlagEyeGUID = pGo->GetGUID(); 
-+        break;
-+    case GO_MILI_EYE: 
-+        m_uiMiliEyeGUID = pGo->GetGUID(); 
-+        break;
-+    case GO_CONS_EYE: 
-+        m_uiConsEyeGUID = pGo->GetGUID(); 
-+        break;
-+    }
-+}
- 
--        case GO_ARAC_EYE_RAMP:
--            m_uiAracEyeRampGUID = pGo->GetGUID();
--            if (m_auiEncounter[2] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--        case GO_PLAG_EYE_RAMP:
--            m_uiPlagEyeRampGUID = pGo->GetGUID();
--            if (m_auiEncounter[5] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--        case GO_MILI_EYE_RAMP:
--            m_uiMiliEyeRampGUID = pGo->GetGUID();
--            if (m_auiEncounter[8] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
--        case GO_CONS_EYE_RAMP:
--            m_uiConsEyeRampGUID = pGo->GetGUID();
--            if (m_auiEncounter[12] == DONE)
--                pGo->SetGoState(GO_STATE_ACTIVE);
--            break;
-+void instance_naxxramas::OpenDoor(uint64 guid)
-+{
-+    if(!guid) return;
-+    GameObject* pGo = instance->GetGameObject(guid);
-+    if(pGo) pGo->SetGoState(GO_STATE_ACTIVE);
-+}
- 
--        case GO_ARAC_PORTAL:
--            m_uiAracPortalGUID = pGo->GetGUID();
--            break;
--        case GO_PLAG_PORTAL:
--            m_uiPlagPortalGUID = pGo->GetGUID();
--            break;
--        case GO_MILI_PORTAL:
--            m_uiMiliPortalGUID = pGo->GetGUID();
--            break;
--        case GO_CONS_PORTAL:
--            m_uiConsPortalGUID = pGo->GetGUID();
--            break;
--    }
-+void instance_naxxramas::CloseDoor(uint64 guid)
-+{
-+    if(!guid) return;
-+    GameObject* pGo = instance->GetGameObject(guid);
-+    if(pGo) pGo->SetGoState(GO_STATE_READY);
- }
- 
- bool instance_naxxramas::IsEncounterInProgress()
-@@ -246,157 +374,238 @@ void instance_naxxramas::SetData(uint32 uiType, uint32 uiData)
- {
-     switch(uiType)
-     {
--        case TYPE_ANUB_REKHAN:
--            m_auiEncounter[0] = uiData;
--            DoUseDoorOrButton(m_uiAnubDoorGUID);
--            if (uiData == DONE)
--                DoUseDoorOrButton(m_uiAnubGateGUID);
--            break;
--        case TYPE_FAERLINA:
--            m_auiEncounter[1] = uiData;
--            DoUseDoorOrButton(m_uiFaerWebGUID);
--            if (uiData == DONE)
--            {
--                DoUseDoorOrButton(m_uiFaerDoorGUID);
--                DoUseDoorOrButton(m_uiMaexOuterGUID);
--            }
--            break;
--        case TYPE_MAEXXNA:
--            m_auiEncounter[2] = uiData;
--            DoUseDoorOrButton(m_uiMaexInnerGUID, uiData);
--            if (uiData == DONE)
--            {
--                DoUseDoorOrButton(m_uiAracEyeRampGUID);
--                DoRespawnGameObject(m_uiAracPortalGUID, 30*MINUTE);
--            }
--            break;
--        case TYPE_NOTH:
--            m_auiEncounter[3] = uiData;
--            DoUseDoorOrButton(m_uiNothEntryDoorGUID);
--            if (uiData == DONE)
--            {
--                DoUseDoorOrButton(m_uiNothExitDoorGUID);
--                DoUseDoorOrButton(m_uiHeigEntryDoorGUID);
--            }
--            break;
--        case TYPE_HEIGAN:
--            m_auiEncounter[4] = uiData;
--            DoUseDoorOrButton(m_uiHeigEntryDoorGUID);
--            if (uiData == DONE)
--                DoUseDoorOrButton(m_uiHeigExitDoorGUID);
--            break;
--        case TYPE_LOATHEB:
--            m_auiEncounter[5] = uiData;
--            DoUseDoorOrButton(m_uiLoathebDoorGUID);
--            if (uiData == DONE)
--            {
--                DoUseDoorOrButton(m_uiPlagEyeRampGUID);
--                DoRespawnGameObject(m_uiPlagPortalGUID, 30*MINUTE);
--            }
--            break;
--        case TYPE_RAZUVIOUS:
--            m_auiEncounter[6] = uiData;
--            if (uiData == DONE)
--                DoUseDoorOrButton(m_uiGothikEntryDoorGUID);
--            break;
--        case TYPE_GOTHIK:
--            switch(uiData)
--            {
--                case IN_PROGRESS:
--                    DoUseDoorOrButton(m_uiGothikEntryDoorGUID);
--                    DoUseDoorOrButton(m_uiGothCombatGateGUID);
--                    break;
--                case SPECIAL:
--                    DoUseDoorOrButton(m_uiGothCombatGateGUID);
--                    break;
--                case FAIL:
--                    if (m_auiEncounter[7] == IN_PROGRESS)
--                        DoUseDoorOrButton(m_uiGothCombatGateGUID);
--
--                    DoUseDoorOrButton(m_uiGothikEntryDoorGUID);
--                    break;
--                case DONE:
--                    DoUseDoorOrButton(m_uiGothikEntryDoorGUID);
--                    DoUseDoorOrButton(m_uiGothikExitDoorGUID);
--                    DoUseDoorOrButton(m_uiHorsemenDoorGUID);
--                    break;
--            }
--            m_auiEncounter[7] = uiData;
--            break;
--        case TYPE_FOUR_HORSEMEN:
--            m_auiEncounter[8] = uiData;
--            DoUseDoorOrButton(m_uiHorsemenDoorGUID);
--            if (uiData == DONE)
-+    case TYPE_ANUB_REKHAN:
-+        m_auiEncounter[0] = uiData;
-+        DoUseDoorOrButton(m_uiAnubDoorGUID);
-+        if (uiData == DONE)
-+        {
-+            OpenDoor(m_uiAnubGateGUID);
-+            m_uiArachnofobiaTimer = 0;
-+            m_bIsArachnofobia = true;
-+        }
-+        break;
-+    case TYPE_FAERLINA:
-+        m_auiEncounter[1] = uiData;
-+        DoUseDoorOrButton(m_uiFaerWebGUID);
-+        if (uiData == DONE)
-+        {
-+            OpenDoor(m_uiFaerDoorGUID);
-+            OpenDoor(m_uiMaexOuterGUID);
-+        }
-+        break;
-+    case TYPE_MAEXXNA:
-+        m_auiEncounter[2] = uiData;
-+        DoUseDoorOrButton(m_uiMaexInnerGUID, uiData);
-+        if (uiData == DONE)
-+        {
-+            DoUseDoorOrButton(m_uiAracEyeRampGUID);
-+            DoUseDoorOrButton(m_uiAracEyeGUID);
-+            DoRespawnGameObject(m_uiAracPortalGUID, 30*MINUTE);
-+            Immortal();
-+
-+            // Arachnofobia
-+            if(m_uiArachnofobiaTimer <= 20 * 60000 && m_bIsArachnofobia)
-             {
--                DoUseDoorOrButton(m_uiMiliEyeRampGUID);
--                DoRespawnGameObject(m_uiMiliPortalGUID, 30*MINUTE);
--                DoRespawnGameObject(m_uiHorsemenChestGUID, 30*MINUTE);
-+                Arachnofobia();
-+                m_bIsArachnofobia = false;
-             }
-+        }
-+        break;
-+    case TYPE_NOTH:
-+        m_auiEncounter[3] = uiData;
-+        DoUseDoorOrButton(m_uiNothEntryDoorGUID);
-+        if (uiData == DONE)
-+        {
-+            OpenDoor(m_uiNothExitDoorGUID);
-+            OpenDoor(m_uiHeigEntryDoorGUID);
-+        }
-+        break;
-+    case TYPE_HEIGAN:
-+        m_auiEncounter[4] = uiData;
-+        DoUseDoorOrButton(m_uiHeigEntryDoorGUID);
-+        if (uiData == DONE)
-+        {
-+            OpenDoor(m_uiHeigExitDoorGUID);
-+            OpenDoor(m_uiLoathebDoorGUID);
-+        }
-+        break;
-+    case TYPE_LOATHEB:
-+        m_auiEncounter[5] = uiData;
-+        DoUseDoorOrButton(m_uiLoathebDoorGUID);
-+        if (uiData == DONE)
-+        {
-+            DoUseDoorOrButton(m_uiPlagEyeRampGUID);
-+            DoUseDoorOrButton(m_uiPlagEyeGUID);
-+            DoRespawnGameObject(m_uiPlagPortalGUID, 30*MINUTE);
-+            Immortal();
-+        }
-+        break;
-+    case TYPE_RAZUVIOUS:
-+        m_auiEncounter[6] = uiData;
-+        if (uiData == DONE)
-+            OpenDoor(m_uiGothikEntryDoorGUID);
-+        break;
-+    case TYPE_GOTHIK:
-+        switch(uiData)
-+        {
-+        case IN_PROGRESS:
-+            DoUseDoorOrButton(m_uiGothikEntryDoorGUID);
-+            DoUseDoorOrButton(m_uiGothCombatGateGUID);
-             break;
--        case TYPE_PATCHWERK:
--            m_auiEncounter[9] = uiData;
--            if (uiData == DONE)
--                DoUseDoorOrButton(m_uiPathExitDoorGUID);
-+        case SPECIAL:
-+            DoUseDoorOrButton(m_uiGothCombatGateGUID);
-             break;
--        case TYPE_GROBBULUS:
--            m_auiEncounter[10] = uiData;
-+        case FAIL:
-+            if (m_auiEncounter[7] == IN_PROGRESS)
-+                DoUseDoorOrButton(m_uiGothCombatGateGUID);
-+
-+            DoUseDoorOrButton(m_uiGothikEntryDoorGUID);
-             break;
--        case TYPE_GLUTH:
--            m_auiEncounter[11] = uiData;
--            if (uiData == DONE)
--            {
--                DoUseDoorOrButton(m_uiGlutExitDoorGUID);
--                DoUseDoorOrButton(m_uiThadDoorGUID);
--            }
-+        case DONE:
-+            OpenDoor(m_uiGothikEntryDoorGUID);
-+            OpenDoor(m_uiGothikExitDoorGUID);
-+            OpenDoor(m_uiHorsemenDoorGUID);
-+            OpenDoor(m_uiGothCombatGateGUID);
-             break;
--        case TYPE_THADDIUS:
--            m_auiEncounter[12] = uiData;
-+        }
-+        m_auiEncounter[7] = uiData;
-+        break;
-+    case TYPE_FOUR_HORSEMEN:
-+        m_auiEncounter[8] = uiData;
-+        DoUseDoorOrButton(m_uiHorsemenDoorGUID);
-+        if (uiData == DONE)
-+        {
-+            //DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, 59450);
-+            DoUseDoorOrButton(m_uiMiliEyeRampGUID);
-+            DoUseDoorOrButton(m_uiMiliEyeGUID);
-+            DoRespawnGameObject(m_uiMiliPortalGUID, 30*MINUTE);
-+            DoRespawnGameObject(m_uiHorsemenChestGUID, 30*MINUTE);
-+            Immortal();
-+        }
-+        break;
-+    case TYPE_PATCHWERK:
-+        m_auiEncounter[9] = uiData;
-+        if (uiData == DONE)
-+            OpenDoor(m_uiPathExitDoorGUID);
-+        break;
-+    case TYPE_GROBBULUS:
-+        m_auiEncounter[10] = uiData;
-+        break;
-+    case TYPE_GLUTH:
-+        m_auiEncounter[11] = uiData;
-+        if (uiData == DONE)
-+        {
-+            OpenDoor(m_uiGlutExitDoorGUID);
-+            OpenDoor(m_uiThadDoorGUID);
-+        }
-+        break;
-+    case TYPE_THADDIUS:
-+        m_auiEncounter[12] = uiData;
-+        if(uiData != SPECIAL)
-             DoUseDoorOrButton(m_uiThadDoorGUID, uiData);
--            if (uiData == DONE)
--            {
--                DoUseDoorOrButton(m_uiConsEyeRampGUID);
--                DoRespawnGameObject(m_uiConsPortalGUID, 30*MINUTE);
--            }
--            break;
--        case TYPE_SAPPHIRON:
--            m_auiEncounter[13] = uiData;
--            if (uiData == DONE)
--                DoUseDoorOrButton(m_uiKelthuzadDoorGUID);
--            break;
--        case TYPE_KELTHUZAD:
--            switch(uiData)
-+        if(uiData == FAIL)
-+            OpenDoor(m_uiThadDoorGUID);
-+        if (uiData == DONE)
-+        {
-+            DoUseDoorOrButton(m_uiConsEyeRampGUID);
-+            DoUseDoorOrButton(m_uiConsEyeGUID);
-+            DoRespawnGameObject(m_uiConsPortalGUID, 30*MINUTE);
-+            Immortal();
-+        }
-+        break;
-+    case TYPE_SAPPHIRON:
-+        m_auiEncounter[13] = uiData;
-+        if (uiData == DONE)
-+        {
-+            OpenDoor(m_uiKelthuzadWaterfallDoorGUID);
-+            OpenDoor(m_uiKelthuzadDoorGUID);
-+        }
-+        break;
-+    case TYPE_KELTHUZAD: 
-+        //DoUseDoorOrButton(m_uiKelthuzadDoorGUID);
-+        switch(uiData)
-+        {
-+        case SPECIAL:
-             {
--                case SPECIAL:
--                {
--                    Map::PlayerList const& lPlayers = instance->GetPlayers();
-+                Map::PlayerList const& lPlayers = instance->GetPlayers();
- 
--                    if (lPlayers.isEmpty())
--                        return;
-+                if (lPlayers.isEmpty())
-+                    return;
- 
--                    bool bCanBegin = true;
-+                bool bCanBegin = true;
- 
--                    for(Map::PlayerList::const_iterator itr = lPlayers.begin(); itr != lPlayers.end(); ++itr)
-+                for(Map::PlayerList::const_iterator itr = lPlayers.begin(); itr != lPlayers.end(); ++itr)
-+                {
-+                    if (Player* pPlayer = itr->getSource())
-                     {
--                        if (Player* pPlayer = itr->getSource())
--                        {
--                            if (!pPlayer->IsWithinDist2d(m_fChamberCenterX, m_fChamberCenterY, 15.0f))
--                                bCanBegin = false;
--                        }
-+                        if (!pPlayer->IsWithinDist2d(m_fChamberCenterX, m_fChamberCenterY, 15.0f))
-+                            bCanBegin = false;
-                     }
-+                }
- 
--                    if (bCanBegin)
--                        m_auiEncounter[14] = IN_PROGRESS;
--
--                    break;
-+                if (bCanBegin)
-+                {
-+                    m_auiEncounter[14] = IN_PROGRESS;
-+                    CloseDoor(m_uiKelthuzadDoorGUID);
-                 }
--                case FAIL:
--                    m_auiEncounter[14] = NOT_STARTED;
--                    break;
--                default:
--                    m_auiEncounter[14] = uiData;
--                    break;
-+
-+                break;
-             }
-+        case FAIL:
-+            m_auiEncounter[14] = NOT_STARTED;
-+            OpenDoor(m_uiKelthuzadDoorGUID);
-+            break;
-+        case DONE:
-+            OpenDoor(m_uiKelthuzadDoorGUID);
-+            Immortal();
-+            break;
-+        default:
-+            m_auiEncounter[14] = uiData;
-             break;
-+        }
-+        break;
-+    case TYPE_IMMORTAL:
-+        m_auiEncounter[15] = uiData;
-+        break;
-+        //Four Horsemen Chest
-+    case TYPE_BLAUMEAUX:
-+        if (uiData == DONE)
-+        {
-+            BlaumeuxDead = true;
-+            UpdateCheck = true;
-+            Horseman();
-+        }
-+        break;
-+    case TYPE_RIVENDARE:
-+        if (uiData == DONE)
-+        {
-+            RivendareDead = true;
-+            UpdateCheck = true;
-+            Horseman();
-+        }
-+        break;
-+    case TYPE_ZELIEK:
-+        if (uiData == DONE)
-+        {
-+            ZeliekDead = true;
-+            UpdateCheck = true;
-+            Horseman();
-+        }
-+        break;
-+    case TYPE_KORTHAZZ:
-+        if (uiData == DONE)
-+        {
-+            KorthazzDead = true;
-+            UpdateCheck = true;
-+            Horseman();
-+        }
-+        break;
-+    case TYPE_STALAGG:
-+        m_auiStalaggEncounter = uiData;
-+        break;
-+    case TYPE_FEUGEN:
-+        m_auiFeugenEncouter = uiData;
-+        break;
-     }
- 
-     if (uiData == DONE)
-@@ -408,7 +617,8 @@ void instance_naxxramas::SetData(uint32 uiType, uint32 uiData)
-             << m_auiEncounter[3] << " " << m_auiEncounter[4] << " " << m_auiEncounter[5] << " "
-             << m_auiEncounter[6] << " " << m_auiEncounter[7] << " " << m_auiEncounter[8] << " "
-             << m_auiEncounter[9] << " " << m_auiEncounter[10] << " " << m_auiEncounter[11] << " "
--            << m_auiEncounter[12] << " " << m_auiEncounter[13] << " " << m_auiEncounter[14];
-+            << m_auiEncounter[12] << " " << m_auiEncounter[13] << " " << m_auiEncounter[14] << " " 
-+            << m_auiEncounter[15];
- 
-         strInstData = saveStream.str();
- 
-@@ -429,9 +639,9 @@ void instance_naxxramas::Load(const char* chrIn)
- 
-     std::istringstream loadStream(chrIn);
-     loadStream >> m_auiEncounter[0] >> m_auiEncounter[1] >> m_auiEncounter[2] >> m_auiEncounter[3]
--        >> m_auiEncounter[4] >> m_auiEncounter[5] >> m_auiEncounter[6] >> m_auiEncounter[7]
--        >> m_auiEncounter[8] >> m_auiEncounter[9] >> m_auiEncounter[10] >> m_auiEncounter[11]
--        >> m_auiEncounter[12] >> m_auiEncounter[13] >> m_auiEncounter[14];
-+    >> m_auiEncounter[4] >> m_auiEncounter[5] >> m_auiEncounter[6] >> m_auiEncounter[7]
-+    >> m_auiEncounter[8] >> m_auiEncounter[9] >> m_auiEncounter[10] >> m_auiEncounter[11]
-+    >> m_auiEncounter[12] >> m_auiEncounter[13] >> m_auiEncounter[14] >> m_auiEncounter[15];
- 
-     for(uint8 i = 0; i < MAX_ENCOUNTER; ++i)
-     {
-@@ -442,40 +652,121 @@ void instance_naxxramas::Load(const char* chrIn)
-     OUT_LOAD_INST_DATA_COMPLETE;
- }
- 
-+void instance_naxxramas::Horseman()
-+{
-+    // check the 4 horseman and also check the other bosses in Military quaters
-+    if (BlaumeuxDead && RivendareDead && ZeliekDead && KorthazzDead)
-+    {
-+        SetData(TYPE_FOUR_HORSEMEN, DONE);
-+
-+        // check if the other bosses in military are dead
-+        if(m_auiEncounter[7] == DONE && m_auiEncounter[6] == DONE && this)
-+            DoCompleteAchievement(instance->IsRegularDifficulty() ? ACHIEVEMENT_HORSEMEN : H_ACHIEVEMENT_HORSEMEN);
-+    }
-+}
-+
-+void instance_naxxramas::Arachnofobia()
-+{
-+    if(this)
-+        DoCompleteAchievement(instance->IsRegularDifficulty() ? ACHIEV_ARACHNOFOBIA : ACHIEV_ARACHNOFOBIA_H);
-+}
-+
-+void instance_naxxramas::Immortal()
-+{
-+    if(m_auiEncounter[15] != FAIL)
-+    {
-+        if(m_auiEncounter[14] == DONE && m_auiEncounter[12] == DONE && m_auiEncounter[2] == DONE && m_auiEncounter[5] == DONE && m_auiEncounter[8] == DONE)
-+        {
-+            if(this)
-+                DoCompleteAchievement(instance->IsRegularDifficulty() ? ACHIEV_THE_UNDYING : ACHIEV_THE_IMMORTAL);
-+        }
-+    }
-+}
-+
-+void instance_naxxramas::IsRaidWiped()
-+{
-+    Map::PlayerList const &players = instance->GetPlayers();
-+    for (Map::PlayerList::const_iterator i = players.begin(); i != players.end(); ++i)
-+    {
-+        if(Player* pPlayer = i->getSource())
-+        {
-+            if(!pPlayer->isAlive())
-+                m_auiEncounter[15] = FAIL;
-+        }
-+    }
-+}
-+
-+void instance_naxxramas::Update(uint32 uiDiff)
-+{
-+    // Down they fall together achiev
-+    if (BlaumeuxDead || RivendareDead || ZeliekDead || KorthazzDead)
-+    {
-+        if (DeadTimer < 15000 && UpdateCheck)
-+        {
-+            if (BlaumeuxDead && RivendareDead && ZeliekDead && KorthazzDead)
-+            {
-+                if(this)
-+                    DoCompleteAchievement(instance->IsRegularDifficulty() ? ACHIEVEMENT_TOGETHER : H_ACHIEVEMENT_TOGETHER);
-+
-+                UpdateCheck = false;
-+            }
-+            else 
-+                DeadTimer += uiDiff;
-+        }
-+    }
-+
-+    // Arachnofobia achiev
-+    if(m_bIsArachnofobia)
-+        m_uiArachnofobiaTimer += uiDiff;
-+
-+    // Immortal check
-+    if (m_uiImmortaCheck < uiDiff)
-+    {
-+        IsRaidWiped();
-+        m_uiImmortaCheck = 1000;
-+    }else m_uiImmortaCheck -= uiDiff;
-+}
-+
- uint32 instance_naxxramas::GetData(uint32 uiType)
- {
-     switch(uiType)
-     {
--        case TYPE_ANUB_REKHAN:
--            return m_auiEncounter[0];
--        case TYPE_FAERLINA:
--            return m_auiEncounter[1];
--        case TYPE_MAEXXNA:
--            return m_auiEncounter[2];
--        case TYPE_NOTH:
--            return m_auiEncounter[3];
--        case TYPE_HEIGAN:
--            return m_auiEncounter[4];
--        case TYPE_LOATHEB:
--            return m_auiEncounter[5];
--        case TYPE_RAZUVIOUS:
--            return m_auiEncounter[6];
--        case TYPE_GOTHIK:
--            return m_auiEncounter[7];
--        case TYPE_FOUR_HORSEMEN:
--            return m_auiEncounter[8];
--        case TYPE_PATCHWERK:
--            return m_auiEncounter[9];
--        case TYPE_GROBBULUS:
--            return m_auiEncounter[10];
--        case TYPE_GLUTH:
--            return m_auiEncounter[11];
--        case TYPE_THADDIUS:
--            return m_auiEncounter[12];
--        case TYPE_SAPPHIRON:
--            return m_auiEncounter[13];
--        case TYPE_KELTHUZAD:
--            return m_auiEncounter[14];
-+    case TYPE_ANUB_REKHAN:
-+        return m_auiEncounter[0];
-+    case TYPE_FAERLINA:
-+        return m_auiEncounter[1];
-+    case TYPE_MAEXXNA:
-+        return m_auiEncounter[2];
-+    case TYPE_NOTH:
-+        return m_auiEncounter[3];
-+    case TYPE_HEIGAN:
-+        return m_auiEncounter[4];
-+    case TYPE_LOATHEB:
-+        return m_auiEncounter[5];
-+    case TYPE_RAZUVIOUS:
-+        return m_auiEncounter[6];
-+    case TYPE_GOTHIK:
-+        return m_auiEncounter[7];
-+    case TYPE_FOUR_HORSEMEN:
-+        return m_auiEncounter[8];
-+    case TYPE_PATCHWERK:
-+        return m_auiEncounter[9];
-+    case TYPE_GROBBULUS:
-+        return m_auiEncounter[10];
-+    case TYPE_GLUTH:
-+        return m_auiEncounter[11];
-+    case TYPE_THADDIUS:
-+        return m_auiEncounter[12];
-+    case TYPE_SAPPHIRON:
-+        return m_auiEncounter[13];
-+    case TYPE_KELTHUZAD:
-+        return m_auiEncounter[14];
-+    case TYPE_IMMORTAL:
-+        return m_auiEncounter[15];
-+    case TYPE_STALAGG: 
-+        return m_auiStalaggEncounter;
-+    case TYPE_FEUGEN:
-+        return m_auiFeugenEncouter;
-     }
-     return 0;
- }
-@@ -484,28 +775,32 @@ uint64 instance_naxxramas::GetData64(uint32 uiData)
- {
-     switch(uiData)
-     {
--        case NPC_ANUB_REKHAN:
--            return m_uiAnubRekhanGUID;
--        case NPC_FAERLINA:
--            return m_uiFaerlinanGUID;
--        case GO_MILI_GOTH_COMBAT_GATE:
--            return m_uiGothCombatGateGUID;
--        case NPC_ZELIEK:
--            return m_uiZeliekGUID;
--        case NPC_THANE:
--            return m_uiThaneGUID;
--        case NPC_BLAUMEUX:
--            return m_uiBlaumeuxGUID;
--        case NPC_RIVENDARE:
--            return m_uiRivendareGUID;
--        case NPC_THADDIUS:
--            return m_uiThaddiusGUID;
--        case NPC_STALAGG:
--            return m_uiStalaggGUID;
--        case NPC_FEUGEN:
--            return m_uiFeugenGUID;
--        case NPC_GOTHIK:
--            return m_uiGothikGUID;
-+    case NPC_ANUB_REKHAN:
-+        return m_uiAnubRekhanGUID;
-+    case NPC_FAERLINA:
-+        return m_uiFaerlinanGUID;
-+    case GO_MILI_GOTH_COMBAT_GATE:
-+        return m_uiGothCombatGateGUID;
-+    case NPC_ZELIEK:
-+        return m_uiZeliekGUID;
-+    case NPC_THANE:
-+        return m_uiThaneGUID;
-+    case NPC_BLAUMEUX:
-+        return m_uiBlaumeuxGUID;
-+    case NPC_RIVENDARE:
-+        return m_uiRivendareGUID;
-+    case NPC_THADDIUS:
-+        return m_uiThaddiusGUID;
-+    case NPC_STALAGG:
-+        return m_uiStalaggGUID;
-+    case NPC_FEUGEN:
-+        return m_uiFeugenGUID;
-+    case GO_CONS_NOX_TESLA_FEUGEN:
-+        return m_uiThadNoxTeslaFeugenGUID;
-+    case GO_CONS_NOX_TESLA_STALAGG:
-+        return m_uiThadNoxTeslaStalaggGUID;
-+    case NPC_GOTHIK:
-+        return m_uiGothikGUID;
-     }
-     return 0;
- }
-@@ -572,6 +867,7 @@ void instance_naxxramas::GetGothSummonPointCreatures(std::list<Creature*> &lList
- 
- bool instance_naxxramas::IsInRightSideGothArea(Unit* pUnit)
- {
-+    // return true if on undead side
-     if (GameObject* pCombatGate = instance->GetGameObject(m_uiGothCombatGateGUID))
-         return (pCombatGate->GetPositionY() >= pUnit->GetPositionY());
- 
-@@ -608,6 +904,17 @@ bool AreaTrigger_at_naxxramas(Player* pPlayer, AreaTriggerEntry* pAt)
-         }
-     }
- 
-+    if (pAt->id == AREATRIGGER_THADDIUS_DOOR)
-+    {
-+        if (instance_naxxramas* pInstance = (instance_naxxramas*)pPlayer->GetInstanceData())
-+            if (pInstance->GetData(TYPE_THADDIUS) == NOT_STARTED)
-+                if (Creature* pThaddius = pInstance->instance->GetCreature(pInstance->GetData64(NPC_THADDIUS)))
-+                {
-+                    pInstance->SetData(TYPE_THADDIUS, SPECIAL);
-+                    DoScriptText(SAY_THADDIUS_GREET, pThaddius);
-+                }
-+    }
-+
-     return false;
- }
- 
-@@ -624,4 +931,9 @@ void AddSC_instance_naxxramas()
-     pNewScript->Name = "at_naxxramas";
-     pNewScript->pAreaTrigger = &AreaTrigger_at_naxxramas;
-     pNewScript->RegisterSelf();
-+
-+    pNewScript = new Script;
-+    pNewScript->Name = "go_naxxTeleporter";
-+    pNewScript->pGOHello = &GOHello_go_naxxTeleporter;
-+    pNewScript->RegisterSelf();
- }
-diff --git a/scripts/northrend/naxxramas/naxxramas.h b/scripts/northrend/naxxramas/naxxramas.h
-index 49dc479..d4797fd 100644
---- a/scripts/northrend/naxxramas/naxxramas.h
-+++ b/scripts/northrend/naxxramas/naxxramas.h
-@@ -7,7 +7,7 @@
- 
- enum
- {
--    MAX_ENCOUNTER               = 15,
-+    MAX_ENCOUNTER               = 16,
- 
-     TYPE_ANUB_REKHAN            = 1,
-     TYPE_FAERLINA               = 2,
-@@ -31,12 +31,22 @@ enum
-     TYPE_SAPPHIRON              = 16,
-     TYPE_KELTHUZAD              = 17,
- 
-+    //Misc
-+    TYPE_KORTHAZZ,
-+    TYPE_BLAUMEAUX,
-+    TYPE_ZELIEK,
-+    TYPE_RIVENDARE,
-+
-+    TYPE_IMMORTAL,
-+
-     NPC_ANUB_REKHAN             = 15956,
-     NPC_FAERLINA                = 15953,
-+    NPC_LOATHEB                 = 16011,
- 
-     NPC_THADDIUS                = 15928,
-     NPC_STALAGG                 = 15929,
-     NPC_FEUGEN                  = 15930,
-+    NPC_TESLA_COIL              = 16218,
- 
-     NPC_ZELIEK                  = 16063,
-     NPC_THANE                   = 16064,
-@@ -89,16 +99,23 @@ enum
-     // Construct Quarter
-     GO_CONS_PATH_EXIT_DOOR      = 181123,
-     GO_CONS_GLUT_EXIT_DOOR      = 181120,
-+    GO_CONS_NOX_TESLA_FEUGEN    = 181477,
-+    GO_CONS_NOX_TESLA_STALAGG   = 181478,
-     GO_CONS_THAD_DOOR           = 181121,                   // Thaddius enc door
- 
-     // Frostwyrm Lair
-     GO_KELTHUZAD_WATERFALL_DOOR = 181225,                   // exit, open after sapphiron is dead
-+    GO_KELTHUZAD_COMBAT_GATE    = 181228,
- 
-     // Eyes
-     GO_ARAC_EYE_RAMP            = 181212,
-     GO_PLAG_EYE_RAMP            = 181211,
-     GO_MILI_EYE_RAMP            = 181210,
-     GO_CONS_EYE_RAMP            = 181213,
-+    GO_ARAC_EYE                 = 181233,
-+    GO_PLAG_EYE                 = 181231,
-+    GO_MILI_EYE                 = 181230,
-+    GO_CONS_EYE                 = 181232,
- 
-     // Portals
-     GO_ARAC_PORTAL              = 181575,
-@@ -108,7 +125,21 @@ enum
- 
-     AREATRIGGER_FROSTWYRM       = 4120,                    //not needed here, but AT to be scripted
-     AREATRIGGER_KELTHUZAD       = 4112,
--    AREATRIGGER_GOTHIK          = 4116
-+    AREATRIGGER_GOTHIK          = 4116,
-+    AREATRIGGER_THADDIUS_DOOR   = 4113,
-+    SAY_THADDIUS_GREET          = -1533029,
-+
-+    ACHIEVEMENT_HORSEMEN        = 568,
-+    H_ACHIEVEMENT_HORSEMEN      = 569,
-+    ACHIEVEMENT_TOGETHER        = 2176,
-+    H_ACHIEVEMENT_TOGETHER      = 2177,
-+
-+    ACHIEV_ARACHNOFOBIA         = 1858,
-+    ACHIEV_ARACHNOFOBIA_H       = 1859,
-+
-+    // counts for: Thaddius, 4 horseman, maexxna, loatheb, kelthuzad
-+    ACHIEV_THE_UNDYING          = 2187, // on 10 man
-+    ACHIEV_THE_IMMORTAL         = 2186, // on 25 man
- };
- 
- struct GothTrigger
-@@ -136,6 +167,7 @@ class MANGOS_DLL_DECL instance_naxxramas : public ScriptedInstance
- 
-         const char* Save() { return strInstData.c_str(); }
-         void Load(const char* chrIn);
-+        void Update(uint32 uiDiff);
- 
-         // goth
-         void SetGothTriggers();
-@@ -143,6 +175,9 @@ class MANGOS_DLL_DECL instance_naxxramas : public ScriptedInstance
-         void GetGothSummonPointCreatures(std::list<Creature*> &lList, bool bRightSide);
-         bool IsInRightSideGothArea(Unit* pUnit);
- 
-+        // thaddius
-+        void GetThadTeslaCreatures(std::list<uint64> &lList){ lList = m_lThadTeslaCoilList; };
-+
-         // kel
-         void SetChamberCenterCoords(float fX, float fY, float fZ);
-         void GetChamberCenterCoords(float &fX, float &fY, float &fZ) { fX = m_fChamberCenterX; fY = m_fChamberCenterY; fZ = m_fChamberCenterZ; }
-@@ -161,6 +196,11 @@ class MANGOS_DLL_DECL instance_naxxramas : public ScriptedInstance
-         uint64 m_uiMiliPortalGUID;
-         uint64 m_uiConsPortalGUID;
- 
-+        uint64 m_uiAracEyeGUID;
-+        uint64 m_uiPlagEyeGUID;
-+        uint64 m_uiMiliEyeGUID;
-+        uint64 m_uiConsEyeGUID;
-+
-         uint64 m_uiAnubRekhanGUID;
-         uint64 m_uiFaerlinanGUID;
- 
-@@ -176,6 +216,9 @@ class MANGOS_DLL_DECL instance_naxxramas : public ScriptedInstance
-         uint64 m_uiPathExitDoorGUID;
-         uint64 m_uiGlutExitDoorGUID;
-         uint64 m_uiThadDoorGUID;
-+        std::list<uint64> m_lThadTeslaCoilList;
-+        uint64 m_uiThadNoxTeslaFeugenGUID;
-+        uint64 m_uiThadNoxTeslaStalaggGUID;
- 
-         uint64 m_uiAnubDoorGUID;
-         uint64 m_uiAnubGateGUID;
-@@ -201,9 +244,34 @@ class MANGOS_DLL_DECL instance_naxxramas : public ScriptedInstance
-         uint64 m_uiLoathebDoorGUID;
- 
-         uint64 m_uiKelthuzadDoorGUID;
-+        uint64 m_uiKelthuzadWaterfallDoorGUID;
-         float m_fChamberCenterX;
-         float m_fChamberCenterY;
-         float m_fChamberCenterZ;
-+
-+        bool BlaumeuxDead;
-+        bool RivendareDead;
-+        bool ZeliekDead;
-+        bool KorthazzDead;
-+        uint32 m_auiStalaggEncounter;
-+        uint32 m_auiFeugenEncouter;
-+
-+        int32 DeadTimer;
-+        uint32 HorsemanDeadCount;
-+        bool UpdateCheck;
-+
-+        uint32 m_uiArachnofobiaTimer;
-+        bool m_bIsArachnofobia;
-+
-+        uint32 m_uiImmortaCheck;
-+
-+        void CloseDoor(uint64 guid);
-+        void OpenDoor(uint64 guid);
-+
-+        void Horseman();
-+        void IsRaidWiped();
-+        void Immortal();
-+        void Arachnofobia();
- };
- 
- #endif
-diff --git a/sql/Custom_Updates/Mangos/Northrend/Naxxramas_Mangos.sql b/sql/Custom_Updates/Mangos/Northrend/Naxxramas_Mangos.sql
-new file mode 100644
-index 0000000..597092a
---- /dev/null
-+++ b/sql/Custom_Updates/Mangos/Northrend/Naxxramas_Mangos.sql
-@@ -0,0 +1,52 @@
-+/* NAXXRAMAS */
-+UPDATE creature_template SET ScriptName = "npc_stalagg" WHERE entry= 15929;
-+UPDATE creature_template SET ScriptName = "npc_feugen" WHERE entry= 15930;
-+UPDATE creature_template SET ScriptName = "boss_thaddius"  WHERE entry= 15928;
-+UPDATE creature_template SET ScriptName = "npc_tesla_coil" WHERE entry = 16218;
-+-- spawn two dummies for teslas
-+UPDATE creature_template SET InhabitType=4 WHERE entry = 16218;
-+DELETE FROM creature WHERE id = 16218;
-+INSERT INTO creature VALUES (800020,16218,533,1,1,0,0,3487.17,-2911.54,319.417,5.71991,25,2,0,300,0,0,1);
-+INSERT INTO creature VALUES (800021,16218,533,1,1,0,0,3527.79,-2952.2,319.422,4.16378,25,2,0,300,0,0,1);
-+
-+DELETE FROM spell_script_target WHERE entry in (28087, 28096, 28111, 28159);
-+INSERT INTO spell_script_target VALUES
-+(28159, 1, 15928),
-+(28087, 1, 16218),
-+(28096, 1, 15929),
-+(28111, 1, 15930);
-+
-+DELETE FROM areatrigger_scripts WHERE entry = 4113;
-+INSERT INTO areatrigger_scripts VALUES
-+(4113, 'at_naxxramas');
-+
-+DELETE FROM scriptdev2.script_texts WHERE entry BETWEEN -1533149 AND -1533147;
-+INSERT INTO scriptdev2.script_texts (entry,content_default,sound,type,language,emote,comment) VALUES
-+(-1533147,'%s loses its link!',0,3,0,0,'tesla_coil EMOTE_LOSING_LINK'),
-+(-1533148,'%s overloads!',0,3,0,0,'tesla_coil EMOTE_TESLA_OVERLOAD'),
-+(-1533149,'The polarity has shifted!',0,3,0,0,'thaddius EMOTE_POLARITY_SHIFT');
-+
-+UPDATE `gameobject` SET `state` = 1 WHERE `guid` = 73469;
-+UPDATE `gameobject_template` SET `faction` = 114, `data0` = '1' where `entry` in (194022, 181195, 181228, 181225, 181201, 181200);
-+UPDATE `gameobject_template` SET `faction` = 114 where `entry` in (181234, 181169, 181168, 181477, 181478);
-+-- portals
-+UPDATE `gameobject_template` SET `faction` = 114 where `entry` in (181212, 181211, 181210, 181213);
-+update `gameobject_template` set `ScriptName` = 'go_naxxTeleporter' where entry in (181575, 181577, 181578, 181576);
-+-- Zombie crow, Gluth
-+Update `creature_template` set `ScriptName` = 'mob_zombie_chows' where `entry` = 16360;
-+Update `creature_template` set `ScriptName` = 'mob_worshippers' where `entry` = 16506;
-+Update `creature_template` set `ScriptName` = 'mob_unstoppable_abomination' where `entry` = 16428;
-+-- Grobbulus
-+Update `creature_template` set `ScriptName` = 'npc_grobbulus_poison_cloud' where `entry` = 16363;
-+Update `creature_template` set `ScriptName` = 'boss_grobbulus' where `entry` = 15931;
-+-- Loatheb
-+Update `creature_template` set `ScriptName` = 'npc_loatheb_spores' where `entry` = 16286;
-+-- Noth: fix guardians hp
-+Update `creature_template` set `minhealth` = 104264, `maxhealth` = 104264 where `entry` = 16983;
-+Update `creature_template` set `minhealth` = 104264, `maxhealth` = 104264 where `entry` = 16984;
-+-- Razu
-+Update `creature_template` set npcFlag =1, unit_flags = 68, `ScriptName` = 'npc_obedience_crystal' where `entry` = 29912;
-+-- enable los for gothik door
-+Update `gameobject_template` set data10 = 1 where `entry` = 181170;
-+UPDATE creature_template SET `unk16` = 200, `type_flags` = 1024 WHERE entry in (30641, 16129);
-+UPDATE creature_template SET `faction_A` = 14, `faction_H` = 14 WHERE entry = 16363;
-\ No newline at end of file
diff --git a/scripts/northrend/naxxramas/boss_anubrekhan.cpp b/scripts/northrend/naxxramas/boss_anubrekhan.cpp
index 3959ef7..2fac88a 100644
--- a/scripts/northrend/naxxramas/boss_anubrekhan.cpp
+++ b/scripts/northrend/naxxramas/boss_anubrekhan.cpp
@@ -1,4 +1,4 @@
-/* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+s /* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation; either version 2 of the License, or
@@ -47,9 +47,12 @@ enum
     SPELL_SELF_SPAWN_5          = 29105,                    //This spawns 5 corpse scarabs ontop of us (most likely the pPlayer casts this on death)
     SPELL_SELF_SPAWN_10         = 28864,                    //This is used by the crypt guards when they die
 
-    NPC_CRYPT_GUARD             = 16573
+    NPC_CRYPT_GUARD             = 16573,
+    NPC_CORPSE_SCARAB           = 16698,
 };
 
+static const uint32 MAX_CRYPT_GUARDS = 8;
+
 struct MANGOS_DLL_DECL boss_anubrekhanAI : public ScriptedAI
 {
     boss_anubrekhanAI(Creature* pCreature) : ScriptedAI(pCreature)
@@ -68,11 +71,39 @@ struct MANGOS_DLL_DECL boss_anubrekhanAI : public ScriptedAI
     uint32 m_uiSummonTimer;
     bool   m_bHasTaunted;
 
+    uint32 RiseFromCorpse_Timer;
+
+    uint64 guidCryptGuards[MAX_CRYPT_GUARDS];
+    uint32 CryptGuard_count;
+
+    bool swarm;                        //is active spell LocustSwarm or not, when active he cannot use other spels
+
     void Reset()
     {
         m_uiImpaleTimer = 15000;                            // 15 seconds
         m_uiLocustSwarmTimer = urand(80000, 120000);        // Random time between 80 seconds and 2 minutes for initial cast
         m_uiSummonTimer = m_uiLocustSwarmTimer + 45000;     // 45 seconds after initial locust swarm
+
+        swarm = false;
+        CryptGuard_count = 0;
+
+        // Remove all Crypt Guards
+        for (int i = 0; i < MAX_CRYPT_GUARDS; i++)
+        {
+            //delete creature
+            Unit* pUnit = Unit::GetUnit((*m_creature), guidCryptGuards[i]);
+            if (pUnit)
+                pUnit->AddObjectToRemoveList();
+            guidCryptGuards[i] = 0;
+        }
+        
+        //Remove all corpse scarabs
+        std::list<Creature*> CorpseScarabs = GetCreaturesByEntry(NPC_CORPSE_SCARAB);
+        if (!CorpseScarabs.empty())
+            for(std::list<Creature*>::iterator itr = CorpseScarabs.begin(); itr != CorpseScarabs.end(); ++itr)
+                (*itr)->AddObjectToRemoveList();
+
+        //if anubrekhan is alive -> this must be first time we entered Arachnid Quarter -> close all other doors
     }
 
     void KilledUnit(Unit* pVictim)
@@ -130,44 +161,128 @@ struct MANGOS_DLL_DECL boss_anubrekhanAI : public ScriptedAI
         ScriptedAI::MoveInLineOfSight(pWho);
     }
 
+    bool IsVisible(Unit* who) const
+    {
+        if (!who)
+            return false;
+        return m_creature->IsWithinDistInMap(who, 100.0f);
+    }
+
+    std::list<Creature*> GetCreaturesByEntry(uint32 entry)
+    {
+        CellPair pair(MaNGOS::ComputeCellPair(m_creature->GetPositionX(), m_creature->GetPositionY()));
+        Cell cell(pair);
+        cell.data.Part.reserved = ALL_DISTRICT;
+        cell.SetNoCreate();
+
+        std::list<Creature*> creatureList;
+
+        AllCreaturesOfEntryInRange check(m_creature, entry, 100);
+        MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange> searcher(m_creature, creatureList, check);
+        TypeContainerVisitor<MaNGOS::CreatureListSearcher<AllCreaturesOfEntryInRange>, GridTypeMapContainer> visitor(searcher);
+
+        cell.Visit(pair, visitor, *(m_creature->GetMap()));
+
+        return creatureList;
+    }
+
+    void JustSummoned(Creature* temp) 
+    {
+        if (!temp)
+            return;
+
+        //Summoned Crypt Guard will target random player
+        guidCryptGuards[CryptGuard_count++] = temp->GetGUID();
+        if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+        {
+            temp->AddThreat(target);
+            m_creature->SetInCombatWithZone();
+        }
+
+        switch (rand()%4)
+        {
+            case 0: DoScriptText(SAY_TAUNT1, m_creature); break;
+            case 1: DoScriptText(SAY_TAUNT2, m_creature); break;
+            case 2: DoScriptText(SAY_TAUNT3, m_creature); break;
+            case 3: DoScriptText(SAY_TAUNT4, m_creature); break;
+        }
+    }
+
     void UpdateAI(const uint32 uiDiff)
     {
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
             return;
 
-        // Impale
-        if (m_uiImpaleTimer < uiDiff)
+        //SumonFirstCryptGuard_Timer
+        if (m_uiSummonTimer< uiDiff)
         {
-            //Cast Impale on a random target
-            //Do NOT cast it when we are afflicted by locust swarm
-            if (!m_creature->HasAura(SPELL_LOCUSTSWARM) || !m_creature->HasAura(SPELL_LOCUSTSWARM_H))
-            {
-                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM,0))
-                    DoCastSpellIfCan(target, m_bIsRegularMode ? SPELL_IMPALE : SPELL_IMPALE_H);
-            }
+            if (CryptGuard_count < MAX_CRYPT_GUARDS)
+                DoSpawnCreature(NPC_CRYPT_GUARD,0,0,0,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,10000);
+            m_uiSummonTimer = 2000000;
+        }else m_uiSummonTimer -= uiDiff;
 
-            m_uiImpaleTimer = 15000;
-        }
-        else
-            m_uiImpaleTimer -= uiDiff;
+        //RiseFromCorpse_Timer
+        if (RiseFromCorpse_Timer < uiDiff)
+        {
+            RiseFromCorpse_Timer = 60000 + (rand()%10000);
+            std::list<Creature*> CryptGuards = GetCreaturesByEntry(NPC_CRYPT_GUARD);
+            if (!CryptGuards.empty())
+                for(std::list<Creature*>::iterator itr = CryptGuards.begin(); itr != CryptGuards.end(); ++itr)
+                    if ((*itr)->isDead())
+                    {
+                        (*itr)->CastSpell((*itr),SPELL_SELF_SPAWN_10,true);
+                        (*itr)->AddObjectToRemoveList();
+                    }
+
+            const Map::PlayerList &players = m_creature->GetMap()->GetPlayers();
+            if (players.isEmpty())
+                return;
+
+            for(Map::PlayerList::const_iterator i = players.begin(); i != players.end(); ++i)
+                if (Player* pPlayer = i->getSource())
+                {
+                    if (pPlayer->isGameMaster())
+                        continue;
+
+                    if (pPlayer->isDead())
+                        pPlayer->CastSpell(pPlayer,SPELL_SELF_SPAWN_5,true);
+                }
+            CryptGuards.clear();
+        }else RiseFromCorpse_Timer -= uiDiff; 
 
-        // Locust Swarm
-        if (m_uiLocustSwarmTimer < uiDiff)
+        if(!swarm)
         {
-            DoCastSpellIfCan(m_creature, m_bIsRegularMode ? SPELL_LOCUSTSWARM :SPELL_LOCUSTSWARM_H);
-            m_uiLocustSwarmTimer = 90000;
+            //Impale_Timer
+            if (m_uiImpaleTimer < uiDiff)
+            {
+                //Cast Impale on a random target
+                //Do NOT cast it when we are afflicted by locust swarm
+                if (!m_creature->HasAura(m_bIsRegularMode ? SPELL_LOCUSTSWARM : SPELL_LOCUSTSWARM_H, EFFECT_INDEX_1))
+                    if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 1))
+                        DoCast(target,m_bIsRegularMode ? SPELL_IMPALE : SPELL_IMPALE_H);
+                m_uiImpaleTimer = 15000;
+            }else m_uiImpaleTimer -= uiDiff;
+
+            //LocustSwarm_Timer
+            if (m_uiLocustSwarmTimer < uiDiff)
+            {
+                //Cast Locust Swarm buff on ourselves
+                DoCast(m_creature, m_bIsRegularMode ? SPELL_LOCUSTSWARM : SPELL_LOCUSTSWARM_H);
+                swarm = true;
+                //Summon Crypt Guard immidietly after Locust Swarm
+                if (CryptGuard_count < MAX_CRYPT_GUARDS)
+                    DoSpawnCreature(NPC_CRYPT_GUARD,0,0,0,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,10000);
+                m_uiLocustSwarmTimer = 20000;
+            }else m_uiLocustSwarmTimer -= uiDiff;
         }
         else
-            m_uiLocustSwarmTimer -= uiDiff;
-
-        // Summon
-        /*if (m_uiSummonTimer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature, SPELL_SUMMONGUARD);
-            Summon_Timer = 45000;
+            if (m_uiLocustSwarmTimer < uiDiff)
+            {            
+                swarm = false;
+                m_uiLocustSwarmTimer = 60000 + rand()%20000;
+            }else m_uiLocustSwarmTimer -= uiDiff;
         }
-        else
-            m_uiSummonTimer -= uiDiff;*/
 
         DoMeleeAttackIfReady();
     }
diff --git a/scripts/northrend/naxxramas/boss_faerlina.cpp b/scripts/northrend/naxxramas/boss_faerlina.cpp
index 52499bb..95321a7 100644
--- a/scripts/northrend/naxxramas/boss_faerlina.cpp
+++ b/scripts/northrend/naxxramas/boss_faerlina.cpp
@@ -41,8 +41,17 @@ enum
     H_SPELL_POSIONBOLT_VOLLEY = 54098,
     SPELL_ENRAGE              = 28798,
     H_SPELL_ENRAGE            = 54100,
+    SPELL_WIDOWS_EMBRACE       = 28732,
+    SPELL_FIREBALL            = 54095,
+    SPELL_FIREBALL_H          = 54096,
 
-    SPELL_RAINOFFIRE          = 28794                       //Not sure if targeted AoEs work if casted directly upon a pPlayer
+    SPELL_RAINOFFIRE          = 28794,                       //Not sure if targeted AoEs work if casted directly upon a pPlayer
+
+    NPC_NAXX_FOLLOWER           = 16505,
+    NPC_NAXX_WORSHIPER          = 16506,
+
+    ACHIEV_KNOCK_YOU_OUT        = 1997,
+    ACHIEV_KNOCK_YOU_OUT_H      = 2140,
 };
 struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
 {
@@ -62,11 +71,38 @@ struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
     uint32 m_uiEnrageTimer;
     bool   m_bHasTaunted;
 
+    bool m_bHasFrenzy;
+
+    std::list<Creature*> lFollowers;
+    std::list<Creature*> lWorshipers;
+
     void Reset()
     {
         m_uiPoisonBoltVolleyTimer = 8000;
         m_uiRainOfFireTimer = 16000;
         m_uiEnrageTimer = 60000;
+
+        m_bHasFrenzy = false;
+
+        GetCreatureListWithEntryInGrid(lFollowers, m_creature, NPC_NAXX_FOLLOWER, DEFAULT_VISIBILITY_INSTANCE);
+        if (!lFollowers.empty())
+        {
+            for(std::list<Creature*>::iterator iter = lFollowers.begin(); iter != lFollowers.end(); ++iter)
+            {
+                if ((*iter) && !(*iter)->isAlive())
+                    (*iter)->Respawn();
+            }
+        }
+
+        GetCreatureListWithEntryInGrid(lWorshipers, m_creature, NPC_NAXX_WORSHIPER, DEFAULT_VISIBILITY_INSTANCE);
+        if (!lWorshipers.empty())
+        {
+            for(std::list<Creature*>::iterator iter = lWorshipers.begin(); iter != lWorshipers.end(); ++iter)
+            {
+                if ((*iter) && !(*iter)->isAlive())
+                    (*iter)->Respawn();
+            }
+        }
     }
 
     void Aggro(Unit* pWho)
@@ -105,6 +141,12 @@ struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
 
         if (m_pInstance)
             m_pInstance->SetData(TYPE_FAERLINA, DONE);
+
+        if(m_bHasFrenzy)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_KNOCK_YOU_OUT : ACHIEV_KNOCK_YOU_OUT_H);
+        }
     }
 
     void JustReachedHome()
@@ -121,7 +163,7 @@ struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
         // Poison Bolt Volley
         if (m_uiPoisonBoltVolleyTimer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature->getVictim(), SPELL_POSIONBOLT_VOLLEY);
+            DoCastSpellIfCan(m_creature->getVictim(), !m_bIsRegularMode ? H_SPELL_POSIONBOLT_VOLLEY : SPELL_POSIONBOLT_VOLLEY);
             m_uiPoisonBoltVolleyTimer = 11000;
         }
         else
@@ -141,7 +183,8 @@ struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
         //Enrage_Timer
         if (m_uiEnrageTimer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature, SPELL_ENRAGE);
+            m_bHasFrenzy = true;
+            DoCastSpellIfCan(m_creature, m_bIsRegularMode ? SPELL_ENRAGE : H_SPELL_ENRAGE);
             m_uiEnrageTimer = 61000;
         }
         else 
@@ -151,6 +194,93 @@ struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
     }
 };
 
+struct MANGOS_DLL_DECL mob_worshippersAI : public ScriptedAI
+{
+    mob_worshippersAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+    bool m_bIsDead;
+
+    uint32 m_uiFireball_Timer;
+    uint32 m_uiDeathDelay_Timer;
+
+    void Reset()
+    {
+        m_bIsDead = false;
+        m_uiFireball_Timer = 0;
+        m_uiDeathDelay_Timer = 0;
+    }
+
+    void DamageTaken(Unit* pDoneBy, uint32 &uiDamage)
+    {
+        if (m_bIsDead)
+        {
+            uiDamage = 0;
+            return;
+        }
+
+        if (uiDamage > m_creature->GetHealth())
+        {
+            if (m_creature->IsNonMeleeSpellCasted(false))
+                m_creature->InterruptNonMeleeSpells(false);
+
+            m_creature->RemoveAllAuras();
+            m_creature->AttackStop();
+
+            //DoCast(m_creature, SPELL_WIDOWS_EMBRACE);
+
+            if (m_pInstance)
+                if (Creature* pFaerlina = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(NPC_FAERLINA))))
+                {
+                    if (m_creature->GetDistance2d(pFaerlina) <= 5 && pFaerlina->HasAura(m_bIsRegularMode ? H_SPELL_ENRAGE : SPELL_ENRAGE))
+                        pFaerlina->RemoveAurasDueToSpell(m_bIsRegularMode ? H_SPELL_ENRAGE : SPELL_ENRAGE);
+
+                    //pFaerlina->CastSpell(pFaerlina, SPELL_WIDOWS_EMBRACE, false);
+                }
+
+            m_bIsDead = true;
+            m_uiDeathDelay_Timer = 500;
+
+            uiDamage = 0;
+            return;
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_bIsDead)
+            if (m_uiDeathDelay_Timer < uiDiff)
+            {
+                m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                m_uiDeathDelay_Timer = 0;
+            }
+            else m_uiDeathDelay_Timer -= uiDiff;
+
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim() || m_bIsDead)
+            return;
+
+        if (m_uiFireball_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_FIREBALL_H : SPELL_FIREBALL);
+            m_uiFireball_Timer = 7000 + rand()%4000;
+        }
+        else m_uiFireball_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_worshippers(Creature* pCreature)
+{
+    return new mob_worshippersAI(pCreature);
+}
+
 CreatureAI* GetAI_boss_faerlina(Creature* pCreature)
 {
     return new boss_faerlinaAI(pCreature);
@@ -163,4 +293,9 @@ void AddSC_boss_faerlina()
     NewScript->Name = "boss_faerlina";
     NewScript->GetAI = &GetAI_boss_faerlina;
     NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_worshippers";
+    NewScript->GetAI = &GetAI_mob_worshippers;
+    NewScript->RegisterSelf();
 }
diff --git a/scripts/northrend/naxxramas/boss_four_horsemen.cpp b/scripts/northrend/naxxramas/boss_four_horsemen.cpp
index ca50c0a..d1a70ea 100644
--- a/scripts/northrend/naxxramas/boss_four_horsemen.cpp
+++ b/scripts/northrend/naxxramas/boss_four_horsemen.cpp
@@ -38,7 +38,7 @@ enum
     SAY_BLAU_SPECIAL        = -1533048,
     SAY_BLAU_SLAY           = -1533049,
     SAY_BLAU_DEATH          = -1533050,
-
+    // spells
     SPELL_MARK_OF_BLAUMEUX  = 28833,
     SPELL_UNYILDING_PAIN    = 57381,
     SPELL_VOIDZONE          = 28863,
@@ -57,7 +57,7 @@ enum
     SAY_RIVE_TAUNT2         = -1533072,
     SAY_RIVE_TAUNT3         = -1533073,
     SAY_RIVE_DEATH          = -1533074,
-
+    // spells
     SPELL_MARK_OF_RIVENDARE = 28834,
     SPELL_UNHOLY_SHADOW     = 28882,
     H_SPELL_UNHOLY_SHADOW   = 57369,
@@ -70,8 +70,9 @@ enum
     SAY_KORT_SPECIAL        = -1533055,
     SAY_KORT_SLAY           = -1533056,
     SAY_KORT_DEATH          = -1533057,
-
+    // spells
     SPELL_MARK_OF_KORTHAZZ  = 28832,
+    H_SPELL_METEOR          = 57467,
     SPELL_METEOR            = 26558,                        // m_creature->getVictim() auto-area spell but with a core problem
 
     //sir zeliek
@@ -82,12 +83,13 @@ enum
     SAY_ZELI_SPECIAL        = -1533062,
     SAY_ZELI_SLAY           = -1533063,
     SAY_ZELI_DEATH          = -1533064,
-
+    // spells
     SPELL_MARK_OF_ZELIEK    = 28835,
     SPELL_HOLY_WRATH        = 28883,
     H_SPELL_HOLY_WRATH      = 57466,
     SPELL_HOLY_BOLT         = 57376,
     H_SPELL_HOLY_BOLT       = 57465,
+    SPELL_CONDEMNATION      = 57377, 
 
     // horseman spirits
     NPC_SPIRIT_OF_BLAUMEUX    = 16776,
@@ -96,14 +98,42 @@ enum
     NPC_SPIRIT_OF_ZELIREK     = 16777
 };
 
+/*walk coords*/
+#define WALKX_BLAU                2462.112f
+#define WALKY_BLAU                -2956.598f
+#define WALKZ_BLAU                241.276f
+
+#define WALKX_RIVE                2579.571f
+#define WALKY_RIVE                -2960.945f
+#define WALKZ_RIVE                241.32f
+
+#define WALKX_KORT                2529.108f
+#define WALKY_KORT                -3015.303f
+#define WALKZ_KORT                241.32f
+    
+#define WALKX_ZELI                2521.039f
+#define WALKY_ZELI                -2891.633f
+#define WALKZ_ZELI                241.276f
+
 struct MANGOS_DLL_DECL boss_lady_blaumeuxAI : public ScriptedAI
 {
-    boss_lady_blaumeuxAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_lady_blaumeuxAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
 
+    bool m_bIsRegularMode;
+    ScriptedInstance* m_pInstance;
     uint32 Mark_Timer;
     uint32 VoidZone_Timer;
+    uint32 ShadowboltTimer;
+    uint32 Cast_Timer;
     bool ShieldWall1;
     bool ShieldWall2;
+    bool Move_Check;
+    bool Attack_Check;
 
     void Reset()
     {
@@ -111,11 +141,34 @@ struct MANGOS_DLL_DECL boss_lady_blaumeuxAI : public ScriptedAI
         VoidZone_Timer = 12000;                             // right
         ShieldWall1 = true;
         ShieldWall2 = true;
+        Move_Check = true;
+        ShadowboltTimer = 3000;
+        Cast_Timer = 15000;
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_BLAUMEAUX, NOT_STARTED);
     }
 
     void Aggro(Unit *who)
     {
         DoScriptText(SAY_BLAU_AGGRO, m_creature);
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, IN_PROGRESS);
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_BLAUMEAUX, IN_PROGRESS);
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!pWho)
+            return;
+
+        if (m_creature->Attack(pWho, true))
+        {
+            m_creature->AddThreat(pWho);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+        }
     }
 
     void KilledUnit(Unit* Victim)
@@ -126,6 +179,8 @@ struct MANGOS_DLL_DECL boss_lady_blaumeuxAI : public ScriptedAI
     void JustDied(Unit* Killer)
     {
         DoScriptText(SAY_BLAU_DEATH, m_creature);
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_BLAUMEAUX, DONE);
     }
 
     void UpdateAI(const uint32 uiDiff)
@@ -133,27 +188,52 @@ struct MANGOS_DLL_DECL boss_lady_blaumeuxAI : public ScriptedAI
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
             return;
 
+        //run on aggro
+        if (m_creature->getVictim() && Move_Check)
+        {
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            m_creature->GetMotionMaster()->MovePoint(0, WALKX_BLAU, WALKY_BLAU, WALKZ_BLAU);
+            Move_Check = false;
+        }
+
+        // Cast
+        if (Cast_Timer < uiDiff)
+        {
+            if (m_creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            if(m_creature->getVictim()->IsWithinDist(m_creature, 40))
+            {
+                DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_SHADOW_BOLT : H_SPELL_SHADOW_BOLT);
+                Cast_Timer = 5000;
+            }
+            else
+            {
+                DoCast(m_creature->getVictim(), SPELL_UNYILDING_PAIN);
+                Cast_Timer = 2050;
+            }   
+        }else Cast_Timer -= uiDiff;
+
         // Mark of Blaumeux
         if (Mark_Timer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature->getVictim(),SPELL_MARK_OF_BLAUMEUX);
+            DoCast(m_creature->getVictim(),SPELL_MARK_OF_BLAUMEUX);
             Mark_Timer = 12000;
         }else Mark_Timer -= uiDiff;
 
         // Shield Wall - All 4 horsemen will shield wall at 50% hp and 20% hp for 20 seconds
-        if (ShieldWall1 && m_creature->GetHealthPercent() < 50.0f)
+        if (ShieldWall1 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 50)
         {
             if (ShieldWall1)
             {
-                DoCastSpellIfCan(m_creature,SPELL_SHIELDWALL);
+                DoCast(m_creature,SPELL_SHIELDWALL);
                 ShieldWall1 = false;
             }
         }
-        if (ShieldWall2 && m_creature->GetHealthPercent() < 20.0f)
+        if (ShieldWall2 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 20)
         {
             if (ShieldWall2)
             {
-                DoCastSpellIfCan(m_creature,SPELL_SHIELDWALL);
+                DoCast(m_creature,SPELL_SHIELDWALL);
                 ShieldWall2 = false;
             }
         }
@@ -161,7 +241,7 @@ struct MANGOS_DLL_DECL boss_lady_blaumeuxAI : public ScriptedAI
         // Void Zone
         if (VoidZone_Timer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature->getVictim(),SPELL_VOIDZONE);
+            DoCast(m_creature->getVictim(),m_bIsRegularMode ? SPELL_VOIDZONE : H_SPELL_VOIDZONE);
             VoidZone_Timer = 12000;
         }else VoidZone_Timer -= uiDiff;
 
@@ -176,10 +256,35 @@ CreatureAI* GetAI_boss_lady_blaumeux(Creature* pCreature)
 
 struct MANGOS_DLL_DECL boss_rivendare_naxxAI : public ScriptedAI
 {
-    boss_rivendare_naxxAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_rivendare_naxxAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+    uint32 UnholyShadowTimer;
+    uint32 Mark_Timer;
+    bool ShieldWall1;
+    bool ShieldWall2;
+
+    bool Move_Check;
+    bool Attack_Check;
 
     void Reset()
     {
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_RIVENDARE, NOT_STARTED);
+
+        UnholyShadowTimer = 15000;
+        ShieldWall1 = true;
+        ShieldWall2 = true;
+        Mark_Timer = 20000;
+
+        Move_Check = true;
+        Attack_Check = true;
     }
 
     void Aggro(Unit *who)
@@ -190,6 +295,11 @@ struct MANGOS_DLL_DECL boss_rivendare_naxxAI : public ScriptedAI
             case 1: DoScriptText(SAY_RIVE_AGGRO2, m_creature); break;
             case 2: DoScriptText(SAY_RIVE_AGGRO3, m_creature); break;
         }
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, IN_PROGRESS);
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_RIVENDARE, IN_PROGRESS);
     }
 
     void KilledUnit(Unit* Victim)
@@ -200,6 +310,9 @@ struct MANGOS_DLL_DECL boss_rivendare_naxxAI : public ScriptedAI
     void JustDied(Unit* Killer)
     {
         DoScriptText(SAY_RIVE_DEATH, m_creature);
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_RIVENDARE, DONE);
     }
 
     void UpdateAI(const uint32 uiDiff)
@@ -207,6 +320,55 @@ struct MANGOS_DLL_DECL boss_rivendare_naxxAI : public ScriptedAI
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
             return;
 
+        //run on aggro
+        if (m_creature->getVictim() && Move_Check)
+        {
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            m_creature->GetMotionMaster()->MovePoint(0, WALKX_RIVE, WALKY_RIVE, WALKZ_RIVE);
+            Move_Check = false;
+        }
+        
+        //when reach position, set possible to attack
+        if (m_creature->GetDistance2d(WALKX_RIVE, WALKY_RIVE) <= 2 && Attack_Check)
+        {
+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+            Attack_Check = false;
+        }
+
+        // Mark of Rivendare
+        if (Mark_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(),SPELL_MARK_OF_RIVENDARE);
+            Mark_Timer = 12000;
+        }else Mark_Timer -= uiDiff;
+
+        // Shield Wall - All 4 horsemen will shield wall at 50% hp and 20% hp for 20 seconds
+        if (ShieldWall1 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 50)
+        {
+            if (ShieldWall1)
+            {
+                DoCast(m_creature,SPELL_SHIELDWALL);
+                ShieldWall1 = false;
+            }
+        }
+        if (ShieldWall2 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 20)
+        {
+            if (ShieldWall2)
+            {
+                DoCast(m_creature,SPELL_SHIELDWALL);
+                ShieldWall2 = false;
+            }
+        }
+
+        //Unholy Shadow
+        if(UnholyShadowTimer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_UNHOLY_SHADOW : H_SPELL_UNHOLY_SHADOW);
+            UnholyShadowTimer = 15000;
+        }
+        else UnholyShadowTimer -= uiDiff;
+
         DoMeleeAttackIfReady();
     }
 };
@@ -218,24 +380,45 @@ CreatureAI* GetAI_boss_rivendare_naxx(Creature* pCreature)
 
 struct MANGOS_DLL_DECL boss_thane_korthazzAI : public ScriptedAI
 {
-    boss_thane_korthazzAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_thane_korthazzAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
 
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
     uint32 Mark_Timer;
     uint32 Meteor_Timer;
     bool ShieldWall1;
     bool ShieldWall2;
 
+    bool Move_Check;
+    bool Attack_Check;
+
     void Reset()
     {
         Mark_Timer = 20000;                                 // First Horsemen Mark is applied at 20 sec.
         Meteor_Timer = 30000;                               // wrong
         ShieldWall1 = true;
         ShieldWall2 = true;
+
+        Move_Check = true;
+        Attack_Check = true;
+
+        if(m_pInstance) 
+             m_pInstance->SetData(TYPE_KORTHAZZ, NOT_STARTED);
     }
 
     void Aggro(Unit *who)
     {
         DoScriptText(SAY_KORT_AGGRO, m_creature);
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, IN_PROGRESS);
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_KORTHAZZ, IN_PROGRESS);
     }
 
     void KilledUnit(Unit* Victim)
@@ -246,6 +429,9 @@ struct MANGOS_DLL_DECL boss_thane_korthazzAI : public ScriptedAI
     void JustDied(Unit* Killer)
     {
         DoScriptText(SAY_KORT_DEATH, m_creature);
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_KORTHAZZ, DONE);
     }
 
     void UpdateAI(const uint32 uiDiff)
@@ -253,27 +439,43 @@ struct MANGOS_DLL_DECL boss_thane_korthazzAI : public ScriptedAI
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
             return;
 
+        //run on aggro
+        if (m_creature->getVictim() && Move_Check)
+        {
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            m_creature->GetMotionMaster()->MovePoint(0, WALKX_KORT, WALKY_KORT, WALKZ_KORT);
+            Move_Check = false;
+        }
+        
+        //when reach position, set possible to attack
+        if (m_creature->GetDistance2d(WALKX_KORT, WALKY_KORT) <= 2 && Attack_Check)
+        {
+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+            Attack_Check = false;
+        }
+
         // Mark of Korthazz
         if (Mark_Timer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature->getVictim(),SPELL_MARK_OF_KORTHAZZ);
+            DoCast(m_creature->getVictim(),SPELL_MARK_OF_KORTHAZZ);
             Mark_Timer = 12000;
         }else Mark_Timer -= uiDiff;
 
         // Shield Wall - All 4 horsemen will shield wall at 50% hp and 20% hp for 20 seconds
-        if (ShieldWall1 && m_creature->GetHealthPercent() < 50.0f)
+        if (ShieldWall1 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 50)
         {
             if (ShieldWall1)
             {
-                DoCastSpellIfCan(m_creature,SPELL_SHIELDWALL);
+                DoCast(m_creature,SPELL_SHIELDWALL);
                 ShieldWall1 = false;
             }
         }
-        if (ShieldWall2 && m_creature->GetHealthPercent() < 20.0f)
+        if (ShieldWall2 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 20)
         {
             if (ShieldWall2)
             {
-                DoCastSpellIfCan(m_creature,SPELL_SHIELDWALL);
+                DoCast(m_creature,SPELL_SHIELDWALL);
                 ShieldWall2 = false;
             }
         }
@@ -281,7 +483,7 @@ struct MANGOS_DLL_DECL boss_thane_korthazzAI : public ScriptedAI
         // Meteor
         if (Meteor_Timer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature->getVictim(),SPELL_METEOR);
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_METEOR : H_SPELL_METEOR);
             Meteor_Timer = 20000;                           // wrong
         }else Meteor_Timer -= uiDiff;
 
@@ -296,12 +498,22 @@ CreatureAI* GetAI_boss_thane_korthazz(Creature* pCreature)
 
 struct MANGOS_DLL_DECL boss_sir_zeliekAI : public ScriptedAI
 {
-    boss_sir_zeliekAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_sir_zeliekAI(Creature* pCreature) : ScriptedAI(pCreature) 
+    {
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
 
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
     uint32 Mark_Timer;
     uint32 HolyWrath_Timer;
     bool ShieldWall1;
     bool ShieldWall2;
+    bool Move_Check;
+    bool Attack_Check;
+    uint32 Cast_Timer;
 
     void Reset()
     {
@@ -309,11 +521,21 @@ struct MANGOS_DLL_DECL boss_sir_zeliekAI : public ScriptedAI
         HolyWrath_Timer = 12000;                            // right
         ShieldWall1 = true;
         ShieldWall2 = true;
+        Move_Check = true;
+        Cast_Timer = 15000;
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_ZELIEK, NOT_STARTED);
     }
 
     void Aggro(Unit *who)
     {
         DoScriptText(SAY_ZELI_AGGRO, m_creature);
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, IN_PROGRESS);
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_ZELIEK, IN_PROGRESS);
     }
 
     void KilledUnit(Unit* Victim)
@@ -324,6 +546,22 @@ struct MANGOS_DLL_DECL boss_sir_zeliekAI : public ScriptedAI
     void JustDied(Unit* Killer)
     {
         DoScriptText(SAY_ZELI_DEATH, m_creature);
+
+        if(m_pInstance) 
+            m_pInstance->SetData(TYPE_ZELIEK, DONE);
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!pWho)
+            return;
+
+        if (m_creature->Attack(pWho, true))
+        {
+            m_creature->AddThreat(pWho);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+        }
     }
 
     void UpdateAI(const uint32 uiDiff)
@@ -332,27 +570,52 @@ struct MANGOS_DLL_DECL boss_sir_zeliekAI : public ScriptedAI
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
             return;
 
+           //run on aggro
+        if (m_creature->getVictim() && Move_Check)
+        {
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            m_creature->GetMotionMaster()->MovePoint(0, WALKX_ZELI, WALKY_ZELI, WALKZ_ZELI);
+            Move_Check = false;
+        }
+        
+        // Cast
+        if (Cast_Timer < uiDiff)
+        {
+            if (m_creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            if(m_creature->getVictim()->IsWithinDist(m_creature, 40))
+            {
+                DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_HOLY_BOLT : H_SPELL_HOLY_BOLT);
+                Cast_Timer = 5000;
+            }
+            else
+            {
+                DoCast(m_creature->getVictim(), SPELL_CONDEMNATION);
+                Cast_Timer = 2050;
+            }
+        }else Cast_Timer -= uiDiff;
+
         // Mark of Zeliek
         if (Mark_Timer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature->getVictim(),SPELL_MARK_OF_ZELIEK);
+            DoCast(m_creature->getVictim(),SPELL_MARK_OF_ZELIEK);
             Mark_Timer = 12000;
         }else Mark_Timer -= uiDiff;
 
         // Shield Wall - All 4 horsemen will shield wall at 50% hp and 20% hp for 20 seconds
-        if (ShieldWall1 && m_creature->GetHealthPercent() < 50.0f)
+        if (ShieldWall1 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 50)
         {
             if (ShieldWall1)
             {
-                DoCastSpellIfCan(m_creature,SPELL_SHIELDWALL);
+                DoCast(m_creature,SPELL_SHIELDWALL);
                 ShieldWall1 = false;
             }
         }
-        if (ShieldWall2 && m_creature->GetHealthPercent() < 20.0f)
+        if (ShieldWall2 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 20)
         {
             if (ShieldWall2)
             {
-                DoCastSpellIfCan(m_creature,SPELL_SHIELDWALL);
+                DoCast(m_creature,SPELL_SHIELDWALL);
                 ShieldWall2 = false;
             }
         }
@@ -360,7 +623,7 @@ struct MANGOS_DLL_DECL boss_sir_zeliekAI : public ScriptedAI
         // Holy Wrath
         if (HolyWrath_Timer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature->getVictim(),SPELL_HOLY_WRATH);
+            DoCast(m_creature->getVictim(),m_bIsRegularMode ? SPELL_HOLY_WRATH : H_SPELL_HOLY_WRATH);
             HolyWrath_Timer = 12000;
         }else HolyWrath_Timer -= uiDiff;
 
diff --git a/scripts/northrend/naxxramas/boss_gluth.cpp b/scripts/northrend/naxxramas/boss_gluth.cpp
index 2e0016e..8f1ddee 100644
--- a/scripts/northrend/naxxramas/boss_gluth.cpp
+++ b/scripts/northrend/naxxramas/boss_gluth.cpp
@@ -34,7 +34,8 @@ enum
     SPELL_ENRAGE_H    = 54427,
     SPELL_BERSERK     = 26662,
 
-    NPC_ZOMBIE_CHOW   = 16360
+    NPC_ZOMBIE_CHOW   = 16360,
+    SPELL_INFECTED_WOUND = 29306
 };
 
 #define ADD_1X 3269.590f
@@ -73,6 +74,45 @@ enum
 #define ADD_9Y -3180.766f
 #define ADD_9Z 297.423f
 
+struct MANGOS_DLL_DECL mob_zombie_chowsAI : public ScriptedAI
+{
+    mob_zombie_chowsAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        Reset();
+    }
+
+    bool bIsForceMove;
+
+    void Reset()
+    {
+        bIsForceMove = false;
+    }
+    void JustDied(Unit* Killer) {}
+
+    void DoMeleeAttackIfReady()
+    {
+        //If we are within range melee the target
+        if (m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+        {
+            //Make sure our attack is ready and we aren't currently casting
+            if (m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+            {
+                DoCast(m_creature->getVictim(), SPELL_INFECTED_WOUND, true);
+                m_creature->AttackerStateUpdate(m_creature->getVictim());
+                m_creature->resetAttackTimer();
+            }
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim() || bIsForceMove)
+            return;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
 struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
 {
     boss_gluthAI(Creature* pCreature) : ScriptedAI(pCreature)
@@ -92,6 +132,9 @@ struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
 
     uint32 m_uiBerserkTimer;
 
+    uint32 RangeCheck_Timer;
+    std::list<uint64> m_lZombieGUIDList;
+
     void Reset()
     {
         m_uiMortalWoundTimer = 8000;
@@ -100,6 +143,9 @@ struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
         m_uiSummonTimer = 10000;
 
         m_uiBerserkTimer = MINUTE*8*IN_MILLISECONDS;
+
+        RangeCheck_Timer = 1000;
+        m_lZombieGUIDList.clear();
     }
 
     void JustDied(Unit* pKiller)
@@ -120,6 +166,11 @@ struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
             m_pInstance->SetData(TYPE_GLUTH, FAIL);
     }
 
+    void JustSummoned(Creature* summoned)
+    {
+        summoned->SetSpeedRate(MOVE_RUN, 0.8f);
+    }
+
     void UpdateAI(const uint32 uiDiff)
     {
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
@@ -134,39 +185,88 @@ struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
         else
             m_uiMortalWoundTimer -= uiDiff;
 
-        // Decimate
+         //Decimate_Timer
         if (m_uiDecimateTimer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature->getVictim(), SPELL_DECIMATE);
-            m_uiDecimateTimer = 100000;
-        }
-        else
-            m_uiDecimateTimer -= uiDiff;
+            DoCast(m_creature->getVictim(),SPELL_DECIMATE); // need core support
+
+            // workaround below
+            std::list<HostileReference*> t_list = m_creature->getThreatManager().getThreatList();
+            if (t_list.size())
+            {
+                //begin + 1 , so we don't target the one with the highest threat
+                std::list<HostileReference*>::iterator itr = t_list.begin();
+                std::advance(itr, 1);
+                for(; itr!= t_list.end(); ++itr)
+                {
+                    Unit *target = Unit::GetUnit(*m_creature, (*itr)->getUnitGuid());
+                    if (target && target->isAlive() && target->GetTypeId() == TYPEID_PLAYER &&
+                        (target->GetHealth() > target->GetMaxHealth() * 0.05))
+                        target->SetHealth(target->GetMaxHealth() * 0.05);
+                }
+            }
+            // Move Zombies
+            if (!m_lZombieGUIDList.empty())
+            {
+                for(std::list<uint64>::iterator itr = m_lZombieGUIDList.begin(); itr != m_lZombieGUIDList.end(); ++itr)
+                    if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+                        if (pTemp->isAlive())
+                        {
+                            ((mob_zombie_chowsAI*)pTemp->AI())->bIsForceMove = true;
+                            if (m_creature->GetHealth() > m_creature->GetMaxHealth() * 0.05) // remove when SPELL_DECIMATE is working
+                                pTemp->SetHealth(pTemp->GetMaxHealth() * 0.02);
+                            pTemp->AddThreat(m_creature, 1000000000.0f); // force move toward to Gluth
+                        }
+            }
+            m_uiDecimateTimer = (m_bIsRegularMode ? 100000 : 120000);
+        }else m_uiDecimateTimer -= uiDiff;
 
         // Enrage
         if (m_uiEnrageTimer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature, m_bIsRegularMode ? SPELL_ENRAGE : SPELL_ENRAGE_H);
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_ENRAGE : SPELL_ENRAGE_H);
             m_uiEnrageTimer = 60000;
         }
         else
             m_uiEnrageTimer -= uiDiff;
 
+        if (RangeCheck_Timer < uiDiff)
+        {
+            if (!m_lZombieGUIDList.empty())
+            {
+                for(std::list<uint64>::iterator itr = m_lZombieGUIDList.begin(); itr != m_lZombieGUIDList.end(); ++itr)
+                    if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+                        if (pTemp->isAlive() && m_creature->IsWithinDistInMap(pTemp, ATTACK_DISTANCE))
+                        {
+                            DoScriptText(EMOTE_ZOMBIE, m_creature);
+                            m_creature->SetHealth(m_creature->GetHealth() + m_creature->GetMaxHealth() * 0.05);
+                            pTemp->ForcedDespawn();
+                        }
+            }
+            RangeCheck_Timer = 1000;
+        }else RangeCheck_Timer -= uiDiff;
+
         // Summon
         if (m_uiSummonTimer < uiDiff)
         {
-            if (Creature* pZombie = m_creature->SummonCreature(NPC_ZOMBIE_CHOW, ADD_1X, ADD_1Y, ADD_1Z, 0.0f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 80000))
+            if (Creature* pZombie = m_creature->SummonCreature(NPC_ZOMBIE_CHOW, ADD_5X, ADD_5Y, ADD_5Z, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 80000))
             {
                 if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                {
+                    m_lZombieGUIDList.push_back(pZombie->GetGUID());
                     pZombie->AddThreat(pTarget);
+                }
             }
 
             if (!m_bIsRegularMode)
             {
-                if (Creature* pZombie = m_creature->SummonCreature(NPC_ZOMBIE_CHOW, ADD_1X, ADD_1Y, ADD_1Z, 0.0f, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 80000))
+                if (Creature* pZombie = m_creature->SummonCreature(NPC_ZOMBIE_CHOW, ADD_9X, ADD_9Y, ADD_9Z, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 80000))
                 {
                     if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                    {
                         pZombie->AddThreat(pTarget);
+                        m_lZombieGUIDList.push_back(pZombie->GetGUID());
+                    }
                 }
             }
 
@@ -178,7 +278,7 @@ struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
         // Berserk
         if (m_uiBerserkTimer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature, SPELL_BERSERK, CAST_TRIGGERED);
+            DoCast(m_creature, SPELL_BERSERK, true);
             m_uiBerserkTimer = MINUTE*5*IN_MILLISECONDS;
         }
         else
@@ -193,6 +293,11 @@ CreatureAI* GetAI_boss_gluth(Creature* pCreature)
     return new boss_gluthAI(pCreature);
 }
 
+CreatureAI* GetAI_mob_zombie_chows(Creature* pCreature)
+{
+    return new mob_zombie_chowsAI(pCreature);
+}
+
 void AddSC_boss_gluth()
 {
     Script* NewScript;
@@ -200,4 +305,9 @@ void AddSC_boss_gluth()
     NewScript->Name = "boss_gluth";
     NewScript->GetAI = &GetAI_boss_gluth;
     NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_zombie_chows";
+    NewScript->GetAI = &GetAI_mob_zombie_chows;
+    NewScript->RegisterSelf();
 }
diff --git a/scripts/northrend/naxxramas/boss_gothik.cpp b/scripts/northrend/naxxramas/boss_gothik.cpp
index 155043d..525b3c6 100644
--- a/scripts/northrend/naxxramas/boss_gothik.cpp
+++ b/scripts/northrend/naxxramas/boss_gothik.cpp
@@ -68,6 +68,10 @@ enum eSpellDummy
     SPELL_C_TO_SKULL        = 27937
 };
 
+const float PosPlatform[4] = {2640.5f, -3360.6f, 285.26f, 0};
+const float PosGroundLive[4] = {2692.174f, -3400.963f, 267.680f, 1.7f};
+const float PosGroundDeath[4] = {2690.378f, -3328.279f, 267.681f, 1.7f};
+
 struct MANGOS_DLL_DECL boss_gothikAI : public ScriptedAI
 {
     boss_gothikAI(Creature* pCreature) : ScriptedAI(pCreature)
@@ -157,6 +161,7 @@ struct MANGOS_DLL_DECL boss_gothikAI : public ScriptedAI
     {
         if (m_pInstance)
             m_pInstance->SetData(TYPE_GOTHIK, FAIL);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
     }
 
     void SummonAdds(bool bRightSide, uint32 uiSummonEntry)
@@ -210,11 +215,21 @@ struct MANGOS_DLL_DECL boss_gothikAI : public ScriptedAI
         }
     }
 
+    void JustSummoned(Creature* pSummoned)
+    {
+        if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+            pSummoned->AI()->AttackStart(pTarget);
+    }
+
     void UpdateAI(const uint32 uiDiff)
     {
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
             return;
 
+        // remove for debug!
+        if(!HasPlayersInLeftSide())
+            m_creature->AI()->EnterEvadeMode();
+
         switch(m_uiPhase)
         {
             case PHASE_SPEECH:
@@ -235,6 +250,8 @@ struct MANGOS_DLL_DECL boss_gothikAI : public ScriptedAI
                 else
                     m_uiSpeechTimer -= uiDiff;
 
+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
                 break;
             }
             case PHASE_BALCONY:
@@ -332,6 +349,8 @@ struct MANGOS_DLL_DECL boss_gothikAI : public ScriptedAI
                 else
                     m_uiShadowboltTimer -= uiDiff;
 
+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
                 DoMeleeAttackIfReady();                     // possibly no melee at all
                 break;
             }
diff --git a/scripts/northrend/naxxramas/boss_grobbulus.cpp b/scripts/northrend/naxxramas/boss_grobbulus.cpp
index 5270203..64a234b 100644
--- a/scripts/northrend/naxxramas/boss_grobbulus.cpp
+++ b/scripts/northrend/naxxramas/boss_grobbulus.cpp
@@ -29,3 +29,172 @@ Enrages 26527*/
 
 #include "precompiled.h"
 #include "naxxramas.h"
+
+#define SPELL_BOMBARD_SLIME         28280
+
+#define SPELL_POISON_CLOUD          28240
+#define SPELL_MUTATING_INJECTION    28169
+#define SPELL_SLIME_SPRAY           28157
+#define H_SPELL_SLIME_SPRAY         54364
+#define SPELL_BERSERK               26662
+
+#define MOB_FALLOUT_SLIME       16290
+#define MOB_GROBBOLUS_CLOUD     16363
+
+struct MANGOS_DLL_DECL boss_grobbulusAI : public ScriptedAI
+{
+    boss_grobbulusAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 PoisonCloud_Timer;
+    uint32 MutatingInjection_Timer;
+    uint32 SlimeSpary_Timer;
+    uint32 Enrage_Timer;
+    std::list<Creature*> lClouds;
+
+    void Reset()
+    {
+        PoisonCloud_Timer = 15000;
+        MutatingInjection_Timer = 20000;
+        SlimeSpary_Timer = 15000+rand()%15000;
+        Enrage_Timer = 720000;
+
+        DespawnAdds();
+        lClouds.clear();
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GROBBULUS, NOT_STARTED);
+    }
+
+    void JustDied(Unit* Killer)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GROBBULUS, DONE);
+        DespawnAdds();        
+    }
+
+    void Aggro(Unit *who)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GROBBULUS, IN_PROGRESS);
+    }
+
+    void DespawnAdds()
+    {
+        GetCreatureListWithEntryInGrid(lClouds, m_creature, MOB_GROBBOLUS_CLOUD, DEFAULT_VISIBILITY_INSTANCE);
+        if (!lClouds.empty())
+        {
+            for(std::list<Creature*>::iterator iter = lClouds.begin(); iter != lClouds.end(); ++iter)
+            {
+                if ((*iter) && (*iter)->isAlive())
+                    (*iter)->ForcedDespawn();
+            }
+        }
+    }
+
+    void SpellHitTarget(Unit *target, const SpellEntry *spell)
+    {
+        if(spell->Id == SPELL_SLIME_SPRAY || spell->Id == H_SPELL_SLIME_SPRAY)
+        {
+            if (Creature* pTemp = m_creature->SummonCreature(MOB_FALLOUT_SLIME, target->GetPositionX(), target->GetPositionY(), target->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 1000))
+                if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                {
+                    pTemp->AddThreat(pTarget,0.0f);
+                    pTemp->AI()->AttackStart(pTarget);
+                }
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (PoisonCloud_Timer < diff)
+        {
+            //DoCast(m_creature, SPELL_POISON_CLOUD);
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                    m_creature->SummonCreature(MOB_GROBBOLUS_CLOUD, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN, 75000);
+            PoisonCloud_Timer = 15000;
+        }else PoisonCloud_Timer -= diff;
+
+        if (MutatingInjection_Timer < diff)
+        {
+            if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                DoCast(target, SPELL_MUTATING_INJECTION);
+
+            MutatingInjection_Timer = 20000;
+        }else MutatingInjection_Timer -= diff;
+
+        if (SlimeSpary_Timer < diff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_SLIME_SPRAY : H_SPELL_SLIME_SPRAY);
+            SlimeSpary_Timer = 15000+rand()%15000;
+        }else SlimeSpary_Timer -= diff;
+
+        if (Enrage_Timer < diff)
+        {
+            DoCast(m_creature, SPELL_BERSERK);
+            Enrage_Timer = 300000;
+        }else Enrage_Timer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_grobbulus_poison_cloudAI : public Scripted_NoMovementAI
+{
+    npc_grobbulus_poison_cloudAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
+    {
+        Reset();
+    }
+
+    uint32 Cloud_Timer;
+
+    void Reset()
+    {
+        Cloud_Timer = 1000;
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (Cloud_Timer < diff)
+        {
+            DoCast(m_creature, 59116);
+            Cloud_Timer = 10000;
+        }else Cloud_Timer -= diff;
+    }
+};
+
+CreatureAI* GetAI_boss_grobbulus(Creature* pCreature)
+{
+    return new boss_grobbulusAI(pCreature);
+}
+
+CreatureAI* GetAI_npc_grobbulus_poison_cloud(Creature* pCreature)
+{
+    return new npc_grobbulus_poison_cloudAI(pCreature);
+}
+
+void AddSC_boss_grobbulus()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_grobbulus";
+    newscript->GetAI = &GetAI_boss_grobbulus;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "npc_grobbulus_poison_cloud";
+    newscript->GetAI = &GetAI_npc_grobbulus_poison_cloud;
+    newscript->RegisterSelf();
+}
+
diff --git a/scripts/northrend/naxxramas/boss_kelthuzad.cpp b/scripts/northrend/naxxramas/boss_kelthuzad.cpp
index b016b8b..8795a59 100644
--- a/scripts/northrend/naxxramas/boss_kelthuzad.cpp
+++ b/scripts/northrend/naxxramas/boss_kelthuzad.cpp
@@ -82,13 +82,25 @@ enum
 
     SPELL_MANA_DETONATION               = 27819,
     SPELL_SHADOW_FISSURE                = 27810,
-    SPELL_FROST_BLAST                   = 27808
+    SPELL_FROST_BLAST                   = 27808,
+
+    // abomination
+    SPELL_FRENZY                        = 28468,
+    SPELL_MORTAL_WOUND                  = 28467,
+
+    ACHIEV_JUST_CANT_GET_ENOUGH         = 2184,
+    ACHIEV_JUST_CANT_GET_ENOUGH_H       = 2185,
 };
 
 static float M_F_ANGLE = 0.2f;                              // to adjust for map rotation
 static float M_F_HEIGHT = 2.0f;                             // adjust for height difference
 static float M_F_RANGE = 55.0f;                             // ~ range from center of chamber to center of alcove
 
+#define HOME_X                      3748.0f
+#define HOME_Y                      -5113.0f
+
+uint8 m_uiAbominationsDead;
+
 struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
 {
     boss_kelthuzadAI(Creature* pCreature) : ScriptedAI(pCreature)
@@ -158,6 +170,8 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
 
         // it may be some spell should be used instead, to control the intro phase
         m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+        m_uiAbominationsDead = 0;
     }
 
     void KilledUnit(Unit* pVictim)
@@ -179,11 +193,18 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
                     continue;
 
                 pGuardian->AI()->EnterEvadeMode();
+                pGuardian->ForcedDespawn();
             }
         }
 
         if (m_pInstance)
             m_pInstance->SetData(TYPE_KELTHUZAD, DONE);
+
+        if(m_uiAbominationsDead >= 18)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_JUST_CANT_GET_ENOUGH : ACHIEV_JUST_CANT_GET_ENOUGH_H);
+        }
     }
 
     void MoveInLineOfSight(Unit* pWho)
@@ -221,7 +242,8 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
             for(std::set<uint64>::iterator itr = m_lSoldierSet.begin(); itr != m_lSoldierSet.end(); ++itr)
             {
                 if (Creature* pSoldier = m_pInstance->instance->GetCreature(*itr))
-                    pSoldier->ForcedDespawn();
+                    if(!pSoldier->getVictim())
+                        pSoldier->ForcedDespawn();
             }
         }
 
@@ -230,7 +252,8 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
             for(std::set<uint64>::iterator itr = m_lUndeadSet.begin(); itr != m_lUndeadSet.end(); ++itr)
             {
                 if (Creature* pSoldier = m_pInstance->instance->GetCreature(*itr))
-                    pSoldier->ForcedDespawn();
+                    if(!pSoldier->getVictim())
+                        pSoldier->ForcedDespawn();
             }
         }
 
@@ -422,6 +445,9 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
 
     void UpdateAI(const uint32 uiDiff)
     {
+        if (m_creature->GetDistance2d(HOME_X, HOME_Y) > 80)
+            EnterEvadeMode();
+
         if (m_creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
         {
             if (!m_pInstance)
@@ -443,6 +469,7 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
                 float fx, fy, fz;
                 m_pInstance->GetChamberCenterCoords(fx, fy, fz);
                 m_creature->GetMotionMaster()->MovePoint(0, fx, fy, fz);
+                DespawnAllIntroCreatures();
 
                 DoScriptText(EMOTE_PHASE2, m_creature);
                 return;
@@ -566,6 +593,61 @@ struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
     }
 };
 
+struct MANGOS_DLL_DECL mob_unstoppable_abominationAI : public ScriptedAI
+{
+    mob_unstoppable_abominationAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    uint32 m_uiMortalWoundTimer;
+    uint32 m_uiFrenzyTimer;
+    bool m_bHasFrenzy;
+
+    void Reset()
+    {
+        m_uiMortalWoundTimer = 5000;
+        m_uiFrenzyTimer = 15000;
+        m_bHasFrenzy = false;
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        ++m_uiAbominationsDead;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiMortalWoundTimer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_MORTAL_WOUND);
+            m_uiMortalWoundTimer = urand(5000, 7000);
+        }
+        else m_uiMortalWoundTimer -= uiDiff;
+
+        if (m_uiFrenzyTimer < uiDiff && !m_bHasFrenzy)
+        {
+            DoCast(m_creature, SPELL_FRENZY);
+            m_bHasFrenzy = true;
+            m_uiFrenzyTimer = 0;
+        }
+        else m_uiFrenzyTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_unstoppable_abomination(Creature* pCreature)
+{
+    return new mob_unstoppable_abominationAI(pCreature);
+}
+
 CreatureAI* GetAI_boss_kelthuzad(Creature* pCreature)
 {
     return new boss_kelthuzadAI(pCreature);
@@ -579,4 +661,9 @@ void AddSC_boss_kelthuzad()
     NewScript->Name = "boss_kelthuzad";
     NewScript->GetAI = &GetAI_boss_kelthuzad;
     NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_unstoppable_abomination";
+    NewScript->GetAI = &GetAI_mob_unstoppable_abomination;
+    NewScript->RegisterSelf();
 }
diff --git a/scripts/northrend/naxxramas/boss_loatheb.cpp b/scripts/northrend/naxxramas/boss_loatheb.cpp
index 853941b..707b5c7 100644
--- a/scripts/northrend/naxxramas/boss_loatheb.cpp
+++ b/scripts/northrend/naxxramas/boss_loatheb.cpp
@@ -38,9 +38,15 @@ enum
     SPELL_SUMMON_SPORE      = 29234,
     SPELL_BERSERK           = 26662,
 
-    NPC_SPORE               = 16286
+    SPELL_FUNGAL_CREEP      = 29232,
+    NPC_SPORE               = 16286,
+
+    ACHIEV_SPORE_LOSER      = 2182,
+    ACHIEV_SPORE_LOSER_H    = 2183,
 };
 
+bool m_bHasSporeDied;
+
 struct MANGOS_DLL_DECL boss_loathebAI : public ScriptedAI
 {
     boss_loathebAI(Creature* pCreature) : ScriptedAI(pCreature)
@@ -68,6 +74,7 @@ struct MANGOS_DLL_DECL boss_loathebAI : public ScriptedAI
         m_uiSummonTimer = urand(10000, 15000);              // first seen in vid after approx 12s
         m_uiBerserkTimer = MINUTE*12*IN_MILLISECONDS;       // only in heroic, after 12min
         m_uiNecroticAuraCount = 0;
+        m_bHasSporeDied = false;
     }
 
     void Aggro(Unit* pWho)
@@ -80,6 +87,12 @@ struct MANGOS_DLL_DECL boss_loathebAI : public ScriptedAI
     {
         if (m_pInstance)
             m_pInstance->SetData(TYPE_LOATHEB, DONE);
+
+        if (!m_bHasSporeDied)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_SPORE_LOSER : ACHIEV_SPORE_LOSER_H);
+        }
     }
 
     void JustReachedHome()
@@ -172,11 +185,67 @@ struct MANGOS_DLL_DECL boss_loathebAI : public ScriptedAI
     }
 };
 
+struct MANGOS_DLL_DECL npc_loatheb_sporesAI : public ScriptedAI
+{
+    npc_loatheb_sporesAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        Reset();
+    }
+
+    uint32 DieDelay_Timer;
+
+    void Reset()
+    {
+        DieDelay_Timer = 0;
+    }
+
+    void DamageTaken(Unit* done_by, uint32 &damage)
+    {
+        if (damage > m_creature->GetHealth() && !DieDelay_Timer)
+        {
+            m_creature->CastSpell(m_creature, SPELL_FUNGAL_CREEP, true);
+            m_creature->SetHealth(m_creature->GetMaxHealth());
+            DieDelay_Timer = 500;
+        }
+        if (DieDelay_Timer)
+        {
+            damage = 0;
+            return;
+        }
+    }
+
+    void JustDied(Unit* Killer) 
+    {
+        if(Killer != GetClosestCreatureWithEntry(m_creature, NPC_LOATHEB, 80.0f))
+            m_bHasSporeDied = true;
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (DieDelay_Timer)
+            if (DieDelay_Timer < diff)
+            {
+                m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                DieDelay_Timer = 0;
+            }else DieDelay_Timer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
 CreatureAI* GetAI_boss_loatheb(Creature* pCreature)
 {
     return new boss_loathebAI(pCreature);
 }
 
+CreatureAI* GetAI_npc_loatheb_spores(Creature* pCreature)
+{
+    return new npc_loatheb_sporesAI(pCreature);
+}
+
 void AddSC_boss_loatheb()
 {
     Script* NewScript;
@@ -184,4 +253,9 @@ void AddSC_boss_loatheb()
     NewScript->Name = "boss_loatheb";
     NewScript->GetAI = &GetAI_boss_loatheb;
     NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "npc_loatheb_spores";
+    NewScript->GetAI = &GetAI_npc_loatheb_spores;
+    NewScript->RegisterSelf();
 }
diff --git a/scripts/northrend/naxxramas/boss_maexxna.cpp b/scripts/northrend/naxxramas/boss_maexxna.cpp
index eb9a525..3416213 100644
--- a/scripts/northrend/naxxramas/boss_maexxna.cpp
+++ b/scripts/northrend/naxxramas/boss_maexxna.cpp
@@ -39,6 +39,7 @@ enum
 
     //spellId invalid
     SPELL_SUMMON_SPIDERLING = 29434,
+    NPC_SPIDERLING          = 17055
 };
 
 #define LOC_X1    3546.796f
@@ -189,6 +190,24 @@ struct MANGOS_DLL_DECL boss_maexxnaAI : public ScriptedAI
         }
     }
 
+    void SummonSpiderling()
+    {
+        uint8 number = 9;
+        float x,y,z;
+        for(uint8 i = 0; number >= i; i++)
+        {
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+            {
+                m_creature->GetRandomPoint(m_creature->GetPositionX(),m_creature->GetPositionY(),m_creature->GetPositionZ(),7.0f,x,y,z);
+                if(Creature* spiderling = m_creature->SummonCreature(NPC_SPIDERLING, x, y, z,0, TEMPSUMMON_DEAD_DESPAWN, 0))
+                {
+                    spiderling->AddThreat(pTarget, 0.0f);
+                    spiderling->AI()->AttackStart(pTarget);
+                }
+            }
+        }
+    }
+
     void UpdateAI(const uint32 uiDiff)
     {
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
@@ -233,7 +252,8 @@ struct MANGOS_DLL_DECL boss_maexxnaAI : public ScriptedAI
         // Summon Spiderling
         if (m_uiSummonSpiderlingTimer < uiDiff)
         {
-            DoCastSpellIfCan(m_creature, SPELL_SUMMON_SPIDERLING);
+            //DoCastSpellIfCan(m_creature, SPELL_SUMMON_SPIDERLING);
+            SummonSpiderling();
             m_uiSummonSpiderlingTimer = 40000;
         }
         else
diff --git a/scripts/northrend/naxxramas/boss_noth.cpp b/scripts/northrend/naxxramas/boss_noth.cpp
index a1e8349..41ae5d4 100644
--- a/scripts/northrend/naxxramas/boss_noth.cpp
+++ b/scripts/northrend/naxxramas/boss_noth.cpp
@@ -111,6 +111,9 @@ struct MANGOS_DLL_DECL boss_nothAI : public ScriptedAI
         m_uiBlinkTimer = 25000;
         m_uiCurseTimer = 4000;
         m_uiSummonTimer = 30000;
+
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
     }
 
     void Aggro(Unit* pWho)
@@ -173,6 +176,8 @@ struct MANGOS_DLL_DECL boss_nothAI : public ScriptedAI
                 {
                     DoScriptText(EMOTE_TELEPORT, m_creature);
                     m_creature->GetMotionMaster()->MoveIdle();
+                    m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
                     m_uiPhaseTimer = 70000;
                     m_uiPhase = PHASE_BALCONY;
                     ++m_uiPhaseSub;
@@ -243,6 +248,8 @@ struct MANGOS_DLL_DECL boss_nothAI : public ScriptedAI
                 if (DoCastSpellIfCan(m_creature, SPELL_TELEPORT_RETURN) == CAST_OK)
                 {
                     DoScriptText(EMOTE_TELEPORT_RETURN, m_creature);
+                    m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                    m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
                     m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
                     m_uiPhaseTimer = 90000;
                     m_uiPhase = PHASE_GROUND;
diff --git a/scripts/northrend/naxxramas/boss_patchwerk.cpp b/scripts/northrend/naxxramas/boss_patchwerk.cpp
index 3e7a23e..95e0b98 100644
--- a/scripts/northrend/naxxramas/boss_patchwerk.cpp
+++ b/scripts/northrend/naxxramas/boss_patchwerk.cpp
@@ -38,7 +38,10 @@ enum
     SPELL_HATEFULSTRIKE_H = 59192,
     SPELL_ENRAGE          = 28131,
     SPELL_BERSERK         = 26662,
-    SPELL_SLIMEBOLT       = 32309
+    SPELL_SLIMEBOLT       = 32309,
+
+    ACHIEV_QUICK_WERK       = 1856,
+    ACHIEV_QUICK_WERK_H     = 1857,
 };
 
 struct MANGOS_DLL_DECL boss_patchwerkAI : public ScriptedAI
@@ -59,6 +62,8 @@ struct MANGOS_DLL_DECL boss_patchwerkAI : public ScriptedAI
     bool   m_bEnraged;
     bool   m_bBerserk;
 
+    uint32 uiEncounterTimer;
+
     void Reset()
     {
         m_uiHatefulStrikeTimer = 1000;                      //1 second
@@ -66,6 +71,7 @@ struct MANGOS_DLL_DECL boss_patchwerkAI : public ScriptedAI
         m_uiSlimeboltTimer = 10000;
         m_bEnraged = false;
         m_bBerserk = false;
+        uiEncounterTimer = 0;
     }
 
     void KilledUnit(Unit* pVictim)
@@ -82,6 +88,12 @@ struct MANGOS_DLL_DECL boss_patchwerkAI : public ScriptedAI
 
         if (m_pInstance)
             m_pInstance->SetData(TYPE_PATCHWERK, DONE);
+
+        if (uiEncounterTimer < 180000)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_QUICK_WERK : ACHIEV_QUICK_WERK_H);
+        }
     }
 
     void Aggro(Unit* pWho)
@@ -132,6 +144,8 @@ struct MANGOS_DLL_DECL boss_patchwerkAI : public ScriptedAI
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
             return;
 
+        uiEncounterTimer += uiDiff;
+
         // Hateful Strike
         if (m_uiHatefulStrikeTimer < uiDiff)
         {
diff --git a/scripts/northrend/naxxramas/boss_razuvious.cpp b/scripts/northrend/naxxramas/boss_razuvious.cpp
index fe732ce..142725a 100644
--- a/scripts/northrend/naxxramas/boss_razuvious.cpp
+++ b/scripts/northrend/naxxramas/boss_razuvious.cpp
@@ -41,9 +41,33 @@ enum
     SPELL_DISRUPTING_SHOUT   = 55543,
     SPELL_DISRUPTING_SHOUT_H = 29107,
     SPELL_JAGGED_KNIFE       = 55550,
-    SPELL_HOPELESS           = 29125
+    SPELL_HOPELESS           = 29125,
+
+    SPELL_FORCE_OBEDIENCE   = 55479,
+    NPC_DEATH_KNIGHT_UNDERSTUDY = 16803
 };
 
+bool GossipHello_npc_obedience_crystal(Player* pPlayer, Creature* pCreature)
+{
+    ScriptedInstance *pInstance = (ScriptedInstance *) pCreature->GetInstanceData();
+    if(pInstance->GetData(TYPE_RAZUVIOUS) != DONE)
+        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "To use Mind Control click here !", GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;
+}
+
+bool GossipSelect_npc_obedience_crystal(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    if (uiAction == GOSSIP_ACTION_INFO_DEF+1)
+    {
+        if (Unit* target = GetClosestCreatureWithEntry(pCreature, NPC_DEATH_KNIGHT_UNDERSTUDY, 100.0f))
+            pPlayer->CastSpell(target, SPELL_FORCE_OBEDIENCE, true);
+        pPlayer->CLOSE_GOSSIP_MENU();
+        pPlayer->TalkedToCreature(pCreature->GetEntry(), pCreature->GetGUID());
+    }
+    return true;
+}
+
 struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
 {
     boss_razuviousAI(Creature* pCreature) : ScriptedAI(pCreature)
@@ -60,6 +84,9 @@ struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
     uint32 m_uiDisruptingShoutTimer;
     uint32 m_uiJaggedKnifeTimer;
     uint32 m_uiCommandSoundTimer;
+    uint32 m_uiAggroCheckTimer;
+
+    std::list<Creature*> lUnderstudies;
 
     void Reset()
     {
@@ -67,6 +94,17 @@ struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
         m_uiDisruptingShoutTimer   = 15000;                 // 15 seconds
         m_uiJaggedKnifeTimer       = urand(10000, 15000);
         m_uiCommandSoundTimer      = 40000;                 // 40 seconds
+        m_uiAggroCheckTimer         = 1000;
+
+        GetCreatureListWithEntryInGrid(lUnderstudies, m_creature, NPC_DEATH_KNIGHT_UNDERSTUDY, DEFAULT_VISIBILITY_INSTANCE);
+        if (!lUnderstudies.empty())
+        {
+            for(std::list<Creature*>::iterator iter = lUnderstudies.begin(); iter != lUnderstudies.end(); ++iter)
+            {
+                if ((*iter) && !(*iter)->isAlive())
+                    (*iter)->Respawn();
+            }
+        }
     }
 
     void KilledUnit(Unit* Victim)
@@ -87,6 +125,16 @@ struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
 
         if (m_pInstance)
             m_pInstance->SetData(TYPE_RAZUVIOUS, DONE);
+
+        GetCreatureListWithEntryInGrid(lUnderstudies, m_creature, NPC_DEATH_KNIGHT_UNDERSTUDY, DEFAULT_VISIBILITY_INSTANCE);
+        if (!lUnderstudies.empty())
+        {
+            for(std::list<Creature*>::iterator iter = lUnderstudies.begin(); iter != lUnderstudies.end(); ++iter)
+            {
+                if ((*iter) && (*iter)->isAlive())
+                    (*iter)->ForcedDespawn();
+            }
+        }
     }
 
     void Aggro(Unit* pWho)
@@ -100,6 +148,16 @@ struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
 
         if (m_pInstance)
             m_pInstance->SetData(TYPE_RAZUVIOUS, IN_PROGRESS);
+
+        GetCreatureListWithEntryInGrid(lUnderstudies, m_creature, NPC_DEATH_KNIGHT_UNDERSTUDY, DEFAULT_VISIBILITY_INSTANCE);
+        if (!lUnderstudies.empty())
+        {
+            for(std::list<Creature*>::iterator iter = lUnderstudies.begin(); iter != lUnderstudies.end(); ++iter)
+            {
+                if ((*iter) && (*iter)->isAlive())
+                    (*iter)->AI()->AttackStart(m_creature->getVictim());
+            }
+        }
     }
 
     void JustReachedHome()
@@ -110,6 +168,22 @@ struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
 
     void UpdateAI(const uint32 uiDiff)
     {
+        if (m_uiAggroCheckTimer < uiDiff && m_pInstance->GetData(TYPE_RAZUVIOUS) != IN_PROGRESS)
+        {
+            GetCreatureListWithEntryInGrid(lUnderstudies, m_creature, NPC_DEATH_KNIGHT_UNDERSTUDY, DEFAULT_VISIBILITY_INSTANCE);
+            if (!lUnderstudies.empty())
+            {
+                for(std::list<Creature*>::iterator iter = lUnderstudies.begin(); iter != lUnderstudies.end(); ++iter)
+                {
+                    if ((*iter) && (*iter)->isAlive() && (*iter)->getVictim())
+                        m_creature->AI()->AttackStart((*iter)->getVictim());
+                }
+            }
+            m_uiAggroCheckTimer = 1000;
+        }
+        else
+            m_uiAggroCheckTimer -= uiDiff;
+
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
             return;
 
@@ -172,4 +246,10 @@ void AddSC_boss_razuvious()
     NewScript->Name = "boss_razuvious";
     NewScript->GetAI = &GetAI_boss_razuvious;
     NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "npc_obedience_crystal";
+    NewScript->pGossipHello =  &GossipHello_npc_obedience_crystal;
+    NewScript->pGossipSelect = &GossipSelect_npc_obedience_crystal;
+    NewScript->RegisterSelf();
 }
diff --git a/scripts/northrend/naxxramas/boss_sapphiron.cpp b/scripts/northrend/naxxramas/boss_sapphiron.cpp
index 3ceb9af..57ea12c 100644
--- a/scripts/northrend/naxxramas/boss_sapphiron.cpp
+++ b/scripts/northrend/naxxramas/boss_sapphiron.cpp
@@ -29,12 +29,24 @@ enum
     EMOTE_BREATH       = -1533082,
     EMOTE_ENRAGE       = -1533083,
 
-    SPELL_ICEBOLT      = 28522,
-    SPELL_FROST_BREATH = 29318,
-    SPELL_FROST_AURA   = 28531,
-    SPELL_LIFE_DRAIN   = 28542,
-    SPELL_BLIZZARD     = 28547,
-    SPELL_BESERK       = 26662
+    SPELL_ICEBOLT           = 28522,
+    SPELL_FROST_BREATH      = 29318,
+    SPELL_FROST_BREATH_H    = 28524,
+    SPELL_FROST_AURA        = 28531,
+    SPELL_LIFE_DRAIN        = 28542,
+    SPELL_LIFE_DRAIN_H      = 55665,
+    SPELL_BLIZZARD          = 28547,
+    SPELL_BESERK            = 26662,
+    SPELL_CLEAVE           = 19983,
+    SPELL_TAIL_LASH        = 55697,
+    SPELL_TAIL_LASH_H      = 55696,
+
+    SAPPHIRON_X            = 3522,
+    SAPPHIRON_Y            = -5236,
+    SAPPHIRON_Z            = 137, 
+
+    ACHIEV_THE_HUNDRED_CLUB     = 2146,
+    ACHIEV_THE_HUNDRED_CLUB_H   = 2147,
 };
 
 struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
@@ -57,10 +69,19 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
     uint32 Blizzard_Timer;
     uint32 Fly_Timer;
     uint32 Beserk_Timer;
+    uint32 m_uiCleaveTimer;
+    uint32 m_uiTailSweepTimer;
     uint32 phase;
     bool landoff;
     uint32 land_Timer;
 
+    bool isAtGround;
+    std::vector<Unit*> targets;
+    uint32 land_time;
+
+    bool m_bHasResistance;
+    uint32 m_uiResistanceCheckTimer;
+
     void Reset()
     {
         FrostAura_Timer = 2000;
@@ -70,24 +91,42 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
         Fly_Timer = 45000;
         Icebolt_Timer = 4000;
         land_Timer = 2000;
-        Beserk_Timer = 0;
+        Beserk_Timer = 900000;
+        m_uiCleaveTimer = 7000;
+        m_uiTailSweepTimer = 20000;
         phase = 1;
         Icebolt_Count = 0;
         landoff = false;
+        isAtGround = true;
+        targets.clear();
+        land_time = 0;
+
+        m_bHasResistance = false;
+        m_uiResistanceCheckTimer = 1000;
 
         //m_creature->ApplySpellMod(SPELL_FROST_AURA, SPELLMOD_DURATION, -1);
+
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 0);
+        m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
     }
 
     void Aggro(Unit* pWho)
     {
         if (m_pInstance)
             m_pInstance->SetData(TYPE_SAPPHIRON, IN_PROGRESS);
+        CheckResistance();
     }
 
     void JustDied(Unit* pKiller)
     {
         if (m_pInstance)
             m_pInstance->SetData(TYPE_SAPPHIRON, DONE);
+
+        if (!m_bHasResistance)
+        {
+            if(m_pInstance)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_THE_HUNDRED_CLUB : ACHIEV_THE_HUNDRED_CLUB_H);
+        }
     }
 
     void JustReachedHome()
@@ -96,11 +135,56 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
             m_pInstance->SetData(TYPE_SAPPHIRON, FAIL);
     }
 
+    void CheckResistance()
+    {
+        Map* pMap = m_creature->GetMap();
+        if (!m_bHasResistance && pMap && pMap->IsDungeon())
+        {
+            Map::PlayerList const &players = pMap->GetPlayers();
+            for (Map::PlayerList::const_iterator itr = players.begin(); itr != players.end(); ++itr)
+                if(itr->getSource()->GetResistance(SPELL_SCHOOL_FROST) > 100)
+                    m_bHasResistance = true;
+        }
+    }
+
+    void SpellHitTarget(Unit *target, const SpellEntry *spell)
+    {
+        if(spell->Id == SPELL_ICEBOLT)
+        {
+            if (target->isAlive() && target->HasAura(SPELL_ICEBOLT))
+            {
+                target->CastSpell(target, 62766, true);
+                target->ApplySpellImmune(0, IMMUNITY_SCHOOL, SPELL_SCHOOL_MASK_FROST, true);
+            }
+            return;
+        }
+
+        if(spell->Id == SPELL_FROST_BREATH || spell->Id == SPELL_FROST_BREATH_H)
+        {
+            if (target->GetTypeId() != TYPEID_PLAYER)
+                return;
+
+            if (target->HasAura(SPELL_ICEBOLT))
+            {
+                target->RemoveAurasDueToSpell(62766);
+                target->RemoveAurasDueToSpell(SPELL_ICEBOLT);
+                target->ApplySpellImmune(0, IMMUNITY_SCHOOL, SPELL_SCHOOL_MASK_FROST, false);
+                return;
+            }
+        }
+    }
+
     void UpdateAI(const uint32 uiDiff)
     {
         if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
             return;
 
+         if (m_uiResistanceCheckTimer < uiDiff && !m_bHasResistance)
+        {
+            CheckResistance();
+            m_uiResistanceCheckTimer = 1000;
+        }else m_uiResistanceCheckTimer -= uiDiff;
+
         if (phase == 1)
         {
             if (FrostAura_Timer < uiDiff)
@@ -111,35 +195,55 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
 
             if (LifeDrain_Timer < uiDiff)
             {
-                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM,0))
-                    DoCastSpellIfCan(target,SPELL_LIFE_DRAIN);
+                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                    DoCastSpellIfCan(target,m_bIsRegularMode ? SPELL_LIFE_DRAIN : SPELL_LIFE_DRAIN_H);
 
                 LifeDrain_Timer = 24000;
             }else LifeDrain_Timer -= uiDiff;
 
             if (Blizzard_Timer < uiDiff)
             {
-                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM,0))
+                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
                     DoCastSpellIfCan(target,SPELL_BLIZZARD);
 
                 Blizzard_Timer = 20000;
             }else Blizzard_Timer -= uiDiff;
 
+            // Cleave
+            if (m_uiCleaveTimer < uiDiff)
+            {
+                DoCast(m_creature->getVictim(), SPELL_CLEAVE);
+                m_uiCleaveTimer = 7000 + rand()%3000;
+            }
+            else
+                m_uiCleaveTimer -= uiDiff;
+
+            // Tail Sweep
+            if (m_uiTailSweepTimer < uiDiff)
+            {
+                DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_TAIL_LASH : SPELL_TAIL_LASH_H);
+                m_uiTailSweepTimer = 15000 + rand()%5000;
+            }
+            else
+                m_uiTailSweepTimer -= uiDiff;
+
             if (m_creature->GetHealthPercent() > 10.0f)
             {
                 if (Fly_Timer < uiDiff)
                 {
                     phase = 2;
                     m_creature->InterruptNonMeleeSpells(false);
+                    m_creature->StopMoving();
                     m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
                     m_creature->GetMotionMaster()->Clear(false);
                     m_creature->GetMotionMaster()->MoveIdle();
-                    DoCastSpellIfCan(m_creature,11010);
-                    m_creature->SetHover(true);
-                    DoCastSpellIfCan(m_creature,18430);
+                    m_creature->GetMap()->CreatureRelocation(m_creature, SAPPHIRON_X, SAPPHIRON_Y, SAPPHIRON_Z + 20, m_creature->GetOrientation()); 
+                    m_creature->SendMonsterMove(SAPPHIRON_X, SAPPHIRON_Y, SAPPHIRON_Z + 20, SPLINETYPE_NORMAL, m_creature->GetSplineFlags(), 1);
                     Icebolt_Timer = 4000;
                     Icebolt_Count = 0;
                     landoff = false;
+                    m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 50331648);
+                    m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 50331648);
                 }else Fly_Timer -= uiDiff;
             }
         }
@@ -148,7 +252,7 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
         {
             if (Icebolt_Timer < uiDiff && Icebolt_Count < 5)
             {
-                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM,0))
+                if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
                     DoCastSpellIfCan(target,SPELL_ICEBOLT);
 
                 ++Icebolt_Count;
@@ -176,11 +280,22 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
                     m_creature->SetHover(false);
                     m_creature->GetMotionMaster()->Clear(false);
                     m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+                    m_creature->SetUInt32Value(UNIT_FIELD_BYTES_0, 0);
+                    m_creature->SetUInt32Value(UNIT_FIELD_BYTES_1, 0);
                     Fly_Timer = 67000;
                 }else land_Timer -= uiDiff;
             }
         }
 
+        if(phase == 1 && isAtGround == false)
+        {
+            if(land_time < uiDiff)
+            {
+                isAtGround = true;
+                DoStartMovement(m_creature->getVictim());
+            }else land_time -=uiDiff;
+        }
+
         if (m_creature->GetHealthPercent() <= 10.0f)
         {
             if (Beserk_Timer < uiDiff)
@@ -191,7 +306,7 @@ struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
             }else Beserk_Timer -= uiDiff;
         }
 
-        if (phase!=2)
+        if (phase!=2 && isAtGround == true)
             DoMeleeAttackIfReady();
     }
 };
diff --git a/scripts/northrend/naxxramas/boss_thaddius.cpp b/scripts/northrend/naxxramas/boss_thaddius.cpp
index 3c31172..9d71285 100644
--- a/scripts/northrend/naxxramas/boss_thaddius.cpp
+++ b/scripts/northrend/naxxramas/boss_thaddius.cpp
@@ -31,13 +31,17 @@ enum
     SAY_STAL_SLAY                 = -1533024,
     SAY_STAL_DEATH                = -1533025,
 
-    SPELL_POWERSURGE              = 28134,
+    SPELL_POWERSURGE                = 28134,
+    SPELL_POWERSURGE_H              = 54529,
 
     //Feugen
     SAY_FEUG_AGGRO                = -1533026,
     SAY_FEUG_SLAY                 = -1533027,
     SAY_FEUG_DEATH                = -1533028,
 
+    SPELL_STATIC_FIELD              = 28135,
+    SPELL_STATIC_FIELD_H            = 54528,
+
     SPELL_MANABURN                = 28135,
 
     //both
@@ -55,20 +59,880 @@ enum
     SAY_SCREAM2                   = -1533037,
     SAY_SCREAM3                   = -1533038,
     SAY_SCREAM4                   = -1533039,
+    EMOTE_POLARITY_SHIFT            = -1533149,
+ 
+    SPELL_THADIUS_STUN              = 28160,
+    SPELL_THADIUS_LIGHTNING_VISUAL  = 28136,
+    SPELL_BALL_LIGHTNING            = 28299,
+    SPELL_CHAIN_LIGHTNING           = 28167,
+    SPELL_CHAIN_LIGHTNING_H         = 54531,
+    SPELL_POLARITY_SHIFT            = 28089,
+    SPELL_BESERK                    = 27680,
+ 
+    // Tesla Coils
+    EMOTE_LOSING_LINK               = -1533147,
+    EMOTE_TESLA_OVERLOAD            = -1533148,
+ 
+    SPELL_FEUGEN_CHAIN              = 28111,
+    SPELL_STALAGG_CHAIN             = 28096,
+    SPELL_SHOCK_OVERLOAD            = 28159,
+    SPELL_SHOCK                     = 28099,
+    SPELL_BREAK_CHANNEL             = 28087,
+
+    SPELL_POSITIVE_CHARGE           = 28059,
+    SPELL_NEGATIVE_CHARGE           = 28084,
+
+    ACHIEV_SUBSTRACTION             = 2180,
+    ACHIEV_SUBSTRACTION_H           = 2181,
+
+    ACHIEV_SHOCKING                 = 2178,     // needs advanced script support
+    ACHIEV_SHOCKING_H               = 2179,
+ 
+    PHASE_TESLA_DO_NOTHING          = 0,
+    PHASE_TESLA_SETUP_CHAINS        = 1,
+    PHASE_TESLA_SHOCK_OR_REAPPLY    = 2,
+    PHASE_TESLA_OVERLOAD            = 3
+};
+ 
+static const float MAX_CHAIN_RANGE = 60.0;
+
+/************
+** npc_tesla_coil
+************/
+struct MANGOS_DLL_DECL npc_tesla_coilAI : public ScriptedAI
+{
+    npc_tesla_coilAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (instance_naxxramas*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    instance_naxxramas* m_pInstance;
+    bool m_bToFeugen;
+
+    uint32 m_uiPhaseTimer;
+    uint8 m_uiPhase;
+    uint64 m_uiThadAddGUID;
+    uint64 m_uiNoxTeslaGUID;
+
+    void Reset()
+    {
+        m_uiPhase = PHASE_TESLA_SETUP_CHAINS;
+        m_uiPhaseTimer = 1*IN_MILLISECONDS;;
+        m_uiThadAddGUID = 0;
+        m_uiNoxTeslaGUID = 0;
+    }
+
+    bool SetupChain()
+    {
+        if (!m_pInstance)
+            return false;
+        if (m_pInstance->GetData(TYPE_THADDIUS) == DONE)
+            return true; // Do nothing more, if encounter finished
+
+        GameObject* pNoxTeslaFeugen  = m_pInstance->instance->GetGameObject(m_pInstance->GetData64(GO_CONS_NOX_TESLA_FEUGEN));
+        GameObject* pNoxTeslaStalagg = m_pInstance->instance->GetGameObject(m_pInstance->GetData64(GO_CONS_NOX_TESLA_STALAGG));
+
+        if (!pNoxTeslaFeugen || !pNoxTeslaStalagg)
+            return false;
+        if (m_creature->GetDistanceOrder(pNoxTeslaFeugen, pNoxTeslaStalagg))
+        {
+            m_uiNoxTeslaGUID = pNoxTeslaFeugen->GetGUID();
+            m_uiThadAddGUID = m_pInstance->GetData64(NPC_FEUGEN);
+            m_bToFeugen = true;
+        }
+        else
+        {
+            m_uiNoxTeslaGUID = pNoxTeslaStalagg->GetGUID();
+            m_uiThadAddGUID = m_pInstance->GetData64(NPC_STALAGG);
+            m_bToFeugen = false;
+        }
+
+        if (Creature* pTarget = m_pInstance->instance->GetCreature(m_uiThadAddGUID))
+        {
+            m_pInstance->DoUseDoorOrButton(m_uiNoxTeslaGUID);
+            if (DoCastSpellIfCan(pTarget, m_bToFeugen ? SPELL_FEUGEN_CHAIN : SPELL_STALAGG_CHAIN) == CAST_OK)
+                return true;
+        }
+        return false;
+    }
+
+    void ReApplyChain()
+    {
+        Creature* pTarget = m_pInstance->instance->GetCreature(m_uiThadAddGUID);
+        GameObject* pGo = m_pInstance->instance->GetGameObject(m_uiNoxTeslaGUID);
+
+        if (pGo && pGo->GetGoType() == GAMEOBJECT_TYPE_BUTTON && pGo->getLootState() == GO_READY)
+            pGo->UseDoorOrButton(0, false);
+        if (pTarget)
+            (DoCastSpellIfCan(pTarget, m_bToFeugen ? SPELL_FEUGEN_CHAIN : SPELL_STALAGG_CHAIN, CAST_INTERRUPT_PREVIOUS));
+    }
+
+    void LinkLost()
+    {
+        DoScriptText(EMOTE_LOSING_LINK, m_creature);
+        m_uiPhaseTimer = 2*IN_MILLISECONDS;
+        m_uiPhase = PHASE_TESLA_SHOCK_OR_REAPPLY;
+    }
+
+    void SetOverloading()
+    {
+        m_uiPhaseTimer = 14*IN_MILLISECONDS;
+        m_uiPhase = PHASE_TESLA_OVERLOAD;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_pInstance)
+            return;
+        
+        switch (m_uiPhase)
+        {
+            case PHASE_TESLA_SETUP_CHAINS:
+                if (m_uiPhaseTimer < uiDiff)
+                    if (SetupChain())
+                        m_uiPhase = PHASE_TESLA_DO_NOTHING;
+                    else
+                        m_uiPhaseTimer = 5*IN_MILLISECONDS;
+                else
+                    m_uiPhaseTimer -= uiDiff;
+                break;
+            case PHASE_TESLA_SHOCK_OR_REAPPLY:
+                if (m_uiPhaseTimer < uiDiff)
+                {
+                    if (Creature* pTarget = m_pInstance->instance->GetCreature(m_uiThadAddGUID))
+                        if (m_creature->GetDistance(pTarget)  > MAX_CHAIN_RANGE)
+                        {
+                            m_uiPhaseTimer = 1*IN_MILLISECONDS;
+                            if (pTarget && pTarget->getVictim())
+                                DoCastSpellIfCan(pTarget->getVictim(), SPELL_SHOCK);
+                        }
+                        else
+                        {
+                            ReApplyChain();
+                            m_uiPhase = PHASE_TESLA_DO_NOTHING;
+                        }
+                }
+                else
+                    m_uiPhaseTimer -= uiDiff;
+                break;
+            case PHASE_TESLA_OVERLOAD:
+                if (m_uiPhaseTimer <  uiDiff)
+                {
+                    m_uiPhase = PHASE_TESLA_DO_NOTHING;
+                    if (Creature* pThaddius = m_pInstance->instance->GetCreature(m_pInstance->GetData64(NPC_THADDIUS)))
+                    {
+                        DoCastSpellIfCan(pThaddius,  SPELL_SHOCK_OVERLOAD, CAST_INTERRUPT_PREVIOUS);
+                        DoScriptText(EMOTE_TESLA_OVERLOAD, m_creature);
+                    }
+                    m_pInstance->DoUseDoorOrButton(m_uiNoxTeslaGUID);
+                }
+                else
+                    m_uiPhaseTimer -= uiDiff;
+                break;
+        }
+    }
+};
+
+CreatureAI* GetAI_npc_tesla_coil(Creature* pCreature)
+{
+    return new npc_tesla_coilAI(pCreature);
+}
+
+/************
+** npc_thaddiusAddsAI - Super'class' for Feugen&Stalagg
+************/
+
+struct MANGOS_DLL_DECL npc_thaddiusAddsAI : public ScriptedAI
+{
+    npc_thaddiusAddsAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (instance_naxxramas*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+
+        m_uiThaddiusGUID = 0;
+        m_uiStalaggGUID = 0;
+        m_uiFeugenGUID = 0;
+
+        Reset();
+    }
+
+    instance_naxxramas* m_pInstance;
+    bool m_bIsRegularMode;
+
+    bool m_bFakeDeath;
+    bool m_bBothDead;
+
+    uint32 m_uiHoldTimer;
+    uint32 m_uiWarStompTimer;
+    uint32 m_uiReviveTimer;
+
+    uint64 m_uiThaddiusGUID;
+    uint64 m_uiStalaggGUID;
+    uint64 m_uiFeugenGUID;
+
+    void Reset()
+    {
+        m_bFakeDeath = false;
+        m_bBothDead = false;
+        m_uiReviveTimer = 5*IN_MILLISECONDS;
+        m_uiHoldTimer = 2*IN_MILLISECONDS;
+        m_uiWarStompTimer = urand(8*IN_MILLISECONDS, 10*IN_MILLISECONDS);
+
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        m_creature->SetHealth(m_creature->GetMaxHealth());
+        m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+    }
 
-    SPELL_BALL_LIGHTNING          = 28299,
+    Creature* GetOtherAdd()
+    {
+        switch (m_creature->GetEntry())
+        {
+            case NPC_FEUGEN:  return m_pInstance->instance->GetCreature(m_uiStalaggGUID);
+            case NPC_STALAGG: return m_pInstance->instance->GetCreature(m_uiFeugenGUID);
+        }
+        return NULL;
+    }
 
-    SPELL_CHARGE_POSITIVE_DMGBUFF = 29659,
-    SPELL_CHARGE_POSITIVE_NEARDMG = 28059,
+    void JustRespawned()
+    {
+        Reset();
 
-    SPELL_CHARGE_NEGATIVE_DMGBUFF = 29660,
-    SPELL_CHARGE_NEGATIVE_NEARDMG = 28084,
+        std::list<uint64> lTeslaGUIDList;
+        if (!m_pInstance)
+            return;
 
-    SPELL_CHAIN_LIGHTNING         = 28167,
-    H_SPELL_CHAIN_LIGHTNING       = 54531,
+        m_pInstance->GetThadTeslaCreatures(lTeslaGUIDList);
+        if (lTeslaGUIDList.empty())
+            return;
+        
+        for (std::list<uint64>::const_iterator itr = lTeslaGUIDList.begin(); itr != lTeslaGUIDList.end(); itr++)
+            if (Creature* pTesla = m_pInstance->instance->GetCreature(*itr))
+                if (npc_tesla_coilAI* pTeslaAI = dynamic_cast<npc_tesla_coilAI*> (pTesla->AI()))
+                    pTeslaAI->ReApplyChain();
+    }
 
-    SPELL_BESERK                  = 26662,
+    void JustReachedHome()
+    {
+        if (!m_pInstance)
+            return;
+        m_pInstance->SetData(TYPE_THADDIUS, FAIL);
+        if (Creature* pOther = GetOtherAdd())
+            if (npc_thaddiusAddsAI* pOtherAI = dynamic_cast<npc_thaddiusAddsAI*> (pOther->AI()))
+                if (pOtherAI->isCountingDead())
+                {
+                    pOther->ForcedDespawn();
+                    pOther->Respawn();
+                }
+    }
 
-    //generic
-    C_TESLA_COIL                  = 16218                   //the coils (emotes "Tesla Coil overloads!")
+    void KilledUnit(Unit *pVictim)
+    {
+        switch (m_creature->GetEntry())
+        {
+            case NPC_STALAGG:   DoScriptText(SAY_STAL_SLAY, m_creature); break;
+            case NPC_FEUGEN:    DoScriptText(SAY_FEUG_SLAY, m_creature); break;
+        }
+    }
+
+    void Revive()
+    {
+        DoResetThreat();
+        PauseCombatMovement();
+        Reset();
+    }
+
+    bool isCountingDead()
+    {
+        return m_bFakeDeath || m_creature->isDead();
+    }
+
+    void PauseCombatMovement()
+    {
+        SetCombatMovement(false);
+        m_uiHoldTimer = 2*IN_MILLISECONDS;
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_THADDIUS, IN_PROGRESS);
+    }
+
+    virtual void UpdateAddAI(const uint32 uiDiff){}
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_bBothDead)
+            return;
+        
+        if (m_bFakeDeath)
+        {
+            if (m_uiReviveTimer < uiDiff)
+            {
+                if (Creature* pOther = GetOtherAdd())
+                    if (npc_thaddiusAddsAI* pOtherAI = (npc_thaddiusAddsAI*) pOther->AI())
+                    {
+                        if (!pOtherAI->isCountingDead())
+                            Revive();
+                        else
+                        {
+                            m_bBothDead = true;
+                            pOtherAI->m_bBothDead = true;
+                            // Set Teslas
+                            std::list<uint64> lTeslaGUIDList;
+                            m_pInstance->GetThadTeslaCreatures(lTeslaGUIDList);
+                            for (std::list<uint64>::const_iterator itr = lTeslaGUIDList.begin(); itr != lTeslaGUIDList.end(); itr++)
+                                if (Creature* pTesla = m_pInstance->instance->GetCreature(*itr))
+                                    if (npc_tesla_coilAI* pTeslaAI = dynamic_cast<npc_tesla_coilAI*> (pTesla->AI()))
+                                        pTeslaAI->SetOverloading();
+                        }
+                    }
+            }
+            else
+                m_uiReviveTimer -= uiDiff;
+            return;
+        }
+        
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiHoldTimer)
+        {
+            if (m_uiHoldTimer <= uiDiff)
+            {
+                SetCombatMovement(true);
+                AttackStart(m_creature->getVictim());
+                m_creature->GetMotionMaster()->Clear();
+                m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+                m_uiHoldTimer = 0;
+            }
+            else
+                m_uiHoldTimer -= uiDiff;
+        }
+
+        if (m_uiWarStompTimer < uiDiff)
+        {
+            if (DoCastSpellIfCan(m_creature, SPELL_WARSTOMP) == CAST_OK)
+            m_uiWarStompTimer = urand(8*IN_MILLISECONDS, 10*IN_MILLISECONDS);
+        }
+        else
+            m_uiWarStompTimer -= uiDiff;
+
+        UpdateAddAI(uiDiff);                    // For Add Specific Abilities
+
+        DoMeleeAttackIfReady();
+    }
+
+    void DamageTaken(Unit* pKiller, uint32 &damage)
+    {
+        if (damage < m_creature->GetHealth())
+            return;
+        
+        if (!m_pInstance)
+            return;
+
+        //Prevent glitch if in fake death
+        if (m_bFakeDeath)
+        {
+            damage = 0;
+            return;
+        }
+
+        //prevent death
+        damage = 0;
+        m_bFakeDeath = true;
+
+        m_creature->InterruptNonMeleeSpells(false);
+        m_creature->SetHealth(0);
+        m_creature->StopMoving();
+        m_creature->ClearComboPointHolders();
+        m_creature->RemoveAllAurasOnDeath();
+        m_creature->ModifyAuraState(AURA_STATE_HEALTHLESS_20_PERCENT, false);
+        m_creature->ModifyAuraState(AURA_STATE_HEALTHLESS_35_PERCENT, false);
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        m_creature->ClearAllReactives();
+        m_creature->GetMotionMaster()->Clear();
+        m_creature->GetMotionMaster()->MoveIdle();
+        m_creature->SetStandState(UNIT_STAND_STATE_DEAD);
+
+        JustDied(pKiller);
+    }
 };
+
+/************
+** boss_thaddius
+************/
+
+struct MANGOS_DLL_DECL boss_thaddiusAI : public Scripted_NoMovementAI
+{
+    boss_thaddiusAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
+    {
+        m_pInstance = (instance_naxxramas*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+
+        m_uiStalaggGUID = 0;
+        m_uiFeugenGUID = 0;
+
+        Reset();
+    }
+
+    instance_naxxramas* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiResetFlagsTimer;
+    uint32 m_uiPolarityShiftTimer;
+    uint32 m_uiChainLightningTimer;
+    uint32 m_uiBallLightningTimer;
+    uint32 m_uiBerserkTimer;
+
+    uint64 m_uiStalaggGUID;
+    uint64 m_uiFeugenGUID;
+
+    uint32 m_uiPlayerCheckTimer;
+    uint8 m_uiMaxRaidPlayers;
+    bool m_bSubstraction;
+
+    void Reset()
+    {
+        m_uiResetFlagsTimer = 5*IN_MILLISECONDS;
+        m_uiPolarityShiftTimer = 15*IN_MILLISECONDS;
+        m_uiChainLightningTimer = 8*IN_MILLISECONDS;
+        m_uiBallLightningTimer = 1*IN_MILLISECONDS;
+        m_uiBerserkTimer = 6*MINUTE*IN_MILLISECONDS;
+
+        m_bSubstraction = true;
+        m_uiPlayerCheckTimer = 1000;
+        m_uiMaxRaidPlayers = m_bIsRegularMode ? 8 : 20;
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        switch (urand(0,2))
+        {
+            case 0: DoScriptText(SAY_AGGRO1, m_creature); break;
+            case 1: DoScriptText(SAY_AGGRO2, m_creature); break;
+            case 2: DoScriptText(SAY_AGGRO3, m_creature); break;
+        }
+    }
+
+    void StartEvent()
+    {
+        if (m_pInstance && m_pInstance->GetData(TYPE_THADDIUS) != IN_PROGRESS)
+        {
+            m_pInstance->SetData(TYPE_THADDIUS, IN_PROGRESS);
+            // Make Attackable
+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+
+            m_creature->SetInCombatWithZone();
+            m_uiStalaggGUID = m_pInstance->GetData64(NPC_STALAGG);
+            m_uiFeugenGUID = m_pInstance->GetData64(NPC_FEUGEN);
+        }
+    }
+
+    void JustReachedHome()
+    {
+        if (!m_pInstance)
+            return;
+
+        m_pInstance->SetData(TYPE_THADDIUS, FAIL);
+        RemoveAllAuras();
+        // Respawn Adds:
+        Creature* pFeugen  = m_pInstance->instance->GetCreature(m_uiFeugenGUID);
+        Creature* pStalagg = m_pInstance->instance->GetCreature(m_uiStalaggGUID);
+        if (pFeugen)
+        {
+            pFeugen->ForcedDespawn();
+            pFeugen->Respawn();
+        }
+        if (pStalagg)
+        {
+            pStalagg->ForcedDespawn();
+            pStalagg->Respawn();
+        }
+        Reset();
+    }
+
+    void KilledUnit(Unit *pVictim)
+    {
+        DoScriptText(SAY_SLAY, m_creature);
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+        RemoveAllAuras();
+        
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_THADDIUS, DONE);
+
+            if(m_bSubstraction)
+                m_pInstance->DoCompleteAchievement(m_bIsRegularMode ? ACHIEV_SUBSTRACTION : ACHIEV_SUBSTRACTION_H);
+
+            // Force Despawn of Adds
+            Creature* pFeugen  = ((Creature*)Unit::GetUnit(*m_creature, m_pInstance->GetData64(NPC_FEUGEN)));
+            Creature* pStalagg = ((Creature*)Unit::GetUnit(*m_creature, m_pInstance->GetData64(NPC_STALAGG)));
+
+            if (pFeugen)
+                pFeugen->DealDamage(pFeugen, pFeugen->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            if (pStalagg)
+                pStalagg->DealDamage(pStalagg, pStalagg->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+        }
+    }
+
+    void DoCastPolarityShift()
+    {
+        Map *map = m_creature->GetMap();
+        if (map->IsDungeon())
+        {
+            Map::PlayerList const &PlayerList = map->GetPlayers();
+
+            if (PlayerList.isEmpty())
+                return;
+
+            for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+            {
+                uint32 SpellId = 0;
+                switch (urand(0, 1))
+                {
+                case 0:
+                    SpellId = SPELL_POSITIVE_CHARGE;
+                    break;
+                case 1:
+                    SpellId = SPELL_NEGATIVE_CHARGE;
+                    break;
+                }
+                if (i->getSource()->isAlive())
+                {
+                    if(SpellId == SPELL_POSITIVE_CHARGE)
+                    {
+                        if(i->getSource()->HasAura(SPELL_NEGATIVE_CHARGE, EFFECT_INDEX_0))
+                            i->getSource()->RemoveAurasDueToSpell(SPELL_NEGATIVE_CHARGE);
+                        i->getSource()->CastSpell(i->getSource(), SpellId, false);
+                    }
+                    else if(SpellId == SPELL_NEGATIVE_CHARGE)
+                    {
+                        if(i->getSource()->HasAura(SPELL_POSITIVE_CHARGE, EFFECT_INDEX_0))
+                            i->getSource()->RemoveAurasDueToSpell(SPELL_POSITIVE_CHARGE);
+                        i->getSource()->CastSpell(i->getSource(), SpellId, false);
+                    }
+                }
+            }
+        } 
+    }
+
+    void RemoveAllAuras()
+    {
+        Map *map = m_creature->GetMap();
+        if (map->IsDungeon())
+        {
+            Map::PlayerList const &PlayerList = map->GetPlayers();
+
+            if (PlayerList.isEmpty())
+                return;
+
+            for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+            {
+                if (i->getSource()->isAlive())
+                {
+                    if(i->getSource()->HasAura(SPELL_POSITIVE_CHARGE, EFFECT_INDEX_0))
+                        i->getSource()->RemoveAurasDueToSpell(SPELL_POSITIVE_CHARGE);
+                    if(i->getSource()->HasAura(SPELL_NEGATIVE_CHARGE, EFFECT_INDEX_0))
+                        i->getSource()->RemoveAurasDueToSpell(SPELL_NEGATIVE_CHARGE);
+                }
+            }
+        } 
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_pInstance)
+            return;
+
+        if (m_uiResetFlagsTimer)
+        {
+            if (m_uiResetFlagsTimer < uiDiff)
+            {
+                DoCastSpellIfCan(m_creature, SPELL_THADIUS_STUN);
+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE);
+                m_uiResetFlagsTimer = 0;
+            }
+            else
+                m_uiResetFlagsTimer = (m_uiResetFlagsTimer == uiDiff) ? 1 : m_uiResetFlagsTimer - uiDiff;
+        }
+
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(m_pInstance)
+            if(m_pInstance->GetData(TYPE_FEUGEN) != DONE && m_pInstance->GetData(TYPE_STALAGG) != DONE)
+                return;
+
+        // Players check
+        if (m_uiPlayerCheckTimer < uiDiff && m_bSubstraction)
+        {
+            Map *map = m_creature->GetMap();
+            if (map->IsDungeon())
+            {
+                Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                if (PlayerList.isEmpty())
+                    return;
+
+                if(PlayerList.getSize() > m_uiMaxRaidPlayers)
+                    m_bSubstraction = false;
+            } 
+            m_uiPlayerCheckTimer = 1000;
+        }
+        else
+            m_uiPlayerCheckTimer -= uiDiff;
+
+        // Berserk
+        if (m_uiBerserkTimer < uiDiff)
+        {
+            if (DoCastSpellIfCan(m_creature, SPELL_BESERK) == CAST_OK)                  // allow combat movement?
+                m_uiBerserkTimer = 10*MINUTE*IN_MILLISECONDS;
+        }
+        else
+            m_uiBerserkTimer -= uiDiff;
+
+        // Ball Lightning if target not in melee range
+        if (!m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+        {
+            if (m_uiBallLightningTimer < uiDiff)
+            {
+                if (DoCastSpellIfCan(m_creature->getVictim(), SPELL_BALL_LIGHTNING) == CAST_OK)
+                    m_uiBallLightningTimer = 1*IN_MILLISECONDS;
+            }
+            else
+                m_uiBallLightningTimer -= uiDiff;
+        }
+
+        // Polarity Shift
+        if (m_uiPolarityShiftTimer < uiDiff)
+        {
+            if (DoCastSpellIfCan(m_creature, SPELL_POLARITY_SHIFT, CAST_INTERRUPT_PREVIOUS) == CAST_OK)
+            {
+                DoCastPolarityShift();
+                DoScriptText(SAY_ELECT, m_creature);
+                DoScriptText(EMOTE_POLARITY_SHIFT, m_creature);
+                m_uiPolarityShiftTimer = 30*IN_MILLISECONDS;
+            }
+        }
+        else
+            m_uiPolarityShiftTimer -= uiDiff;
+
+        // ChainLightning
+        if (m_uiChainLightningTimer < uiDiff)
+        {
+            Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0);
+            if (pTarget && DoCastSpellIfCan(pTarget, m_bIsRegularMode ? SPELL_CHAIN_LIGHTNING : SPELL_CHAIN_LIGHTNING_H) == CAST_OK)
+                m_uiChainLightningTimer = 15*IN_MILLISECONDS;
+        }
+        else
+            m_uiChainLightningTimer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_thaddius(Creature* pCreature)
+{
+    return new boss_thaddiusAI(pCreature);
+}
+
+bool EffectDummyCreature_spell_thaddius_encounter(Unit* pCaster, uint32 uiSpellId, SpellEffectIndex uiEffIndex, Creature* pCreatureTarget)
+{
+    if (uiEffIndex != EFFECT_INDEX_0)
+        return true;
+
+    switch (uiSpellId)
+    {
+        case SPELL_BREAK_CHANNEL:
+            if (pCreatureTarget->GetEntry() != NPC_TESLA_COIL)
+                return false;
+            if (npc_tesla_coilAI* pTeslaAI = dynamic_cast<npc_tesla_coilAI*>(pCreatureTarget->AI()))
+                pTeslaAI->LinkLost();
+            break;
+        case SPELL_SHOCK_OVERLOAD:
+            if (pCreatureTarget->GetEntry() != NPC_THADDIUS)
+                return false;
+            // remove Stun and then Cast
+            pCreatureTarget->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);    // needed? (in UDB set).
+            pCreatureTarget->RemoveAurasDueToSpell(SPELL_THADIUS_STUN);
+            pCreatureTarget->CastSpell(pCreatureTarget, SPELL_THADIUS_LIGHTNING_VISUAL, false);
+            break;
+        case SPELL_THADIUS_LIGHTNING_VISUAL:
+            if (pCreatureTarget->GetEntry() != NPC_THADDIUS)
+                return false;
+            if (boss_thaddiusAI* pThaddiusAI = dynamic_cast<boss_thaddiusAI*> (pCreatureTarget->AI()))
+                pThaddiusAI->StartEvent();
+            break;
+    }
+    return true;
+}
+
+/************
+** npc_stalagg
+************/
+
+struct MANGOS_DLL_DECL npc_stalaggAI : public npc_thaddiusAddsAI
+{
+    npc_stalaggAI(Creature* pCreature) : npc_thaddiusAddsAI(pCreature)
+    {
+        Reset();
+    }
+    uint32 m_uiPowerSurgeTimer;
+
+    void Reset()
+    {
+        npc_thaddiusAddsAI::Reset();
+        m_uiPowerSurgeTimer = urand(10*IN_MILLISECONDS, 15*IN_MILLISECONDS);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_STALAGG, NOT_STARTED);
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        DoScriptText(SAY_STAL_AGGRO, m_creature);
+
+        if (!m_pInstance)
+            return;
+
+        m_uiFeugenGUID   = m_pInstance->GetData64(NPC_FEUGEN);
+        m_uiStalaggGUID  = m_creature->GetGUID();
+
+        if (Creature* pFeugen = GetOtherAdd())
+            if (!pFeugen->isInCombat())
+                pFeugen->SetInCombatWithZone();
+
+        m_creature->SetInCombatWithZone();
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_STAL_DEATH, m_creature);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_STALAGG, DONE);
+    }
+
+    void UpdateAddAI(const uint32 uiDiff)
+    {
+        if (m_uiPowerSurgeTimer < uiDiff)
+        {
+            if (DoCastSpellIfCan(m_creature, m_bIsRegularMode ? SPELL_POWERSURGE : SPELL_POWERSURGE_H) == CAST_OK)
+                m_uiPowerSurgeTimer = urand(10*IN_MILLISECONDS, 15*IN_MILLISECONDS);
+        }
+        else
+            m_uiPowerSurgeTimer -= uiDiff;
+    }
+
+    void DamageTaken(Unit* pKiller, uint32 &damage)
+    {
+        npc_thaddiusAddsAI::DamageTaken(pKiller, damage);
+    }
+};
+
+CreatureAI* GetAI_npc_stalagg(Creature* pCreature)
+{
+    return new npc_stalaggAI(pCreature);
+}
+
+/************
+** npc_feugen
+************/
+
+struct MANGOS_DLL_DECL npc_feugenAI : public npc_thaddiusAddsAI
+{
+    npc_feugenAI(Creature* pCreature) : npc_thaddiusAddsAI(pCreature)
+    {
+        Reset();
+    }
+    uint32 m_uiStaticFieldTimer;
+    uint32 m_uiMagneticPullTimer;                                       // TODO, missing
+
+    void Reset()
+    {
+        npc_thaddiusAddsAI::Reset();
+        m_uiStaticFieldTimer = urand(10*IN_MILLISECONDS, 15*IN_MILLISECONDS);
+        m_uiMagneticPullTimer = 20*IN_MILLISECONDS;
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_FEUGEN, NOT_STARTED);
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        DoScriptText(SAY_FEUG_AGGRO, m_creature);
+
+        if (!m_pInstance)
+            return;
+
+        m_uiStalaggGUID = m_pInstance->GetData64(NPC_STALAGG);
+        m_uiFeugenGUID  = m_creature->GetGUID();
+
+        if (Creature* pStalagg = GetOtherAdd())
+            if (pStalagg && !pStalagg->isInCombat())
+                pStalagg->SetInCombatWithZone();
+
+        m_creature->SetInCombatWithZone();
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_FEUG_DEATH, m_creature);
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_FEUGEN, DONE);
+    }
+
+    void UpdateAddAI(const uint32 uiDiff)
+    {
+        if (m_uiStaticFieldTimer < uiDiff)
+        {
+            if (DoCastSpellIfCan(m_creature, m_bIsRegularMode ? SPELL_STATIC_FIELD : SPELL_STATIC_FIELD_H) == CAST_OK)
+                m_uiStaticFieldTimer = urand(10*IN_MILLISECONDS, 15*IN_MILLISECONDS);
+        }
+        else
+            m_uiStaticFieldTimer -= uiDiff;
+    }
+
+    void DamageTaken(Unit* pKiller, uint32 &damage)
+    {
+        npc_thaddiusAddsAI::DamageTaken(pKiller, damage);
+    }
+};
+
+CreatureAI* GetAI_npc_feugen(Creature* pCreature)
+{
+    return new npc_feugenAI(pCreature);
+}
+
+void AddSC_boss_thaddius()
+{
+    Script* NewScript;
+    NewScript = new Script;
+    NewScript->Name = "boss_thaddius";
+    NewScript->GetAI = &GetAI_boss_thaddius;
+    NewScript->pEffectDummyCreature = &EffectDummyCreature_spell_thaddius_encounter;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "npc_stalagg";
+    NewScript->GetAI = &GetAI_npc_stalagg;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "npc_feugen";
+    NewScript->GetAI = &GetAI_npc_feugen;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "npc_tesla_coil";
+    NewScript->GetAI = &GetAI_npc_tesla_coil;
+    NewScript->pEffectDummyCreature = &EffectDummyCreature_spell_thaddius_encounter;
+    NewScript->RegisterSelf();
+}
\ No newline at end of file
diff --git a/scripts/northrend/naxxramas/instance_naxxramas.cpp b/scripts/northrend/naxxramas/instance_naxxramas.cpp
index aa64b6d..92efd0a 100644
--- a/scripts/northrend/naxxramas/instance_naxxramas.cpp
+++ b/scripts/northrend/naxxramas/instance_naxxramas.cpp
@@ -1,18 +1,18 @@
 /* Copyright (C) 2006 - 2010 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
 
 /* ScriptData
 SDName: Instance_Naxxramas
@@ -24,12 +24,63 @@ EndScriptData */
 #include "precompiled.h"
 #include "naxxramas.h"
 
+const float PosAracTele[4] = {3020.08f, -3448.65f, 300.97f, 3.14f};
+const float PosConsTele[4] = {3019.93f, -3420.31f, 300.97f, 3.14f};
+const float PosPlagTele[4] = {2991.58f, -3448.51f, 300.97f, 3.14f};
+const float PosMiliTele[4] = {2991.71f, -3420.18f, 300.97f, 3.14f};
+
+bool GOHello_go_naxxTeleporter(Player* pPlayer, GameObject* pGo)
+{
+    ScriptedInstance* pInstance = (ScriptedInstance*)pGo->GetInstanceData();
+
+    if (!pInstance)
+        return false;
+
+    switch(pGo->GetEntry())
+    {
+    case GO_ARAC_PORTAL:
+        if(pInstance->GetData(TYPE_MAEXXNA) == DONE)
+        {
+            if(pGo->GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) < 2)
+                pPlayer->TeleportTo(pPlayer->GetMapId(), PosAracTele[0], PosAracTele[1], PosAracTele[2], PosAracTele[3]);
+        }
+        break;
+    case GO_CONS_PORTAL:
+        if(pInstance->GetData(TYPE_THADDIUS) == DONE)
+        {
+            if(pGo->GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) < 2)
+                pPlayer->TeleportTo(pPlayer->GetMapId(), PosConsTele[0], PosConsTele[1], PosConsTele[2], PosConsTele[3]);
+        }
+        break;
+    case GO_MILI_PORTAL:
+        if(pInstance->GetData(TYPE_FOUR_HORSEMEN) == DONE)
+        {
+            if(pGo->GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) < 2)
+                pPlayer->TeleportTo(pPlayer->GetMapId(), PosMiliTele[0], PosMiliTele[1], PosMiliTele[2], PosMiliTele[3]);
+        }
+        break;
+    case GO_PLAG_PORTAL:
+        if(pInstance->GetData(TYPE_LOATHEB) == DONE)
+        {
+            if(pGo->GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) < 2)
+                pPlayer->TeleportTo(pPlayer->GetMapId(), PosPlagTele[0], PosPlagTele[1], PosPlagTele[2], PosPlagTele[3]);
+        }
+        break;
+    }
+    return false;
+}
+
 instance_naxxramas::instance_naxxramas(Map* pMap) : ScriptedInstance(pMap),
     m_uiAracEyeRampGUID(0),
     m_uiPlagEyeRampGUID(0),
     m_uiMiliEyeRampGUID(0),
     m_uiConsEyeRampGUID(0),
 
+    m_uiAracEyeGUID(0),
+    m_uiPlagEyeGUID(0),
+    m_uiMiliEyeGUID(0),
+    m_uiConsEyeGUID(0),
+
     m_uiAracPortalGUID(0),
     m_uiPlagPortalGUID(0),
     m_uiMiliPortalGUID(0),
@@ -50,6 +101,8 @@ instance_naxxramas::instance_naxxramas(Map* pMap) : ScriptedInstance(pMap),
     m_uiPathExitDoorGUID(0),
     m_uiGlutExitDoorGUID(0),
     m_uiThadDoorGUID(0),
+    m_uiThadNoxTeslaFeugenGUID(0),
+    m_uiThadNoxTeslaStalaggGUID(0),
 
     m_uiAnubDoorGUID(0),
     m_uiAnubGateGUID(0),
@@ -71,10 +124,28 @@ instance_naxxramas::instance_naxxramas(Map* pMap) : ScriptedInstance(pMap),
     m_uiHeigExitDoorGUID(0),
     m_uiLoathebDoorGUID(0),
 
+    m_uiKelthuzadWaterfallDoorGUID(0),
     m_uiKelthuzadDoorGUID(0),
     m_fChamberCenterX(0.0f),
     m_fChamberCenterY(0.0f),
-    m_fChamberCenterZ(0.0f)
+    m_fChamberCenterZ(0.0f),
+
+    BlaumeuxDead(false),
+    RivendareDead(false),
+    ZeliekDead(false), 
+    KorthazzDead(false),
+
+    m_auiStalaggEncounter(0),
+    m_auiFeugenEncouter(0),
+
+    DeadTimer(0),            
+    UpdateCheck(false),
+
+    m_uiArachnofobiaTimer(0),
+    m_bIsArachnofobia (false),
+
+    m_uiImmortaCheck(1000)
+
 {
     Initialize();
 }
@@ -88,17 +159,18 @@ void instance_naxxramas::OnCreatureCreate(Creature* pCreature)
 {
     switch(pCreature->GetEntry())
     {
-        case NPC_ANUB_REKHAN:       m_uiAnubRekhanGUID = pCreature->GetGUID();  break;
-        case NPC_FAERLINA:          m_uiFaerlinanGUID = pCreature->GetGUID();   break;
-        case NPC_THADDIUS:          m_uiThaddiusGUID = pCreature->GetGUID();    break;
-        case NPC_STALAGG:           m_uiStalaggGUID = pCreature->GetGUID();     break;
-        case NPC_FEUGEN:            m_uiFeugenGUID = pCreature->GetGUID();      break;
-        case NPC_ZELIEK:            m_uiZeliekGUID = pCreature->GetGUID();      break;
-        case NPC_THANE:             m_uiThaneGUID = pCreature->GetGUID();       break;
-        case NPC_BLAUMEUX:          m_uiBlaumeuxGUID = pCreature->GetGUID();    break;
-        case NPC_RIVENDARE:         m_uiRivendareGUID = pCreature->GetGUID();   break;
-        case NPC_GOTHIK:            m_uiGothikGUID = pCreature->GetGUID();      break;
-        case NPC_SUB_BOSS_TRIGGER:  m_lGothTriggerList.push_back(pCreature->GetGUID()); break;
+    case NPC_ANUB_REKHAN:       m_uiAnubRekhanGUID = pCreature->GetGUID();  break;
+    case NPC_FAERLINA:          m_uiFaerlinanGUID = pCreature->GetGUID();   break;
+    case NPC_THADDIUS:          m_uiThaddiusGUID = pCreature->GetGUID();    break;
+    case NPC_STALAGG:           m_uiStalaggGUID = pCreature->GetGUID();     break;
+    case NPC_FEUGEN:            m_uiFeugenGUID = pCreature->GetGUID();      break;
+    case NPC_ZELIEK:            m_uiZeliekGUID = pCreature->GetGUID();      break;
+    case NPC_THANE:             m_uiThaneGUID = pCreature->GetGUID();       break;
+    case NPC_BLAUMEUX:          m_uiBlaumeuxGUID = pCreature->GetGUID();    break;
+    case NPC_RIVENDARE:         m_uiRivendareGUID = pCreature->GetGUID();   break;
+    case NPC_GOTHIK:            m_uiGothikGUID = pCreature->GetGUID();      break;
+    case NPC_SUB_BOSS_TRIGGER:  m_lGothTriggerList.push_back(pCreature->GetGUID()); break;
+    case NPC_TESLA_COIL:        m_lThadTeslaCoilList.push_back(pCreature->GetGUID()); break;
     }
 }
 
@@ -106,131 +178,187 @@ void instance_naxxramas::OnObjectCreate(GameObject* pGo)
 {
     switch(pGo->GetEntry())
     {
-        case GO_ARAC_ANUB_DOOR:
-            m_uiAnubDoorGUID = pGo->GetGUID();
-            break;
-        case GO_ARAC_ANUB_GATE:
-            m_uiAnubGateGUID = pGo->GetGUID();
-            if (m_auiEncounter[0] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-        case GO_ARAC_FAER_WEB:
-            m_uiFaerWebGUID = pGo->GetGUID();
-            break;
-        case GO_ARAC_FAER_DOOR:
-            m_uiFaerDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[1] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-        case GO_ARAC_MAEX_INNER_DOOR:
-            m_uiMaexInnerGUID = pGo->GetGUID();
-            break;
-        case GO_ARAC_MAEX_OUTER_DOOR:
-            m_uiMaexOuterGUID = pGo->GetGUID();
-            if (m_auiEncounter[1] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-
-        case GO_PLAG_NOTH_ENTRY_DOOR:
-            m_uiNothEntryDoorGUID = pGo->GetGUID();
-            break;
-        case GO_PLAG_NOTH_EXIT_DOOR:
-            m_uiNothExitDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[3] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-        case GO_PLAG_HEIG_ENTRY_DOOR:
-            m_uiHeigEntryDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[3] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-        case GO_PLAG_HEIG_EXIT_DOOR:
-            m_uiHeigExitDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[4] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-        case GO_PLAG_LOAT_DOOR:
-            m_uiLoathebDoorGUID = pGo->GetGUID();
-            break;
-
-        case GO_MILI_GOTH_ENTRY_GATE:
-            m_uiGothikEntryDoorGUID = pGo->GetGUID();
-            break;
-        case GO_MILI_GOTH_EXIT_GATE:
-            m_uiGothikExitDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[7] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-        case GO_MILI_GOTH_COMBAT_GATE:
-            m_uiGothCombatGateGUID = pGo->GetGUID();
-            break;
-        case GO_MILI_HORSEMEN_DOOR:
-            m_uiHorsemenDoorGUID  = pGo->GetGUID();
-            if (m_auiEncounter[7] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-
-        case GO_CHEST_HORSEMEN_NORM:
-        case GO_CHEST_HORSEMEN_HERO:
+    case GO_ARAC_ANUB_DOOR:
+        m_uiAnubDoorGUID = pGo->GetGUID();
+        break;
+    case GO_ARAC_ANUB_GATE:
+        m_uiAnubGateGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_READY);
+        if (m_auiEncounter[0] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_ARAC_FAER_WEB:
+        m_uiFaerWebGUID = pGo->GetGUID();
+        break;
+    case GO_ARAC_FAER_DOOR:
+        m_uiFaerDoorGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_READY);
+        if (m_auiEncounter[1] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_ARAC_MAEX_INNER_DOOR:
+        m_uiMaexInnerGUID = pGo->GetGUID();
+        break;
+    case GO_ARAC_MAEX_OUTER_DOOR:
+        m_uiMaexOuterGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_READY);
+        if (m_auiEncounter[1] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+
+    case GO_PLAG_NOTH_ENTRY_DOOR:
+        m_uiNothEntryDoorGUID = pGo->GetGUID();
+        break;
+    case GO_PLAG_NOTH_EXIT_DOOR:
+        m_uiNothExitDoorGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_READY);
+        if (m_auiEncounter[3] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_PLAG_HEIG_ENTRY_DOOR:
+        m_uiHeigEntryDoorGUID = pGo->GetGUID();
+        //pGo->SetGoState(GO_STATE_READY);
+        if (m_auiEncounter[3] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_PLAG_HEIG_EXIT_DOOR:
+        m_uiHeigExitDoorGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_READY);
+        if (m_auiEncounter[4] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_PLAG_LOAT_DOOR:
+        m_uiLoathebDoorGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_READY);
+        break;
+
+    case GO_MILI_GOTH_ENTRY_GATE:
+        pGo->SetGoState(GO_STATE_READY);
+        m_uiGothikEntryDoorGUID = pGo->GetGUID();
+        break;
+    case GO_MILI_GOTH_EXIT_GATE:
+        m_uiGothikExitDoorGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_READY);
+        if (m_auiEncounter[7] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_MILI_GOTH_COMBAT_GATE:
+        m_uiGothCombatGateGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_MILI_HORSEMEN_DOOR:
+        m_uiHorsemenDoorGUID  = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_READY);
+        if (m_auiEncounter[7] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+
+    case GO_CHEST_HORSEMEN_NORM:
+        if(instance->IsRegularDifficulty())
+            m_uiHorsemenChestGUID = pGo->GetGUID();
+        break;
+    case GO_CHEST_HORSEMEN_HERO:
+        if(!instance->IsRegularDifficulty())
             m_uiHorsemenChestGUID = pGo->GetGUID();
-            break;
-
-        case GO_CONS_PATH_EXIT_DOOR:
-            m_uiPathExitDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[9] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-        case GO_CONS_GLUT_EXIT_DOOR:
-            m_uiGlutExitDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[11] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-        case GO_CONS_THAD_DOOR:
-            m_uiThadDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[11] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
 
-        case GO_KELTHUZAD_WATERFALL_DOOR:
-            m_uiKelthuzadDoorGUID = pGo->GetGUID();
-            if (m_auiEncounter[13] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
+    case GO_CONS_PATH_EXIT_DOOR:
+        m_uiPathExitDoorGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_READY);
+        if (m_auiEncounter[9] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_CONS_GLUT_EXIT_DOOR:
+        m_uiGlutExitDoorGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_READY);
+        if (m_auiEncounter[11] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_CONS_THAD_DOOR:
+        m_uiThadDoorGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_READY);
+        if (m_auiEncounter[11] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_CONS_NOX_TESLA_FEUGEN:
+        m_uiThadNoxTeslaFeugenGUID = pGo->GetGUID();
+        break;
+    case GO_CONS_NOX_TESLA_STALAGG:
+        m_uiThadNoxTeslaStalaggGUID = pGo->GetGUID();
+        break;
+
+    case GO_KELTHUZAD_WATERFALL_DOOR:
+        m_uiKelthuzadWaterfallDoorGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_READY);
+        if (m_auiEncounter[13] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_KELTHUZAD_COMBAT_GATE: 
+        pGo->SetGoState(GO_STATE_READY);
+        m_uiKelthuzadDoorGUID = pGo->GetGUID();
+        pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+
+    case GO_ARAC_EYE_RAMP:
+        m_uiAracEyeRampGUID = pGo->GetGUID();
+        if (m_auiEncounter[2] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_PLAG_EYE_RAMP:
+        m_uiPlagEyeRampGUID = pGo->GetGUID();
+        if (m_auiEncounter[5] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_MILI_EYE_RAMP:
+        m_uiMiliEyeRampGUID = pGo->GetGUID();
+        if (m_auiEncounter[8] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+    case GO_CONS_EYE_RAMP:
+        m_uiConsEyeRampGUID = pGo->GetGUID();
+        if (m_auiEncounter[12] == DONE)
+            pGo->SetGoState(GO_STATE_ACTIVE);
+        break;
+
+    case GO_ARAC_PORTAL:
+        m_uiAracPortalGUID = pGo->GetGUID();
+        break;
+    case GO_PLAG_PORTAL:
+        m_uiPlagPortalGUID = pGo->GetGUID();
+        break;
+    case GO_MILI_PORTAL:
+        m_uiMiliPortalGUID = pGo->GetGUID();
+        break;
+    case GO_CONS_PORTAL:
+        m_uiConsPortalGUID = pGo->GetGUID();
+        break;
+
+    case GO_ARAC_EYE: 
+        m_uiAracEyeGUID = pGo->GetGUID(); 
+        break;
+    case GO_PLAG_EYE: 
+        m_uiPlagEyeGUID = pGo->GetGUID(); 
+        break;
+    case GO_MILI_EYE: 
+        m_uiMiliEyeGUID = pGo->GetGUID(); 
+        break;
+    case GO_CONS_EYE: 
+        m_uiConsEyeGUID = pGo->GetGUID(); 
+        break;
+    }
+}
 
-        case GO_ARAC_EYE_RAMP:
-            m_uiAracEyeRampGUID = pGo->GetGUID();
-            if (m_auiEncounter[2] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-        case GO_PLAG_EYE_RAMP:
-            m_uiPlagEyeRampGUID = pGo->GetGUID();
-            if (m_auiEncounter[5] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-        case GO_MILI_EYE_RAMP:
-            m_uiMiliEyeRampGUID = pGo->GetGUID();
-            if (m_auiEncounter[8] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
-        case GO_CONS_EYE_RAMP:
-            m_uiConsEyeRampGUID = pGo->GetGUID();
-            if (m_auiEncounter[12] == DONE)
-                pGo->SetGoState(GO_STATE_ACTIVE);
-            break;
+void instance_naxxramas::OpenDoor(uint64 guid)
+{
+    if(!guid) return;
+    GameObject* pGo = instance->GetGameObject(guid);
+    if(pGo) pGo->SetGoState(GO_STATE_ACTIVE);
+}
 
-        case GO_ARAC_PORTAL:
-            m_uiAracPortalGUID = pGo->GetGUID();
-            break;
-        case GO_PLAG_PORTAL:
-            m_uiPlagPortalGUID = pGo->GetGUID();
-            break;
-        case GO_MILI_PORTAL:
-            m_uiMiliPortalGUID = pGo->GetGUID();
-            break;
-        case GO_CONS_PORTAL:
-            m_uiConsPortalGUID = pGo->GetGUID();
-            break;
-    }
+void instance_naxxramas::CloseDoor(uint64 guid)
+{
+    if(!guid) return;
+    GameObject* pGo = instance->GetGameObject(guid);
+    if(pGo) pGo->SetGoState(GO_STATE_READY);
 }
 
 bool instance_naxxramas::IsEncounterInProgress()
@@ -246,155 +374,238 @@ void instance_naxxramas::SetData(uint32 uiType, uint32 uiData)
 {
     switch(uiType)
     {
-        case TYPE_ANUB_REKHAN:
-            m_auiEncounter[0] = uiData;
-            DoUseDoorOrButton(m_uiAnubDoorGUID);
-            if (uiData == DONE)
-                DoUseDoorOrButton(m_uiAnubGateGUID);
-            break;
-        case TYPE_FAERLINA:
-            m_auiEncounter[1] = uiData;
-            DoUseDoorOrButton(m_uiFaerWebGUID);
-            if (uiData == DONE)
-            {
-                DoUseDoorOrButton(m_uiFaerDoorGUID);
-                DoUseDoorOrButton(m_uiMaexOuterGUID);
-            }
-            break;
-        case TYPE_MAEXXNA:
-            m_auiEncounter[2] = uiData;
-            DoUseDoorOrButton(m_uiMaexInnerGUID, uiData);
-            if (uiData == DONE)
-            {
-                DoUseDoorOrButton(m_uiAracEyeRampGUID);
-                DoRespawnGameObject(m_uiAracPortalGUID, 30*MINUTE);
-            }
-            break;
-        case TYPE_NOTH:
-            m_auiEncounter[3] = uiData;
-            DoUseDoorOrButton(m_uiNothEntryDoorGUID);
-            if (uiData == DONE)
-            {
-                DoUseDoorOrButton(m_uiNothExitDoorGUID);
-                DoUseDoorOrButton(m_uiHeigEntryDoorGUID);
-            }
-            break;
-        case TYPE_HEIGAN:
-            m_auiEncounter[4] = uiData;
-            DoUseDoorOrButton(m_uiHeigEntryDoorGUID);
-            if (uiData == DONE)
-                DoUseDoorOrButton(m_uiHeigExitDoorGUID);
-            break;
-        case TYPE_LOATHEB:
-            m_auiEncounter[5] = uiData;
-            DoUseDoorOrButton(m_uiLoathebDoorGUID);
-            if (uiData == DONE)
-            {
-                DoUseDoorOrButton(m_uiPlagEyeRampGUID);
-                DoRespawnGameObject(m_uiPlagPortalGUID, 30*MINUTE);
-            }
-            break;
-        case TYPE_RAZUVIOUS:
-            m_auiEncounter[6] = uiData;
-            break;
-        case TYPE_GOTHIK:
-            switch(uiData)
-            {
-                case IN_PROGRESS:
-                    DoUseDoorOrButton(m_uiGothikEntryDoorGUID);
-                    DoUseDoorOrButton(m_uiGothCombatGateGUID);
-                    break;
-                case SPECIAL:
-                    DoUseDoorOrButton(m_uiGothCombatGateGUID);
-                    break;
-                case FAIL:
-                    if (m_auiEncounter[7] == IN_PROGRESS)
-                        DoUseDoorOrButton(m_uiGothCombatGateGUID);
-
-                    DoUseDoorOrButton(m_uiGothikEntryDoorGUID);
-                    break;
-                case DONE:
-                    DoUseDoorOrButton(m_uiGothikEntryDoorGUID);
-                    DoUseDoorOrButton(m_uiGothikExitDoorGUID);
-                    DoUseDoorOrButton(m_uiHorsemenDoorGUID);
-                    break;
-            }
-            m_auiEncounter[7] = uiData;
-            break;
-        case TYPE_FOUR_HORSEMEN:
-            m_auiEncounter[8] = uiData;
-            DoUseDoorOrButton(m_uiHorsemenDoorGUID);
-            if (uiData == DONE)
+    case TYPE_ANUB_REKHAN:
+        m_auiEncounter[0] = uiData;
+        DoUseDoorOrButton(m_uiAnubDoorGUID);
+        if (uiData == DONE)
+        {
+            OpenDoor(m_uiAnubGateGUID);
+            m_uiArachnofobiaTimer = 0;
+            m_bIsArachnofobia = true;
+        }
+        break;
+    case TYPE_FAERLINA:
+        m_auiEncounter[1] = uiData;
+        DoUseDoorOrButton(m_uiFaerWebGUID);
+        if (uiData == DONE)
+        {
+            OpenDoor(m_uiFaerDoorGUID);
+            OpenDoor(m_uiMaexOuterGUID);
+        }
+        break;
+    case TYPE_MAEXXNA:
+        m_auiEncounter[2] = uiData;
+        DoUseDoorOrButton(m_uiMaexInnerGUID, uiData);
+        if (uiData == DONE)
+        {
+            DoUseDoorOrButton(m_uiAracEyeRampGUID);
+            DoUseDoorOrButton(m_uiAracEyeGUID);
+            DoRespawnGameObject(m_uiAracPortalGUID, 30*MINUTE);
+            Immortal();
+
+            // Arachnofobia
+            if(m_uiArachnofobiaTimer <= 20 * 60000 && m_bIsArachnofobia)
             {
-                DoUseDoorOrButton(m_uiMiliEyeRampGUID);
-                DoRespawnGameObject(m_uiMiliPortalGUID, 30*MINUTE);
-                DoRespawnGameObject(m_uiHorsemenChestGUID, 30*MINUTE);
+                Arachnofobia();
+                m_bIsArachnofobia = false;
             }
+        }
+        break;
+    case TYPE_NOTH:
+        m_auiEncounter[3] = uiData;
+        DoUseDoorOrButton(m_uiNothEntryDoorGUID);
+        if (uiData == DONE)
+        {
+            OpenDoor(m_uiNothExitDoorGUID);
+            OpenDoor(m_uiHeigEntryDoorGUID);
+        }
+        break;
+    case TYPE_HEIGAN:
+        m_auiEncounter[4] = uiData;
+        DoUseDoorOrButton(m_uiHeigEntryDoorGUID);
+        if (uiData == DONE)
+        {
+            OpenDoor(m_uiHeigExitDoorGUID);
+            OpenDoor(m_uiLoathebDoorGUID);
+        }
+        break;
+    case TYPE_LOATHEB:
+        m_auiEncounter[5] = uiData;
+        DoUseDoorOrButton(m_uiLoathebDoorGUID);
+        if (uiData == DONE)
+        {
+            DoUseDoorOrButton(m_uiPlagEyeRampGUID);
+            DoUseDoorOrButton(m_uiPlagEyeGUID);
+            DoRespawnGameObject(m_uiPlagPortalGUID, 30*MINUTE);
+            Immortal();
+        }
+        break;
+    case TYPE_RAZUVIOUS:
+        m_auiEncounter[6] = uiData;
+        if (uiData == DONE)
+            OpenDoor(m_uiGothikEntryDoorGUID);
+        break;
+    case TYPE_GOTHIK:
+        switch(uiData)
+        {
+        case IN_PROGRESS:
+            DoUseDoorOrButton(m_uiGothikEntryDoorGUID);
+            DoUseDoorOrButton(m_uiGothCombatGateGUID);
             break;
-        case TYPE_PATCHWERK:
-            m_auiEncounter[9] = uiData;
-            if (uiData == DONE)
-                DoUseDoorOrButton(m_uiPathExitDoorGUID);
+        case SPECIAL:
+            DoUseDoorOrButton(m_uiGothCombatGateGUID);
             break;
-        case TYPE_GROBBULUS:
-            m_auiEncounter[10] = uiData;
+        case FAIL:
+            if (m_auiEncounter[7] == IN_PROGRESS)
+                DoUseDoorOrButton(m_uiGothCombatGateGUID);
+
+            DoUseDoorOrButton(m_uiGothikEntryDoorGUID);
             break;
-        case TYPE_GLUTH:
-            m_auiEncounter[11] = uiData;
-            if (uiData == DONE)
-            {
-                DoUseDoorOrButton(m_uiGlutExitDoorGUID);
-                DoUseDoorOrButton(m_uiThadDoorGUID);
-            }
+        case DONE:
+            OpenDoor(m_uiGothikEntryDoorGUID);
+            OpenDoor(m_uiGothikExitDoorGUID);
+            OpenDoor(m_uiHorsemenDoorGUID);
+            OpenDoor(m_uiGothCombatGateGUID);
             break;
-        case TYPE_THADDIUS:
-            m_auiEncounter[12] = uiData;
+        }
+        m_auiEncounter[7] = uiData;
+        break;
+    case TYPE_FOUR_HORSEMEN:
+        m_auiEncounter[8] = uiData;
+        DoUseDoorOrButton(m_uiHorsemenDoorGUID);
+        if (uiData == DONE)
+        {
+            //DoUpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_BE_SPELL_TARGET, 59450);
+            DoUseDoorOrButton(m_uiMiliEyeRampGUID);
+            DoUseDoorOrButton(m_uiMiliEyeGUID);
+            DoRespawnGameObject(m_uiMiliPortalGUID, 30*MINUTE);
+            DoRespawnGameObject(m_uiHorsemenChestGUID, 30*MINUTE);
+            Immortal();
+        }
+        break;
+    case TYPE_PATCHWERK:
+        m_auiEncounter[9] = uiData;
+        if (uiData == DONE)
+            OpenDoor(m_uiPathExitDoorGUID);
+        break;
+    case TYPE_GROBBULUS:
+        m_auiEncounter[10] = uiData;
+        break;
+    case TYPE_GLUTH:
+        m_auiEncounter[11] = uiData;
+        if (uiData == DONE)
+        {
+            OpenDoor(m_uiGlutExitDoorGUID);
+            OpenDoor(m_uiThadDoorGUID);
+        }
+        break;
+    case TYPE_THADDIUS:
+        m_auiEncounter[12] = uiData;
+        if(uiData != SPECIAL)
             DoUseDoorOrButton(m_uiThadDoorGUID, uiData);
-            if (uiData == DONE)
-            {
-                DoUseDoorOrButton(m_uiConsEyeRampGUID);
-                DoRespawnGameObject(m_uiConsPortalGUID, 30*MINUTE);
-            }
-            break;
-        case TYPE_SAPPHIRON:
-            m_auiEncounter[13] = uiData;
-            if (uiData == DONE)
-                DoUseDoorOrButton(m_uiKelthuzadDoorGUID);
-            break;
-        case TYPE_KELTHUZAD:
-            switch(uiData)
+        if(uiData == FAIL)
+            OpenDoor(m_uiThadDoorGUID);
+        if (uiData == DONE)
+        {
+            DoUseDoorOrButton(m_uiConsEyeRampGUID);
+            DoUseDoorOrButton(m_uiConsEyeGUID);
+            DoRespawnGameObject(m_uiConsPortalGUID, 30*MINUTE);
+            Immortal();
+        }
+        break;
+    case TYPE_SAPPHIRON:
+        m_auiEncounter[13] = uiData;
+        if (uiData == DONE)
+        {
+            OpenDoor(m_uiKelthuzadWaterfallDoorGUID);
+            OpenDoor(m_uiKelthuzadDoorGUID);
+        }
+        break;
+    case TYPE_KELTHUZAD: 
+        //DoUseDoorOrButton(m_uiKelthuzadDoorGUID);
+        switch(uiData)
+        {
+        case SPECIAL:
             {
-                case SPECIAL:
-                {
-                    Map::PlayerList const& lPlayers = instance->GetPlayers();
+                Map::PlayerList const& lPlayers = instance->GetPlayers();
 
-                    if (lPlayers.isEmpty())
-                        return;
+                if (lPlayers.isEmpty())
+                    return;
 
-                    bool bCanBegin = true;
+                bool bCanBegin = true;
 
-                    for(Map::PlayerList::const_iterator itr = lPlayers.begin(); itr != lPlayers.end(); ++itr)
+                for(Map::PlayerList::const_iterator itr = lPlayers.begin(); itr != lPlayers.end(); ++itr)
+                {
+                    if (Player* pPlayer = itr->getSource())
                     {
-                        if (Player* pPlayer = itr->getSource())
-                        {
-                            if (!pPlayer->IsWithinDist2d(m_fChamberCenterX, m_fChamberCenterY, 15.0f))
-                                bCanBegin = false;
-                        }
+                        if (!pPlayer->IsWithinDist2d(m_fChamberCenterX, m_fChamberCenterY, 15.0f))
+                            bCanBegin = false;
                     }
+                }
 
-                    if (bCanBegin)
-                        m_auiEncounter[14] = IN_PROGRESS;
-
-                    break;
+                if (bCanBegin)
+                {
+                    m_auiEncounter[14] = IN_PROGRESS;
+                    CloseDoor(m_uiKelthuzadDoorGUID);
                 }
-                case FAIL:
-                    m_auiEncounter[14] = NOT_STARTED;
-                    break;
-                default:
-                    m_auiEncounter[14] = uiData;
-                    break;
+
+                break;
             }
+        case FAIL:
+            m_auiEncounter[14] = NOT_STARTED;
+            OpenDoor(m_uiKelthuzadDoorGUID);
+            break;
+        case DONE:
+            OpenDoor(m_uiKelthuzadDoorGUID);
+            Immortal();
+            break;
+        default:
+            m_auiEncounter[14] = uiData;
             break;
+        }
+        break;
+    case TYPE_IMMORTAL:
+        m_auiEncounter[15] = uiData;
+        break;
+        //Four Horsemen Chest
+    case TYPE_BLAUMEAUX:
+        if (uiData == DONE)
+        {
+            BlaumeuxDead = true;
+            UpdateCheck = true;
+            Horseman();
+        }
+        break;
+    case TYPE_RIVENDARE:
+        if (uiData == DONE)
+        {
+            RivendareDead = true;
+            UpdateCheck = true;
+            Horseman();
+        }
+        break;
+    case TYPE_ZELIEK:
+        if (uiData == DONE)
+        {
+            ZeliekDead = true;
+            UpdateCheck = true;
+            Horseman();
+        }
+        break;
+    case TYPE_KORTHAZZ:
+        if (uiData == DONE)
+        {
+            KorthazzDead = true;
+            UpdateCheck = true;
+            Horseman();
+        }
+        break;
+    case TYPE_STALAGG:
+        m_auiStalaggEncounter = uiData;
+        break;
+    case TYPE_FEUGEN:
+        m_auiFeugenEncouter = uiData;
+        break;
     }
 
     if (uiData == DONE)
@@ -406,7 +617,8 @@ void instance_naxxramas::SetData(uint32 uiType, uint32 uiData)
             << m_auiEncounter[3] << " " << m_auiEncounter[4] << " " << m_auiEncounter[5] << " "
             << m_auiEncounter[6] << " " << m_auiEncounter[7] << " " << m_auiEncounter[8] << " "
             << m_auiEncounter[9] << " " << m_auiEncounter[10] << " " << m_auiEncounter[11] << " "
-            << m_auiEncounter[12] << " " << m_auiEncounter[13] << " " << m_auiEncounter[14];
+            << m_auiEncounter[12] << " " << m_auiEncounter[13] << " " << m_auiEncounter[14] << " " 
+            << m_auiEncounter[15];
 
         strInstData = saveStream.str();
 
@@ -427,9 +639,9 @@ void instance_naxxramas::Load(const char* chrIn)
 
     std::istringstream loadStream(chrIn);
     loadStream >> m_auiEncounter[0] >> m_auiEncounter[1] >> m_auiEncounter[2] >> m_auiEncounter[3]
-        >> m_auiEncounter[4] >> m_auiEncounter[5] >> m_auiEncounter[6] >> m_auiEncounter[7]
-        >> m_auiEncounter[8] >> m_auiEncounter[9] >> m_auiEncounter[10] >> m_auiEncounter[11]
-        >> m_auiEncounter[12] >> m_auiEncounter[13] >> m_auiEncounter[14];
+    >> m_auiEncounter[4] >> m_auiEncounter[5] >> m_auiEncounter[6] >> m_auiEncounter[7]
+    >> m_auiEncounter[8] >> m_auiEncounter[9] >> m_auiEncounter[10] >> m_auiEncounter[11]
+    >> m_auiEncounter[12] >> m_auiEncounter[13] >> m_auiEncounter[14] >> m_auiEncounter[15];
 
     for(uint8 i = 0; i < MAX_ENCOUNTER; ++i)
     {
@@ -440,40 +652,121 @@ void instance_naxxramas::Load(const char* chrIn)
     OUT_LOAD_INST_DATA_COMPLETE;
 }
 
+void instance_naxxramas::Horseman()
+{
+    // check the 4 horseman and also check the other bosses in Military quaters
+    if (BlaumeuxDead && RivendareDead && ZeliekDead && KorthazzDead)
+    {
+        SetData(TYPE_FOUR_HORSEMEN, DONE);
+
+        // check if the other bosses in military are dead
+        if(m_auiEncounter[7] == DONE && m_auiEncounter[6] == DONE && this)
+            DoCompleteAchievement(instance->IsRegularDifficulty() ? ACHIEVEMENT_HORSEMEN : H_ACHIEVEMENT_HORSEMEN);
+    }
+}
+
+void instance_naxxramas::Arachnofobia()
+{
+    if(this)
+        DoCompleteAchievement(instance->IsRegularDifficulty() ? ACHIEV_ARACHNOFOBIA : ACHIEV_ARACHNOFOBIA_H);
+}
+
+void instance_naxxramas::Immortal()
+{
+    if(m_auiEncounter[15] != FAIL)
+    {
+        if(m_auiEncounter[14] == DONE && m_auiEncounter[12] == DONE && m_auiEncounter[2] == DONE && m_auiEncounter[5] == DONE && m_auiEncounter[8] == DONE)
+        {
+            if(this)
+                DoCompleteAchievement(instance->IsRegularDifficulty() ? ACHIEV_THE_UNDYING : ACHIEV_THE_IMMORTAL);
+        }
+    }
+}
+
+void instance_naxxramas::IsRaidWiped()
+{
+    Map::PlayerList const &players = instance->GetPlayers();
+    for (Map::PlayerList::const_iterator i = players.begin(); i != players.end(); ++i)
+    {
+        if(Player* pPlayer = i->getSource())
+        {
+            if(!pPlayer->isAlive())
+                m_auiEncounter[15] = FAIL;
+        }
+    }
+}
+
+void instance_naxxramas::Update(uint32 uiDiff)
+{
+    // Down they fall together achiev
+    if (BlaumeuxDead || RivendareDead || ZeliekDead || KorthazzDead)
+    {
+        if (DeadTimer < 15000 && UpdateCheck)
+        {
+            if (BlaumeuxDead && RivendareDead && ZeliekDead && KorthazzDead)
+            {
+                if(this)
+                    DoCompleteAchievement(instance->IsRegularDifficulty() ? ACHIEVEMENT_TOGETHER : H_ACHIEVEMENT_TOGETHER);
+
+                UpdateCheck = false;
+            }
+            else 
+                DeadTimer += uiDiff;
+        }
+    }
+
+    // Arachnofobia achiev
+    if(m_bIsArachnofobia)
+        m_uiArachnofobiaTimer += uiDiff;
+
+    // Immortal check
+    if (m_uiImmortaCheck < uiDiff)
+    {
+        IsRaidWiped();
+        m_uiImmortaCheck = 1000;
+    }else m_uiImmortaCheck -= uiDiff;
+}
+
 uint32 instance_naxxramas::GetData(uint32 uiType)
 {
     switch(uiType)
     {
-        case TYPE_ANUB_REKHAN:
-            return m_auiEncounter[0];
-        case TYPE_FAERLINA:
-            return m_auiEncounter[1];
-        case TYPE_MAEXXNA:
-            return m_auiEncounter[2];
-        case TYPE_NOTH:
-            return m_auiEncounter[3];
-        case TYPE_HEIGAN:
-            return m_auiEncounter[4];
-        case TYPE_LOATHEB:
-            return m_auiEncounter[5];
-        case TYPE_RAZUVIOUS:
-            return m_auiEncounter[6];
-        case TYPE_GOTHIK:
-            return m_auiEncounter[7];
-        case TYPE_FOUR_HORSEMEN:
-            return m_auiEncounter[8];
-        case TYPE_PATCHWERK:
-            return m_auiEncounter[9];
-        case TYPE_GROBBULUS:
-            return m_auiEncounter[10];
-        case TYPE_GLUTH:
-            return m_auiEncounter[11];
-        case TYPE_THADDIUS:
-            return m_auiEncounter[12];
-        case TYPE_SAPPHIRON:
-            return m_auiEncounter[13];
-        case TYPE_KELTHUZAD:
-            return m_auiEncounter[14];
+    case TYPE_ANUB_REKHAN:
+        return m_auiEncounter[0];
+    case TYPE_FAERLINA:
+        return m_auiEncounter[1];
+    case TYPE_MAEXXNA:
+        return m_auiEncounter[2];
+    case TYPE_NOTH:
+        return m_auiEncounter[3];
+    case TYPE_HEIGAN:
+        return m_auiEncounter[4];
+    case TYPE_LOATHEB:
+        return m_auiEncounter[5];
+    case TYPE_RAZUVIOUS:
+        return m_auiEncounter[6];
+    case TYPE_GOTHIK:
+        return m_auiEncounter[7];
+    case TYPE_FOUR_HORSEMEN:
+        return m_auiEncounter[8];
+    case TYPE_PATCHWERK:
+        return m_auiEncounter[9];
+    case TYPE_GROBBULUS:
+        return m_auiEncounter[10];
+    case TYPE_GLUTH:
+        return m_auiEncounter[11];
+    case TYPE_THADDIUS:
+        return m_auiEncounter[12];
+    case TYPE_SAPPHIRON:
+        return m_auiEncounter[13];
+    case TYPE_KELTHUZAD:
+        return m_auiEncounter[14];
+    case TYPE_IMMORTAL:
+        return m_auiEncounter[15];
+    case TYPE_STALAGG: 
+        return m_auiStalaggEncounter;
+    case TYPE_FEUGEN:
+        return m_auiFeugenEncouter;
     }
     return 0;
 }
@@ -482,28 +775,32 @@ uint64 instance_naxxramas::GetData64(uint32 uiData)
 {
     switch(uiData)
     {
-        case NPC_ANUB_REKHAN:
-            return m_uiAnubRekhanGUID;
-        case NPC_FAERLINA:
-            return m_uiFaerlinanGUID;
-        case GO_MILI_GOTH_COMBAT_GATE:
-            return m_uiGothCombatGateGUID;
-        case NPC_ZELIEK:
-            return m_uiZeliekGUID;
-        case NPC_THANE:
-            return m_uiThaneGUID;
-        case NPC_BLAUMEUX:
-            return m_uiBlaumeuxGUID;
-        case NPC_RIVENDARE:
-            return m_uiRivendareGUID;
-        case NPC_THADDIUS:
-            return m_uiThaddiusGUID;
-        case NPC_STALAGG:
-            return m_uiStalaggGUID;
-        case NPC_FEUGEN:
-            return m_uiFeugenGUID;
-        case NPC_GOTHIK:
-            return m_uiGothikGUID;
+    case NPC_ANUB_REKHAN:
+        return m_uiAnubRekhanGUID;
+    case NPC_FAERLINA:
+        return m_uiFaerlinanGUID;
+    case GO_MILI_GOTH_COMBAT_GATE:
+        return m_uiGothCombatGateGUID;
+    case NPC_ZELIEK:
+        return m_uiZeliekGUID;
+    case NPC_THANE:
+        return m_uiThaneGUID;
+    case NPC_BLAUMEUX:
+        return m_uiBlaumeuxGUID;
+    case NPC_RIVENDARE:
+        return m_uiRivendareGUID;
+    case NPC_THADDIUS:
+        return m_uiThaddiusGUID;
+    case NPC_STALAGG:
+        return m_uiStalaggGUID;
+    case NPC_FEUGEN:
+        return m_uiFeugenGUID;
+    case GO_CONS_NOX_TESLA_FEUGEN:
+        return m_uiThadNoxTeslaFeugenGUID;
+    case GO_CONS_NOX_TESLA_STALAGG:
+        return m_uiThadNoxTeslaStalaggGUID;
+    case NPC_GOTHIK:
+        return m_uiGothikGUID;
     }
     return 0;
 }
@@ -570,6 +867,7 @@ void instance_naxxramas::GetGothSummonPointCreatures(std::list<Creature*> &lList
 
 bool instance_naxxramas::IsInRightSideGothArea(Unit* pUnit)
 {
+    // return true if on undead side
     if (GameObject* pCombatGate = instance->GetGameObject(m_uiGothCombatGateGUID))
         return (pCombatGate->GetPositionY() >= pUnit->GetPositionY());
 
@@ -606,6 +904,17 @@ bool AreaTrigger_at_naxxramas(Player* pPlayer, AreaTriggerEntry* pAt)
         }
     }
 
+    if (pAt->id == AREATRIGGER_THADDIUS_DOOR)
+    {
+        if (instance_naxxramas* pInstance = (instance_naxxramas*)pPlayer->GetInstanceData())
+            if (pInstance->GetData(TYPE_THADDIUS) == NOT_STARTED)
+                if (Creature* pThaddius = pInstance->instance->GetCreature(pInstance->GetData64(NPC_THADDIUS)))
+                {
+                    pInstance->SetData(TYPE_THADDIUS, SPECIAL);
+                    DoScriptText(SAY_THADDIUS_GREET, pThaddius);
+                }
+    }
+
     return false;
 }
 
@@ -622,4 +931,9 @@ void AddSC_instance_naxxramas()
     pNewScript->Name = "at_naxxramas";
     pNewScript->pAreaTrigger = &AreaTrigger_at_naxxramas;
     pNewScript->RegisterSelf();
+
+    pNewScript = new Script;
+    pNewScript->Name = "go_naxxTeleporter";
+    pNewScript->pGOHello = &GOHello_go_naxxTeleporter;
+    pNewScript->RegisterSelf();
 }
diff --git a/scripts/northrend/naxxramas/naxxramas.h b/scripts/northrend/naxxramas/naxxramas.h
index 27ad23c..d4797fd 100644
--- a/scripts/northrend/naxxramas/naxxramas.h
+++ b/scripts/northrend/naxxramas/naxxramas.h
@@ -7,7 +7,7 @@
 
 enum
 {
-    MAX_ENCOUNTER               = 15,
+    MAX_ENCOUNTER               = 16,
 
     TYPE_ANUB_REKHAN            = 1,
     TYPE_FAERLINA               = 2,
@@ -31,12 +31,22 @@ enum
     TYPE_SAPPHIRON              = 16,
     TYPE_KELTHUZAD              = 17,
 
+    //Misc
+    TYPE_KORTHAZZ,
+    TYPE_BLAUMEAUX,
+    TYPE_ZELIEK,
+    TYPE_RIVENDARE,
+
+    TYPE_IMMORTAL,
+
     NPC_ANUB_REKHAN             = 15956,
     NPC_FAERLINA                = 15953,
+    NPC_LOATHEB                 = 16011,
 
     NPC_THADDIUS                = 15928,
     NPC_STALAGG                 = 15929,
     NPC_FEUGEN                  = 15930,
+    NPC_TESLA_COIL              = 16218,
 
     NPC_ZELIEK                  = 16063,
     NPC_THANE                   = 16064,
@@ -78,7 +88,7 @@ enum
     GO_PLAG_LOAT_DOOR           = 181241,                   //encounter door
 
     // Military Quarter
-    GO_MILI_GOTH_ENTRY_GATE     = 181124,                   //used while encounter is in progress
+    GO_MILI_GOTH_ENTRY_GATE     = 181124,                   //open after razuvious died
     GO_MILI_GOTH_EXIT_GATE      = 181125,                   //exit, open at boss dead
     GO_MILI_GOTH_COMBAT_GATE    = 181170,                   //used while encounter is in progress
     GO_MILI_HORSEMEN_DOOR       = 181119,                   //encounter door
@@ -89,16 +99,23 @@ enum
     // Construct Quarter
     GO_CONS_PATH_EXIT_DOOR      = 181123,
     GO_CONS_GLUT_EXIT_DOOR      = 181120,
+    GO_CONS_NOX_TESLA_FEUGEN    = 181477,
+    GO_CONS_NOX_TESLA_STALAGG   = 181478,
     GO_CONS_THAD_DOOR           = 181121,                   // Thaddius enc door
 
     // Frostwyrm Lair
     GO_KELTHUZAD_WATERFALL_DOOR = 181225,                   // exit, open after sapphiron is dead
+    GO_KELTHUZAD_COMBAT_GATE    = 181228,
 
     // Eyes
     GO_ARAC_EYE_RAMP            = 181212,
     GO_PLAG_EYE_RAMP            = 181211,
     GO_MILI_EYE_RAMP            = 181210,
     GO_CONS_EYE_RAMP            = 181213,
+    GO_ARAC_EYE                 = 181233,
+    GO_PLAG_EYE                 = 181231,
+    GO_MILI_EYE                 = 181230,
+    GO_CONS_EYE                 = 181232,
 
     // Portals
     GO_ARAC_PORTAL              = 181575,
@@ -108,7 +125,21 @@ enum
 
     AREATRIGGER_FROSTWYRM       = 4120,                    //not needed here, but AT to be scripted
     AREATRIGGER_KELTHUZAD       = 4112,
-    AREATRIGGER_GOTHIK          = 4116
+    AREATRIGGER_GOTHIK          = 4116,
+    AREATRIGGER_THADDIUS_DOOR   = 4113,
+    SAY_THADDIUS_GREET          = -1533029,
+
+    ACHIEVEMENT_HORSEMEN        = 568,
+    H_ACHIEVEMENT_HORSEMEN      = 569,
+    ACHIEVEMENT_TOGETHER        = 2176,
+    H_ACHIEVEMENT_TOGETHER      = 2177,
+
+    ACHIEV_ARACHNOFOBIA         = 1858,
+    ACHIEV_ARACHNOFOBIA_H       = 1859,
+
+    // counts for: Thaddius, 4 horseman, maexxna, loatheb, kelthuzad
+    ACHIEV_THE_UNDYING          = 2187, // on 10 man
+    ACHIEV_THE_IMMORTAL         = 2186, // on 25 man
 };
 
 struct GothTrigger
@@ -136,6 +167,7 @@ class MANGOS_DLL_DECL instance_naxxramas : public ScriptedInstance
 
         const char* Save() { return strInstData.c_str(); }
         void Load(const char* chrIn);
+        void Update(uint32 uiDiff);
 
         // goth
         void SetGothTriggers();
@@ -143,6 +175,9 @@ class MANGOS_DLL_DECL instance_naxxramas : public ScriptedInstance
         void GetGothSummonPointCreatures(std::list<Creature*> &lList, bool bRightSide);
         bool IsInRightSideGothArea(Unit* pUnit);
 
+        // thaddius
+        void GetThadTeslaCreatures(std::list<uint64> &lList){ lList = m_lThadTeslaCoilList; };
+
         // kel
         void SetChamberCenterCoords(float fX, float fY, float fZ);
         void GetChamberCenterCoords(float &fX, float &fY, float &fZ) { fX = m_fChamberCenterX; fY = m_fChamberCenterY; fZ = m_fChamberCenterZ; }
@@ -161,6 +196,11 @@ class MANGOS_DLL_DECL instance_naxxramas : public ScriptedInstance
         uint64 m_uiMiliPortalGUID;
         uint64 m_uiConsPortalGUID;
 
+        uint64 m_uiAracEyeGUID;
+        uint64 m_uiPlagEyeGUID;
+        uint64 m_uiMiliEyeGUID;
+        uint64 m_uiConsEyeGUID;
+
         uint64 m_uiAnubRekhanGUID;
         uint64 m_uiFaerlinanGUID;
 
@@ -176,6 +216,9 @@ class MANGOS_DLL_DECL instance_naxxramas : public ScriptedInstance
         uint64 m_uiPathExitDoorGUID;
         uint64 m_uiGlutExitDoorGUID;
         uint64 m_uiThadDoorGUID;
+        std::list<uint64> m_lThadTeslaCoilList;
+        uint64 m_uiThadNoxTeslaFeugenGUID;
+        uint64 m_uiThadNoxTeslaStalaggGUID;
 
         uint64 m_uiAnubDoorGUID;
         uint64 m_uiAnubGateGUID;
@@ -201,9 +244,34 @@ class MANGOS_DLL_DECL instance_naxxramas : public ScriptedInstance
         uint64 m_uiLoathebDoorGUID;
 
         uint64 m_uiKelthuzadDoorGUID;
+        uint64 m_uiKelthuzadWaterfallDoorGUID;
         float m_fChamberCenterX;
         float m_fChamberCenterY;
         float m_fChamberCenterZ;
+
+        bool BlaumeuxDead;
+        bool RivendareDead;
+        bool ZeliekDead;
+        bool KorthazzDead;
+        uint32 m_auiStalaggEncounter;
+        uint32 m_auiFeugenEncouter;
+
+        int32 DeadTimer;
+        uint32 HorsemanDeadCount;
+        bool UpdateCheck;
+
+        uint32 m_uiArachnofobiaTimer;
+        bool m_bIsArachnofobia;
+
+        uint32 m_uiImmortaCheck;
+
+        void CloseDoor(uint64 guid);
+        void OpenDoor(uint64 guid);
+
+        void Horseman();
+        void IsRaidWiped();
+        void Immortal();
+        void Arachnofobia();
 };
 
 #endif
diff --git a/sql/Custom_Updates/Mangos/Northrend/Naxxramas_Mangos.sql b/sql/Custom_Updates/Mangos/Northrend/Naxxramas_Mangos.sql
new file mode 100644
index 0000000..597092a
--- /dev/null
+++ b/sql/Custom_Updates/Mangos/Northrend/Naxxramas_Mangos.sql
@@ -0,0 +1,52 @@
+/* NAXXRAMAS */
+UPDATE creature_template SET ScriptName = "npc_stalagg" WHERE entry= 15929;
+UPDATE creature_template SET ScriptName = "npc_feugen" WHERE entry= 15930;
+UPDATE creature_template SET ScriptName = "boss_thaddius"  WHERE entry= 15928;
+UPDATE creature_template SET ScriptName = "npc_tesla_coil" WHERE entry = 16218;
+-- spawn two dummies for teslas
+UPDATE creature_template SET InhabitType=4 WHERE entry = 16218;
+DELETE FROM creature WHERE id = 16218;
+INSERT INTO creature VALUES (800020,16218,533,1,1,0,0,3487.17,-2911.54,319.417,5.71991,25,2,0,300,0,0,1);
+INSERT INTO creature VALUES (800021,16218,533,1,1,0,0,3527.79,-2952.2,319.422,4.16378,25,2,0,300,0,0,1);
+
+DELETE FROM spell_script_target WHERE entry in (28087, 28096, 28111, 28159);
+INSERT INTO spell_script_target VALUES
+(28159, 1, 15928),
+(28087, 1, 16218),
+(28096, 1, 15929),
+(28111, 1, 15930);
+
+DELETE FROM areatrigger_scripts WHERE entry = 4113;
+INSERT INTO areatrigger_scripts VALUES
+(4113, 'at_naxxramas');
+
+DELETE FROM scriptdev2.script_texts WHERE entry BETWEEN -1533149 AND -1533147;
+INSERT INTO scriptdev2.script_texts (entry,content_default,sound,type,language,emote,comment) VALUES
+(-1533147,'%s loses its link!',0,3,0,0,'tesla_coil EMOTE_LOSING_LINK'),
+(-1533148,'%s overloads!',0,3,0,0,'tesla_coil EMOTE_TESLA_OVERLOAD'),
+(-1533149,'The polarity has shifted!',0,3,0,0,'thaddius EMOTE_POLARITY_SHIFT');
+
+UPDATE `gameobject` SET `state` = 1 WHERE `guid` = 73469;
+UPDATE `gameobject_template` SET `faction` = 114, `data0` = '1' where `entry` in (194022, 181195, 181228, 181225, 181201, 181200);
+UPDATE `gameobject_template` SET `faction` = 114 where `entry` in (181234, 181169, 181168, 181477, 181478);
+-- portals
+UPDATE `gameobject_template` SET `faction` = 114 where `entry` in (181212, 181211, 181210, 181213);
+update `gameobject_template` set `ScriptName` = 'go_naxxTeleporter' where entry in (181575, 181577, 181578, 181576);
+-- Zombie crow, Gluth
+Update `creature_template` set `ScriptName` = 'mob_zombie_chows' where `entry` = 16360;
+Update `creature_template` set `ScriptName` = 'mob_worshippers' where `entry` = 16506;
+Update `creature_template` set `ScriptName` = 'mob_unstoppable_abomination' where `entry` = 16428;
+-- Grobbulus
+Update `creature_template` set `ScriptName` = 'npc_grobbulus_poison_cloud' where `entry` = 16363;
+Update `creature_template` set `ScriptName` = 'boss_grobbulus' where `entry` = 15931;
+-- Loatheb
+Update `creature_template` set `ScriptName` = 'npc_loatheb_spores' where `entry` = 16286;
+-- Noth: fix guardians hp
+Update `creature_template` set `minhealth` = 104264, `maxhealth` = 104264 where `entry` = 16983;
+Update `creature_template` set `minhealth` = 104264, `maxhealth` = 104264 where `entry` = 16984;
+-- Razu
+Update `creature_template` set npcFlag =1, unit_flags = 68, `ScriptName` = 'npc_obedience_crystal' where `entry` = 29912;
+-- enable los for gothik door
+Update `gameobject_template` set data10 = 1 where `entry` = 181170;
+UPDATE creature_template SET `unk16` = 200, `type_flags` = 1024 WHERE entry in (30641, 16129);
+UPDATE creature_template SET `faction_A` = 14, `faction_H` = 14 WHERE entry = 16363;
\ No newline at end of file

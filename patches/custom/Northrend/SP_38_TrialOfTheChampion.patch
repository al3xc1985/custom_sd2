diff --git a/Makefile.am b/Makefile.am
index c45e8f1..c39565b 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -345,6 +345,12 @@ scripts/northrend/azjol-nerub/azjol-nerub/boss_anubarak.cpp \
 scripts/northrend/azjol-nerub/azjol-nerub/boss_hadronox.cpp \
 scripts/northrend/azjol-nerub/azjol-nerub/boss_krikthir.cpp \
 scripts/northrend/azjol-nerub/azjol-nerub/instance_azjol-nerub.cpp \
+scripts/northrend/crusaders_coliseum/trial_of_the_champion/boss_argent_challenge.cpp \
+scripts/northrend/crusaders_coliseum/trial_of_the_champion/boss_black_knight.cpp \
+scripts/northrend/crusaders_coliseum/trial_of_the_champion/boss_grand_champions.cpp \
+scripts/northrend/crusaders_coliseum/trial_of_the_champion/instance_trial_of_the_champion.cpp \
+scripts/northrend/crusaders_coliseum/trial_of_the_champion/trial_of_the_champion.cpp \
+scripts/northrend/crusaders_coliseum/trial_of_the_champion/trial_of_the_champion.h \
 scripts/northrend/crusaders_coliseum/trial_of_the_crusader/boss_anubarak_trial.cpp \
 scripts/northrend/crusaders_coliseum/trial_of_the_crusader/boss_faction_champions.cpp \
 scripts/northrend/crusaders_coliseum/trial_of_the_crusader/boss_jaraxxus.cpp \
diff --git a/VC90/90ScriptDev2.vcproj b/VC90/90ScriptDev2.vcproj
index 2dbb82c..46f8f4d 100644
--- a/VC90/90ScriptDev2.vcproj
+++ b/VC90/90ScriptDev2.vcproj
@@ -591,6 +591,10 @@
 					Name="blackrock_spire"
 					>
 					<File
+						RelativePath="..\scripts\eastern_kingdoms\blackrock_spire\blackrock_spire.h"
+						>
+					</File>
+					<File
 						RelativePath="..\scripts\eastern_kingdoms\blackrock_spire\boss_drakkisath.cpp"
 						>
 					</File>
@@ -642,10 +646,6 @@
 						RelativePath="..\scripts\eastern_kingdoms\blackrock_spire\instance_blackrock_spire.cpp"
 						>
 					</File>
-					<File
-						RelativePath="..\scripts\eastern_kingdoms\blackrock_spire\blackrock_spire.h"
-						>
-					</File>
 				</Filter>
 				<Filter
 					Name="blackwing_lair"
@@ -1769,6 +1769,30 @@
 					<Filter
 						Name="trial_of_the_champion"
 						>
+						<File
+							RelativePath="..\scripts\northrend\crusaders_coliseum\trial_of_the_champion\boss_argent_challenge.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\crusaders_coliseum\trial_of_the_champion\boss_black_knight.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\crusaders_coliseum\trial_of_the_champion\boss_grand_champions.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\crusaders_coliseum\trial_of_the_champion\instance_trial_of_the_champion.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\crusaders_coliseum\trial_of_the_champion\trial_of_the_champion.cpp"
+							>
+						</File>
+						<File
+							RelativePath="..\scripts\northrend\crusaders_coliseum\trial_of_the_champion\trial_of_the_champion.h"
+							>
+						</File>
 					</Filter>
 					<Filter
 						Name="trial_of_the_crusader"
diff --git a/scripts/northrend/crusaders_coliseum/trial_of_the_champion/boss_argent_challenge.cpp b/scripts/northrend/crusaders_coliseum/trial_of_the_champion/boss_argent_challenge.cpp
new file mode 100644
index 0000000..4e62d14
--- /dev/null
+++ b/scripts/northrend/crusaders_coliseum/trial_of_the_champion/boss_argent_challenge.cpp
@@ -0,0 +1,657 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: boss_argent_challenge
+SD%Complete: 92%
+SDComment: missing yells. radiance is "wrong"
+SDCategory: Trial Of the Champion
+EndScriptData */
+
+#include "precompiled.h"
+#include "trial_of_the_champion.h"
+
+enum Spells
+{
+    // yells
+    SAY_EADRIC_AGGRO            = -1614011,
+    SAY_EADRIC_HAMMER           = -1614012,
+    SAY_EADRIC_KILL1            = -1614013,
+    SAY_EADRIC_KILL2            = -1614014,
+    SAY_EADRIC_DEFEAT           = -1614015,
+
+    SAY_PALETRESS_AGGRO         = -1614022,
+    SAY_SUMMON_MEMORY           = -1614023,
+    SAY_MEMORY_DIES             = -1614024,
+    SAY_PALETRESS_KILL1         = -1614025,
+    SAY_PALETRESS_KILL2         = -1614026,
+    SAY_PALETRESS_DEFEAT        = -1614027,
+
+    //eadric
+    SPELL_VENGEANCE             = 66889,
+    SPELL_RADIANCE_TRIG         = 66935,
+    SPELL_RADIANCE              = 66862,
+    SPELL_RADIANCE_H            = 67681,
+    SPELL_HAMMER_OF_JUSTICE     = 66863,
+    SPELL_STUN_AURA             = 66940,
+    SPELL_HAMMER                = 66867,
+    SPELL_HAMMER_DMG            = 66903,
+    SPELL_HAMMER_DMG_H          = 67680,
+    //paletress
+    SPELL_SMITE                 = 66536,
+    SPELL_SMITE_H               = 67674,
+    SPELL_HOLY_FIRE             = 66538,
+    SPELL_HOLY_FIRE_H           = 67676,
+    SPELL_RENEW                 = 66537,
+    SPELL_RENEW_H               = 67675,
+    SPELL_HOLY_NOVA             = 66546,
+    SPELL_SHIELD                = 66515,
+    SPELL_CONFESS               = 66680,
+    //memory
+    SPELL_FEAR                  = 66552,
+    SPELL_FEAR_H                = 67677,
+    SPELL_SHADOWS               = 66619,
+    SPELL_SHADOWS_H             = 67678,
+    SPELL_OLD_WOUNDS            = 66620,
+    SPELL_OLD_WOUNDS_H          = 67679,
+
+    ACHIEV_FACEROLLER           = 3803,
+    ACHIEV_ARGENT_CONFESSOR     = 3802,
+};
+
+// Eadric The Pure
+struct MANGOS_DLL_DECL boss_eadricAI: public ScriptedAI
+{
+    boss_eadricAI(Creature* pCreature): ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_bHasFlag = true;
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    bool m_bHasFlag;
+    uint32 m_uiCheckDelay;
+
+    uint32 m_uiVengeance_Timer;
+    uint32 m_uiRadiance_Timer;
+    uint32 m_uiHammerJustice_Timer;
+    uint32 m_uiHammer_Dmg_Timer;
+    uint32 m_uiHammerVisualTimer;
+    uint64 m_uiHammerTargetGUID;
+
+    void Reset()
+    {
+        m_uiCheckDelay          = 20000;
+        m_uiVengeance_Timer     = 1000;
+        m_uiRadiance_Timer      = 15000;
+        m_uiHammerJustice_Timer = 40000;
+        m_uiHammerVisualTimer   = 42500;
+        m_uiHammer_Dmg_Timer    = 45000;
+        m_uiHammerTargetGUID    = 0;
+        m_creature->SetRespawnDelay(DAY);
+    }
+
+    void JustReachedHome()
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ARGENT_CHALLENGE, NOT_STARTED);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        switch(urand(0, 1))
+        {
+        case 0: DoScriptText(SAY_EADRIC_KILL1, m_creature); break;
+        case 1: DoScriptText(SAY_EADRIC_KILL2, m_creature); break;
+        }
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!m_pInstance)  
+            return;
+
+        if (m_pInstance->GetData(TYPE_ARGENT_CHALLENGE) != IN_PROGRESS) 
+            return;
+
+        if (m_creature->Attack(pWho, true)) 
+        {
+            m_creature->AddThreat(pWho);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+        }
+    }
+
+    void Aggro(Unit *pWho)
+    {
+        DoScriptText(SAY_EADRIC_AGGRO, m_creature);
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ARGENT_CHALLENGE, IN_PROGRESS);
+    }
+
+    void JustDied(Unit *pKiller)
+    {
+        DoScriptText(SAY_EADRIC_DEFEAT, m_creature);
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_ARGENT_CHALLENGE, DONE);
+            m_pInstance->SetData(TYPE_STAGE, 0);
+
+            if(Creature* pAnnoucer = GetClosestCreatureWithEntry(m_creature, NPC_JAEREN, 180.0f))
+            {
+                pAnnoucer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                pAnnoucer->SetVisibility(VISIBILITY_ON);
+            }
+
+            if(Creature* pAnnoucer = GetClosestCreatureWithEntry(m_creature, NPC_ARELAS, 180.0f))
+            {
+                pAnnoucer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                pAnnoucer->SetVisibility(VISIBILITY_ON);
+            }
+        }
+    }
+
+    bool IsThereAnyTrash()
+    {
+        if(GetClosestCreatureWithEntry(m_creature, NPC_ARGENT_LIGHTWIELDER, 180.0f))
+            return true;
+        if(GetClosestCreatureWithEntry(m_creature, NPC_ARGENT_MONK, 180.0f))
+            return true;
+        if(GetClosestCreatureWithEntry(m_creature, NPC_ARGENT_PRIESTESS, 180.0f))
+            return true;
+ 
+        return false;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if(m_uiCheckDelay < uiDiff)
+        {
+            if (!IsThereAnyTrash() && m_bHasFlag)
+            {
+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                m_bHasFlag = false;
+            }
+        }
+        else m_uiCheckDelay -= uiDiff;
+
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiVengeance_Timer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_VENGEANCE);
+            m_uiVengeance_Timer = 12000;
+        }
+        else
+            m_uiVengeance_Timer -= uiDiff;  
+
+        if (m_uiRadiance_Timer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_RADIANCE_TRIG);
+            //DoCast(m_creature, m_bIsRegularMode ? SPELL_RADIANCE : SPELL_RADIANCE_H);
+            m_uiRadiance_Timer = urand(15000, 20000);
+        }
+        else
+            m_uiRadiance_Timer -= uiDiff;
+
+        if (m_uiHammerJustice_Timer < uiDiff)
+        {
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+            {
+                DoCast(pTarget, SPELL_HAMMER_OF_JUSTICE);
+                m_uiHammerTargetGUID = pTarget->GetGUID();
+            }
+            m_uiHammerVisualTimer = 2000;
+            m_uiHammerJustice_Timer = 40000;
+        }
+        else
+            m_uiHammerJustice_Timer -= uiDiff;
+
+        if (m_uiHammerVisualTimer < uiDiff)
+        {
+            DoScriptText(SAY_EADRIC_HAMMER, m_creature);
+            if (Unit* pHammerTarget = Unit::GetUnit(*m_creature, m_uiHammerTargetGUID))
+                DoCast(pHammerTarget, SPELL_HAMMER);
+            m_uiHammer_Dmg_Timer = 2500;
+            m_uiHammerVisualTimer = 40000;
+        }
+        else
+            m_uiHammerVisualTimer -= uiDiff;
+
+        if (m_uiHammer_Dmg_Timer < uiDiff)
+        {
+            if (Unit* pHammerTarget = Unit::GetUnit(*m_creature, m_uiHammerTargetGUID))
+            {
+                if(pHammerTarget->HasAura(SPELL_STUN_AURA, EFFECT_INDEX_0))
+                    DoCast(pHammerTarget, m_bIsRegularMode ? SPELL_HAMMER_DMG : SPELL_HAMMER_DMG_H);
+            }
+            m_uiHammer_Dmg_Timer = 40000;
+        }
+        else m_uiHammer_Dmg_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+// Argent Confessor Paletress
+struct MANGOS_DLL_DECL boss_paletressAI: public ScriptedAI
+{
+    boss_paletressAI(Creature* pCreature): ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_bHasFlag = true;
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    bool m_bHasFlag;
+    uint32 m_uiCheckDelay;
+
+    uint32 m_uiSmite_Timer;
+    uint32 m_uiHoly_Fire_Timer;
+    uint32 m_uiRenew_Timer;
+    uint32 m_uiShield_Delay;
+    uint32 m_uiMemoryEntry;
+    uint64 m_uiMemoryGUID;
+
+    bool m_bHasSummoned;
+    bool m_bHasShielded;
+
+    void Reset()
+    {
+        m_uiCheckDelay          = 20000;
+        m_uiSmite_Timer         = 5000;
+        m_uiHoly_Fire_Timer     = 10000;
+        m_uiRenew_Timer         = 7000;
+        m_uiShield_Delay        = 0;
+        m_uiMemoryEntry         = SelectRandomMemory();
+        m_uiMemoryGUID          = 0;
+        m_bHasSummoned          = false;
+        m_bHasShielded          = false;
+        m_creature->RemoveAurasDueToSpell(SPELL_SHIELD);
+        m_creature->SetRespawnDelay(DAY);
+    }
+
+    void JustReachedHome()
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ARGENT_CHALLENGE, NOT_STARTED);
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        switch(urand(0, 1))
+        {
+        case 0: DoScriptText(SAY_PALETRESS_KILL1, m_creature); break;
+        case 1: DoScriptText(SAY_PALETRESS_KILL2, m_creature); break;
+        }
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!m_pInstance)  
+            return;
+
+        if (m_pInstance->GetData(TYPE_ARGENT_CHALLENGE) != IN_PROGRESS) 
+            return;
+
+        if (m_creature->Attack(pWho, true)) 
+        {
+            m_creature->AddThreat(pWho);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+        }
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        DoScriptText(SAY_PALETRESS_AGGRO, m_creature);
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ARGENT_CHALLENGE, IN_PROGRESS);
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        DoScriptText(SAY_PALETRESS_DEFEAT, m_creature);
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_ARGENT_CHALLENGE, DONE);
+            m_pInstance->SetData(TYPE_STAGE, 0);
+
+            if(Creature* pAnnoucer = GetClosestCreatureWithEntry(m_creature, NPC_JAEREN, 180.0f))
+            {
+                pAnnoucer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                pAnnoucer->SetVisibility(VISIBILITY_ON);
+            }
+
+            if(Creature* pAnnoucer = GetClosestCreatureWithEntry(m_creature, NPC_ARELAS, 180.0f))
+            {
+                pAnnoucer->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+                pAnnoucer->SetVisibility(VISIBILITY_ON);
+            }
+        }
+    }
+
+    bool IsThereAnyTrash()
+    {
+        if(GetClosestCreatureWithEntry(m_creature, NPC_ARGENT_LIGHTWIELDER, 180.0f))
+            return true;
+        if(GetClosestCreatureWithEntry(m_creature, NPC_ARGENT_MONK, 180.0f))
+            return true;
+        if(GetClosestCreatureWithEntry(m_creature, NPC_ARGENT_PRIESTESS, 180.0f))
+            return true;
+ 
+        return false;
+    }
+
+    uint32 SelectRandomMemory()
+    {
+        uint32 m_uiEntry = 0;
+        switch(urand(0, 24))
+        {
+        case 0:
+            m_uiEntry = MEMORY_ALGALON;
+            break;
+        case 1:
+            m_uiEntry = MEMORY_ARCHIMONDE;
+            break;
+        case 2:
+            m_uiEntry = MEMORY_CHROMAGGUS;
+            break;
+        case 3:
+            m_uiEntry = MEMORY_CYANIGOSA;
+            break;
+        case 4:
+            m_uiEntry = MEMORY_DELRISSA;
+            break;
+        case 5:
+            m_uiEntry = MEMORY_ECK;
+            break;
+        case 6:
+            m_uiEntry = MEMORY_ENTROPIUS;
+            break;
+        case 7:
+            m_uiEntry = MEMORY_GRUUL;
+            break;
+        case 8:
+            m_uiEntry = MEMORY_HAKKAR;
+            break;
+        case 9:
+            m_uiEntry = MEMORY_HEIGAN;
+            break;
+        case 10:
+            m_uiEntry = MEMORY_HEROD;
+            break;
+        case 11:
+            m_uiEntry = MEMORY_HOGGER;
+            break;
+        case 12:
+            m_uiEntry = MEMORY_IGNIS;
+            break;
+        case 13:
+            m_uiEntry = MEMORY_ILLIDAN;
+            break;
+        case 14:
+            m_uiEntry = MEMORY_INGVAR;
+            break;
+        case 15:
+            m_uiEntry = MEMORY_KALITHRESH;
+            break;
+        case 16:
+            m_uiEntry = MEMORY_LUCIFRON;
+            break;
+        case 17:
+            m_uiEntry = MEMORY_MALCHEZAAR;
+            break;
+        case 18:
+            m_uiEntry = MEMORY_MUTANUS;
+            break;
+        case 19:
+            m_uiEntry = MEMORY_ONYXIA;
+            break;
+        case 20:
+            m_uiEntry = MEMORY_THUNDERAAN;
+            break;
+        case 21:
+            m_uiEntry = MEMORY_VANCLEEF;
+            break;
+        case 22:
+            m_uiEntry = MEMORY_VASHJ;
+            break;
+        case 23:
+            m_uiEntry = MEMORY_VEKNILASH;
+            break;
+        case 24:
+            m_uiEntry = MEMORY_VEZAX;
+            break;
+        }
+        return m_uiEntry;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if(m_uiCheckDelay < uiDiff)
+        {
+            if (!IsThereAnyTrash() && m_bHasFlag)
+            {
+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                m_bHasFlag = false;
+            }
+        }
+        else m_uiCheckDelay -= uiDiff;
+
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiSmite_Timer < uiDiff)
+        {
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_SMITE : SPELL_SMITE_H);
+            m_uiSmite_Timer = 2000;
+        }
+        else
+            m_uiSmite_Timer -= uiDiff;  
+
+        if (m_uiHoly_Fire_Timer < uiDiff)
+        {
+            m_creature->InterruptNonMeleeSpells(true);
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_HOLY_FIRE : SPELL_HOLY_FIRE_H);
+            m_uiHoly_Fire_Timer = 10000;
+        }
+        else
+            m_uiHoly_Fire_Timer -= uiDiff;
+
+        if (m_uiRenew_Timer < uiDiff)
+        {
+            m_creature->InterruptNonMeleeSpells(true);
+            switch(urand(0, 1))
+            {
+            case 0:
+                if (Creature* pTemp = m_pInstance->instance->GetCreature(m_uiMemoryGUID))
+                {
+                    if (pTemp->isAlive())
+                        DoCast(pTemp, m_bIsRegularMode ? SPELL_RENEW : SPELL_RENEW_H);
+                    else
+                        DoCast(m_creature, m_bIsRegularMode ? SPELL_RENEW : SPELL_RENEW_H);
+                }
+                else
+                    DoCast(m_creature, m_bIsRegularMode ? SPELL_RENEW : SPELL_RENEW_H);
+                break;
+            case 1:
+                DoCast(m_creature, m_bIsRegularMode ? SPELL_RENEW : SPELL_RENEW_H);
+                break;
+            }
+            m_uiRenew_Timer = urand(20000, 25000);
+        }
+        else
+            m_uiRenew_Timer -= uiDiff;
+
+        if (!m_bHasSummoned && m_creature->GetHealthPercent() < 25.0f)
+        {
+            m_creature->InterruptNonMeleeSpells(true);
+            DoCast(m_creature, SPELL_HOLY_NOVA);
+            m_uiMemoryEntry = SelectRandomMemory();
+            if(m_uiMemoryEntry != 0)
+            {
+                DoScriptText(SAY_SUMMON_MEMORY, m_creature);
+                if (Creature* pSummon = m_creature->SummonCreature(m_uiMemoryEntry, 0, 0, 0, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 10000))
+                {
+                    pSummon->AddThreat(m_creature->getVictim());
+                    m_uiMemoryGUID = pSummon->GetGUID();
+                    if (pSummon->AI())
+                        pSummon->AI()->AttackStart(m_creature->getVictim());
+
+                }
+                m_bHasSummoned = true;
+                m_uiShield_Delay = 1000;
+            }
+        }
+
+        if (m_uiShield_Delay < uiDiff && !m_bHasShielded && m_bHasSummoned)
+        {
+            m_creature->InterruptNonMeleeSpells(true);
+            DoCast(m_creature, SPELL_SHIELD);
+            m_bHasShielded = true;
+        }
+        else
+            m_uiShield_Delay -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+// Summoned Memory
+struct MANGOS_DLL_DECL mob_toc_memoryAI: public ScriptedAI
+{
+    mob_toc_memoryAI(Creature* pCreature): ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiOld_Wounds_Timer;
+    uint32 m_uiShadows_Timer;
+    uint32 m_uiFear_Timer;
+
+    void Reset()
+    {
+        m_uiOld_Wounds_Timer    = 5000;
+        m_uiShadows_Timer       = 8000;
+        m_uiFear_Timer          = 13000;
+        m_creature->SetRespawnDelay(DAY);
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        if (Creature* pPaletress = GetClosestCreatureWithEntry(m_creature, NPC_PALETRESS, 200.0f))
+        {
+            if (pPaletress->isAlive())
+            {
+                pPaletress->RemoveAurasDueToSpell(SPELL_SHIELD);
+                DoScriptText(SAY_MEMORY_DIES, pPaletress);
+            }
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (m_pInstance && m_pInstance->GetData(TYPE_ARGENT_CHALLENGE) != IN_PROGRESS) 
+            m_creature->ForcedDespawn();
+
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiOld_Wounds_Timer < diff)
+        {
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_OLD_WOUNDS : SPELL_OLD_WOUNDS_H);
+            m_uiOld_Wounds_Timer = 10000;
+        }
+        else
+            m_uiOld_Wounds_Timer -= diff;  
+
+        if (m_uiFear_Timer < diff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_FEAR : SPELL_FEAR_H);
+            m_uiFear_Timer = 40000;
+        }
+        else
+            m_uiFear_Timer -= diff; 
+
+        if (m_uiShadows_Timer < diff)
+        {
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_SHADOWS : SPELL_SHADOWS_H);
+            m_uiShadows_Timer = 10000;
+        }
+        else
+            m_uiShadows_Timer -= diff; 
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_eadric(Creature* pCreature)
+{
+    return new boss_eadricAI(pCreature);
+}
+
+CreatureAI* GetAI_boss_paletress(Creature* pCreature)
+{
+    return new boss_paletressAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_toc_memory(Creature* pCreature)
+{
+    return new mob_toc_memoryAI(pCreature);
+}
+
+void AddSC_boss_argent_challenge()
+{
+    Script *NewScript;
+
+    NewScript = new Script;
+    NewScript->Name = "boss_eadric";
+    NewScript->GetAI = &GetAI_boss_eadric;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "boss_paletress";
+    NewScript->GetAI = &GetAI_boss_paletress;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_toc_memory";
+    NewScript->GetAI = &GetAI_mob_toc_memory;
+    NewScript->RegisterSelf();
+}
diff --git a/scripts/northrend/crusaders_coliseum/trial_of_the_champion/boss_black_knight.cpp b/scripts/northrend/crusaders_coliseum/trial_of_the_champion/boss_black_knight.cpp
new file mode 100644
index 0000000..80d1f45
--- /dev/null
+++ b/scripts/northrend/crusaders_coliseum/trial_of_the_champion/boss_black_knight.cpp
@@ -0,0 +1,613 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: boss_black_knight
+SD%Complete: 92%
+SDComment: missing yells. not sure about timers.
+SDCategory: Trial Of the Champion
+EndScriptData */
+
+#include "precompiled.h"
+#include "trial_of_the_champion.h"
+
+enum
+{
+    // yells
+    SAY_INTRO1                  = -1614032,
+    SAY_KILL_HERALD             = -1614033,
+    SAY_TIRION_INTRO            = -1614034,
+    SAY_INTRO2                  = -1614035,
+    SAY_INTRO3                  = -1614036,
+    SAY_AGGRO                   = -1614037,
+    SAY_PHASE2                  = -1614039,
+    SAY_PHASE3                  = -1614040,
+    SAY_KILL1                   = -1614041,
+    SAY_KILL2                   = -1614042,
+    SAY_DEATH                   = -1614043,
+    SAY_TIRION_OUTRO1           = -1614044,
+    SAY_TIRION_OUTRO2           = -1614045,
+
+    //undead
+    SPELL_PLAGUE_STRIKE         = 67724,
+    SPELL_PLAGUE_STRIKE_H       = 67884,
+    SPELL_ICY_TOUCH             = 67718,
+    SPELL_ICY_TOUCH_H           = 67881,
+    SPELL_OBLITERATE            = 67725,
+    SPELL_OBLITERATE_H          = 67883,
+    SPELL_DEATHS_RESPITE        = 68306,
+    //skeleton
+    SPELL_ARMY                  = 67761, 
+    SPELL_DESECRATION           = 67782,
+    SPELL_DESECRATION_SUMMON    = 67779,
+    NPC_DESECRATION_STALKER     = 35614,
+    SPELL_GHOUL_EXPLODE         = 67751,
+    //ghost
+    SPELL_DEATHS_BITE           = 67808,
+    SPELL_DEATHS_BITE_H         = 67875,
+    SPELL_MARKED_DEATH          = 67823,
+
+    //risen ghoul
+    SPELL_CLAW                  = 67879,
+    SPELL_EXPLODE               = 67729,
+    SPELL_EXPLODE_H             = 67886,
+    SPELL_LEAP                  = 67749,
+    SPELL_LEAP_H                = 67880,
+
+    //sword ID
+    EQUIP_SWORD                 = 40343,
+
+    ACHIEV_HAD_WORSE            = 3804,
+};
+
+// Risen Ghoul
+struct MANGOS_DLL_DECL mob_toc_risen_ghoulAI: public ScriptedAI
+{
+    mob_toc_risen_ghoulAI(Creature* pCreature): ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiSpellTimer;
+    uint32 m_uiCreatureEntry;
+    bool m_bHasExploded;
+
+    void Reset()
+    {
+        m_uiCreatureEntry = m_creature->GetEntry();
+        m_creature->SetRespawnDelay(DAY);
+        m_uiSpellTimer = 2500;
+        m_bHasExploded = false;
+    }
+
+    void DoExplode()
+    {
+        DoCast(m_creature, m_bIsRegularMode ? SPELL_EXPLODE : SPELL_EXPLODE_H);
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        if (m_pInstance && m_pInstance->GetData(TYPE_BLACK_KNIGHT) != IN_PROGRESS)
+            m_pInstance->SetData(TYPE_BLACK_KNIGHT, IN_PROGRESS);
+        if(Creature* pKnight = GetClosestCreatureWithEntry(m_creature, NPC_BLACK_KNIGHT, 180.0f))
+            pKnight->AI()->AttackStart(m_creature->getVictim());
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if(m_uiCreatureEntry == NPC_RISEN_CHAMPION)
+        {
+            if (m_pInstance && m_pInstance->GetData(TYPE_BLACK_KNIGHT) != IN_PROGRESS) 
+                m_creature->ForcedDespawn();
+        }
+
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if(m_uiCreatureEntry == NPC_RISEN_CHAMPION)
+        {
+            if(m_uiSpellTimer < uiDiff)
+            {
+                if (Creature* pTemp = GetClosestCreatureWithEntry(m_creature, NPC_BLACK_KNIGHT, 180.0f))
+                {
+                    if (pTemp->isAlive() && pTemp->GetHealthPercent() < 25.0f && !m_bHasExploded)
+                    {
+                        DoExplode();
+                        m_bHasExploded = true;
+                        return;
+                    }
+                }
+
+                if (m_creature->IsWithinDistInMap(m_creature->getVictim(), 30.0f))
+                {
+                    DoCast(m_creature->getVictim(), SPELL_CLAW);
+                    if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                        m_creature->AddThreat(pTarget, 100.0f);
+                    m_uiSpellTimer = urand(2000, 4000);
+                }
+            }
+            else
+                m_uiSpellTimer -= uiDiff;
+        }
+        else
+        {
+            if(m_uiSpellTimer < uiDiff)
+            {
+                if (Creature* pTemp = GetClosestCreatureWithEntry(m_creature, NPC_BLACK_KNIGHT, 180.0f))
+                {
+                    if (pTemp->isAlive() && pTemp->GetHealthPercent() < 25.0f && !m_bHasExploded)
+                    {
+                        DoExplode();
+                        m_bHasExploded = true;
+                        return;
+                    }
+                }
+
+                if (m_creature->IsWithinDistInMap(m_creature->getVictim(), 4.0f))
+                {
+                    DoCast(m_creature->getVictim(), SPELL_CLAW);
+                    if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                        m_creature->AddThreat(pTarget, 100.0f);
+                    m_uiSpellTimer = urand(2000, 4000);
+                }
+                else if (m_creature->IsWithinDistInMap(m_creature->getVictim(), 30.0f))
+                {
+                    DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_LEAP : SPELL_LEAP_H);
+                    m_uiSpellTimer = urand(2000, 4000);
+                } 
+            }
+            else 
+                m_uiSpellTimer -= uiDiff;
+        }
+
+        if (m_creature->GetHealthPercent() < 25.0f && !m_bHasExploded)
+        {
+            DoExplode();
+            m_bHasExploded = true;
+        }
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+// The Black Knight
+struct MANGOS_DLL_DECL boss_black_knightAI: public ScriptedAI
+{
+    boss_black_knightAI(Creature* pCreature): ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        pCreature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_bIsIntro = true;
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiIntroTimer;
+    uint32 m_uiIntroStep;
+
+    bool m_bIsIntro;
+
+    uint32 m_uiMinionId;
+
+    uint32 m_uiPlague_Strike_Timer;
+    uint32 m_uiIcy_Touch_Timer;
+    uint32 m_uiObliterate_Timer;
+    uint32 m_uiChoke_Timer;
+    uint32 m_uiDeath_Timer;
+    uint32 m_uiMark_Timer;
+    uint32 m_uiPhase_Delay;
+    uint32 m_uiDesecrationTimer;
+    uint32 m_uiGhoulExplodeTimer;
+
+    uint32 TeamInInstance;
+
+    bool m_bIsPhase1;
+    bool m_bIsPhase2;
+    bool m_bIsPhase3;
+
+    void Reset()
+    {
+        m_uiIntroTimer              = 3000;
+        m_uiIntroStep               = 0;
+        TeamInInstance              = GetFaction();
+        m_uiPlague_Strike_Timer     = 5000;
+        m_uiIcy_Touch_Timer         = 10000;
+        m_uiObliterate_Timer        = 16000;
+        m_uiChoke_Timer             = 15000;
+        m_bIsPhase1                 = true;      //FIXME: use one numeric value instead
+        m_bIsPhase2                 = false;
+        m_bIsPhase3                 = false;
+        m_creature->SetDisplayId(29837);
+        SetEquipmentSlots(false, EQUIP_SWORD, EQUIP_NO_CHANGE, EQUIP_NO_CHANGE);
+        m_creature->SetRespawnDelay(DAY);
+        // set ghoul
+        if(TeamInInstance == HORDE)
+            m_uiMinionId = NPC_RISEN_ARELAS;
+        else if(TeamInInstance == ALLIANCE)
+            m_uiMinionId = NPC_RISEN_JAEREN;
+    }
+
+    uint32 GetFaction()
+    {
+        uint32 faction = 0;
+        Map *map = m_creature->GetMap();
+        if (map->IsDungeon())
+        {
+            Map::PlayerList const &PlayerList = map->GetPlayers();
+
+            if (!PlayerList.isEmpty())
+            {
+                if (Player* pPlayer = PlayerList.begin()->getSource())
+                    faction = pPlayer->GetTeam();
+            }
+        }
+        return faction;
+    }
+
+    void JustReachedHome()
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_BLACK_KNIGHT, NOT_STARTED);
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!m_pInstance)  
+            return;
+
+        if (m_pInstance->GetData(TYPE_BLACK_KNIGHT) != IN_PROGRESS) 
+            return;
+
+        if (m_creature->Attack(pWho, true)) 
+        {
+            m_creature->AddThreat(pWho);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+        }
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        switch(urand(0, 1))
+        {
+        case 0: DoScriptText(SAY_KILL1, m_creature); break;
+        case 1: DoScriptText(SAY_KILL2, m_creature); break;
+        }
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        DoScriptText(SAY_AGGRO, m_creature);
+        if (m_pInstance && m_pInstance->GetData(TYPE_BLACK_KNIGHT) != IN_PROGRESS)
+            m_pInstance->SetData(TYPE_BLACK_KNIGHT, IN_PROGRESS);
+    }
+
+    void JustSummoned(Creature* pSummoned)
+    {
+        if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+        {
+            pSummoned->AddThreat(pTarget, 100.0f);
+            pSummoned->AI()->AttackStart(pTarget);
+        }
+    }
+
+    void DamageTaken(Unit* pDoneBy, uint32& uiDamage)
+    {
+        if (uiDamage > m_creature->GetHealth() && !m_bIsPhase3)
+        {
+            uiDamage = 0;
+            if (m_bIsPhase2)
+                StartPhase3();
+            if (m_bIsPhase1)
+                StartPhase2();
+        }
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        if (!m_pInstance)
+            return;
+        if (m_bIsPhase3)
+        {
+            DoScriptText(SAY_DEATH, m_creature);
+            if(Creature* pTirion = GetClosestCreatureWithEntry(m_creature, NPC_TIRION, 180.0f))
+                DoScriptText(SAY_TIRION_OUTRO1, pTirion);
+            m_pInstance->SetData(TYPE_BLACK_KNIGHT, DONE);
+        }
+        if (m_bIsPhase2 && !m_creature->isAlive())
+        {
+            m_creature->Respawn();
+            StartPhase3();
+        }
+        if (m_bIsPhase1 && !m_creature->isAlive())
+        {
+            m_creature->Respawn();
+            StartPhase2();
+        }
+    }
+
+    void StartPhase2()
+    {
+        m_bIsPhase1             = false;
+        m_bIsPhase2             = true;
+        m_bIsPhase3             = false;
+        m_uiPlague_Strike_Timer = 14000;
+        m_uiIcy_Touch_Timer     = 12000;
+        m_uiObliterate_Timer    = 18000;
+        m_uiDesecrationTimer    = 15000;
+        m_uiGhoulExplodeTimer   = 13000;
+        m_creature->SetHealthPercent(100.0f);
+        m_creature->SetDisplayId(27550);
+        DoCast(m_creature, SPELL_ARMY);
+        DoScriptText(SAY_PHASE2, m_creature);
+    }
+
+    void StartPhase3()
+    {
+        m_bIsPhase1     = false;
+        m_bIsPhase2     = false;
+        m_bIsPhase3     = true;
+        m_uiDeath_Timer = 5000;
+        m_uiMark_Timer  = 9000;
+        m_creature->SetHealthPercent(100.0f);
+        m_creature->SetDisplayId(14560);
+        SetEquipmentSlots(false, EQUIP_UNEQUIP, EQUIP_NO_CHANGE, EQUIP_NO_CHANGE);
+        DoScriptText(SAY_PHASE3, m_creature);
+        ExplodeZombies();
+    }
+
+    void ExplodeZombies()
+    {
+        std::list<Creature* > lZombies;
+        GetCreatureListWithEntryInGrid(lZombies, m_creature, NPC_RISEN_CHAMPION, 75.0f);
+
+        if (!lZombies.empty())
+        {
+            for(std::list<Creature*>::iterator iter = lZombies.begin(); iter != lZombies.end(); ++iter)
+            {
+                if ((*iter) && !(*iter)->isAlive())
+                    ((mob_toc_risen_ghoulAI*)(*iter)->AI())->DoExplode();
+            }
+        }
+    }
+
+    Creature* SelectRandomZombie(float fRange)
+    {
+        std::list<Creature* > lZombies;
+        GetCreatureListWithEntryInGrid(lZombies, m_creature, NPC_RISEN_CHAMPION, fRange);
+
+        //This should not appear!
+        if (lZombies.empty()){
+            m_uiGhoulExplodeTimer = urand(7000, 15000);
+            return NULL;
+        }
+
+        std::list<Creature* >::iterator iter = lZombies.begin();
+        advance(iter, urand(0, lZombies.size()-1));
+
+        if((*iter)->isAlive())
+            return *iter;
+        else
+        {
+            m_uiGhoulExplodeTimer = urand(7000, 15000);
+            return NULL;
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_bIsIntro)
+        {
+            if(m_uiIntroTimer < uiDiff)
+            {
+                switch(m_uiIntroStep)
+                {
+                case 0:
+                    DoScriptText(SAY_INTRO1, m_creature);
+                    ++m_uiIntroStep;
+                    m_uiIntroTimer = 8000;
+                    break;
+                case 1:
+                    DoScriptText(SAY_KILL_HERALD, m_creature);
+                    if(Creature* pAnnoucer = GetClosestCreatureWithEntry(m_creature, NPC_JAEREN, 180.0f))
+                        pAnnoucer->DealDamage(pAnnoucer, pAnnoucer->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                    if(Creature* pAnnoucer = GetClosestCreatureWithEntry(m_creature, NPC_ARELAS, 180.0f))
+                        pAnnoucer->DealDamage(pAnnoucer, pAnnoucer->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                    ++m_uiIntroStep;
+                    m_uiIntroTimer = 3000;
+                    break;
+                case 2:
+                    // tirion
+                    if(Creature* pTirion = GetClosestCreatureWithEntry(m_creature, NPC_TIRION, 180.0f))
+                        DoScriptText(SAY_TIRION_INTRO, pTirion);
+                    ++m_uiIntroStep;
+                    m_uiIntroTimer = 3000;
+                    break;
+                case 3:
+                    DoScriptText(SAY_INTRO2, m_creature);
+                    ++m_uiIntroStep;
+                    m_uiIntroTimer = 9000;
+                    break;
+                case 4:
+                    DoScriptText(SAY_INTRO3, m_creature);
+                    ++m_uiIntroStep;
+                    m_uiIntroTimer = 4000;
+                    break;
+                case 5:
+                    // summmon 
+                    if (m_pInstance)
+                        m_pInstance->SetData(TYPE_BLACK_KNIGHT, IN_PROGRESS);
+                    if(Creature* pGhoul = m_creature->SummonCreature(m_uiMinionId, 0, 0, 0, 0, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 10000))
+                        pGhoul->SetInCombatWithZone();
+                    m_creature->SetInCombatWithZone();
+                    m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    m_bIsIntro = false;
+                    ++m_uiIntroStep;
+                    m_uiIntroTimer = 3000;
+                    break;
+                }
+            }else m_uiIntroTimer -= uiDiff;
+        }
+
+        if(m_bIsIntro)
+            return;
+
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        // phase 1 spells
+        if (m_uiPlague_Strike_Timer < uiDiff && !m_bIsPhase3)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_PLAGUE_STRIKE : SPELL_PLAGUE_STRIKE_H);
+            m_uiPlague_Strike_Timer = 10500;
+        }
+        else
+            m_uiPlague_Strike_Timer -= uiDiff;  
+
+        if (m_uiIcy_Touch_Timer < uiDiff && !m_bIsPhase3)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_ICY_TOUCH : SPELL_ICY_TOUCH_H);
+            m_uiIcy_Touch_Timer = 10000;
+        }
+        else
+            m_uiIcy_Touch_Timer -= uiDiff;
+
+        if (m_uiObliterate_Timer < uiDiff && !m_bIsPhase3)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_OBLITERATE : SPELL_OBLITERATE_H);
+            m_uiObliterate_Timer = 11000;
+        }
+        else
+            m_uiObliterate_Timer -= uiDiff;
+
+        // only in phase 1
+        if (m_uiChoke_Timer < uiDiff && m_bIsPhase1)
+        {
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_DEATHS_RESPITE);
+            m_uiChoke_Timer = 15000;
+        }
+        else
+            m_uiChoke_Timer -= uiDiff;
+
+        // phase 2 spells
+        if(m_uiDesecrationTimer < uiDiff && m_bIsPhase2)
+        {
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_DESECRATION_SUMMON);
+            m_uiDesecrationTimer = urand(14000, 17000);
+        }
+        else m_uiDesecrationTimer -= uiDiff;
+
+        if(m_uiGhoulExplodeTimer < uiDiff && m_bIsPhase2)
+        {
+            if(Creature* pZombie = SelectRandomZombie(75.0f))
+                ((mob_toc_risen_ghoulAI*)pZombie->AI())->DoExplode();
+            m_uiGhoulExplodeTimer = urand(7000, 15000);
+        }
+        else m_uiGhoulExplodeTimer -= uiDiff;
+
+        // phase 3 spells
+        if (m_uiMark_Timer < uiDiff && m_bIsPhase3)
+        {
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                DoCast(pTarget, SPELL_MARKED_DEATH);
+            m_uiMark_Timer = 15000;
+        }
+        else
+            m_uiMark_Timer -= uiDiff;
+
+        if (m_uiDeath_Timer < uiDiff && m_bIsPhase3)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_DEATHS_BITE : SPELL_DEATHS_BITE_H);
+            m_uiDeath_Timer = 3500;
+        }
+        else
+            m_uiDeath_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+// Desecration bunny
+struct MANGOS_DLL_DECL mob_toc_desecration_bunnyAI: public ScriptedAI
+{
+    mob_toc_desecration_bunnyAI(Creature* pCreature): ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        SetCombatMovement(false);
+        pCreature->setFaction(14);
+        pCreature->SetDisplayId(11686);     // make invisible
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    void Reset()
+    {
+        DoCast(m_creature, SPELL_DESECRATION);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_pInstance && m_pInstance->GetData(TYPE_BLACK_KNIGHT) != IN_PROGRESS) 
+            m_creature->ForcedDespawn();
+    }
+};
+
+CreatureAI* GetAI_mob_toc_risen_ghoul(Creature* pCreature)
+{
+    return new mob_toc_risen_ghoulAI(pCreature);
+}
+
+CreatureAI* GetAI_boss_black_knight(Creature* pCreature)
+{
+    return new boss_black_knightAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_toc_desecration_bunny(Creature* pCreature)
+{
+    return new mob_toc_desecration_bunnyAI(pCreature);
+}
+
+void AddSC_boss_black_knight()
+{
+    Script *NewScript;
+
+    NewScript = new Script;
+    NewScript->Name = "boss_black_knight";
+    NewScript->GetAI = &GetAI_boss_black_knight;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_toc_risen_ghoul";
+    NewScript->GetAI = &GetAI_mob_toc_risen_ghoul;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_toc_desecration_bunny";
+    NewScript->GetAI = &GetAI_mob_toc_desecration_bunny;
+    NewScript->RegisterSelf();
+}
diff --git a/scripts/northrend/crusaders_coliseum/trial_of_the_champion/boss_grand_champions.cpp b/scripts/northrend/crusaders_coliseum/trial_of_the_champion/boss_grand_champions.cpp
new file mode 100644
index 0000000..4e888cc
--- /dev/null
+++ b/scripts/northrend/crusaders_coliseum/trial_of_the_champion/boss_grand_champions.cpp
@@ -0,0 +1,758 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/* ScriptData
+SDName: boss_grand_champions
+SD%Complete: 92%
+SDComment: missing yells. hunter AI sucks. no pvp diminuishing returns
+SDCategory: Trial Of the Champion
+EndScriptData */
+
+#include "precompiled.h"
+#include "trial_of_the_champion.h"
+
+enum Spells
+{
+    //warrior
+    SPELL_MORTAL_STRIKE         = 68783,
+    SPELL_MORTAL_STRIKE_H       = 68784,
+    SPELL_BLADESTORM            = 63784,
+    SPELL_INTERCEPT             = 67540,
+    SPELL_ROLLING_THROW         = 67546,
+    //mage
+    SPELL_FIREBALL              = 66042,
+    SPELL_FIREBALL_H            = 68310,
+    SPELL_BLAST_WAVE            = 66044,
+    SPELL_BLAST_WAVE_H          = 68312,
+    SPELL_HASTE                 = 66045,
+    SPELL_POLYMORPH             = 66043,
+    SPELL_POLYMORPH_H           = 68311,
+    //shaman
+    SPELL_CHAIN_LIGHTNING       = 67529,
+    SPELL_CHAIN_LIGHTNING_H     = 68319,
+    SPELL_EARTH_SHIELD          = 67530,
+    SPELL_HEALING_WAVE          = 67528,
+    SPELL_HEALING_WAVE_H        = 68318,
+    SPELL_HEX_OF_MENDING        = 67534,
+    //hunter
+    SPELL_DISENGAGE             = 68340,
+    SPELL_LIGHTNING_ARROWS      = 66083,
+    SPELL_MULTI_SHOT            = 66081,
+    SPELL_SHOOT                 = 66079,
+    //rogue
+    SPELL_DEADLY_POISON         = 67710,
+    SPELL_DEADLY_POISON_H       = 68315,
+    SPELL_EVISCERATE            = 67709,
+    SPELL_EVISCERATE_H          = 68317,
+    SPELL_FAN_OF_KNIVES         = 67706,
+    SPELL_POISON_BOTTLE         = 67701
+};
+
+enum AI
+{
+    AI_MELEE    = 0,
+    AI_RANGED   = 1,
+};
+
+// common parts for all champions
+struct MANGOS_DLL_DECL toc5_champion_baseAI: public ScriptedAI
+{
+    toc5_champion_baseAI(Creature* pCreature, uint32 aitype): ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        mAIType = aitype;
+        Init();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+    uint32 mAIType;
+    uint32 m_uiThreatTimer;
+    uint32 TeamInInstance;
+
+    void Init()
+    {
+        m_uiThreatTimer = 15000;
+        TeamInInstance = GetFaction();
+        m_creature->SetRespawnDelay(DAY);
+    }
+
+    uint32 GetFaction()
+    {
+        uint32 faction = 0;
+        Map *map = m_creature->GetMap();
+        if (map->IsDungeon())
+        {
+            Map::PlayerList const &PlayerList = map->GetPlayers();
+
+            if (!PlayerList.isEmpty())
+            {
+                if (Player* pPlayer = PlayerList.begin()->getSource())
+                    faction = pPlayer->GetTeam();
+            }
+        }
+        return faction;
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (!pWho) 
+            return;
+
+        if (m_creature->Attack(pWho, true))
+        {
+            m_creature->AddThreat(pWho);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+
+            if(mAIType==AI_MELEE)
+                DoStartMovement(pWho);
+            else
+                DoStartMovement(pWho, 20.0f);
+        }
+    }
+
+    void Aggro(Unit *who)
+    {
+        if(m_pInstance && m_pInstance->GetData(TYPE_GRAND_CHAMPIONS) != IN_PROGRESS) 
+            m_pInstance->SetData(TYPE_GRAND_CHAMPIONS, IN_PROGRESS);
+
+        // call for help
+        if(TeamInInstance == HORDE)
+        {
+            m_pInstance->SetData(TYPE_STAGE, 1);
+
+            if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_JACOB)))
+            {
+                if(pTemp->isAlive())
+                    pTemp->AI()->AttackStart(m_creature->getVictim());
+                else
+                    pTemp->Respawn();
+            }
+            if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_AMBROSE)))
+            {
+                if(pTemp->isAlive())
+                    pTemp->AI()->AttackStart(m_creature->getVictim());
+                else
+                    pTemp->Respawn();
+            }
+            if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_COLOSOS)))
+            {
+                if(pTemp->isAlive())
+                    pTemp->AI()->AttackStart(m_creature->getVictim());
+                else
+                    pTemp->Respawn();
+            }
+            if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_JAELYNE)))
+            {
+                if(pTemp->isAlive())
+                    pTemp->AI()->AttackStart(m_creature->getVictim());
+                else
+                    pTemp->Respawn();
+            }
+            if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_LANA)))
+            {
+                if(pTemp->isAlive())
+                    pTemp->AI()->AttackStart(m_creature->getVictim());
+                else
+                    pTemp->Respawn();
+            }
+        }
+        else if(TeamInInstance == ALLIANCE)
+        {
+            m_pInstance->SetData(TYPE_STAGE, 1);
+
+            if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_MOKRA)))
+            {
+                if(pTemp->isAlive())
+                    pTemp->AI()->AttackStart(m_creature->getVictim());
+                else
+                    pTemp->Respawn();
+            }
+            if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_ERESSEA)))
+            {
+                if(pTemp->isAlive())
+                    pTemp->AI()->AttackStart(m_creature->getVictim());
+                else
+                    pTemp->Respawn();
+            }
+            if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_RUNOK)))
+            {
+                if(pTemp->isAlive())
+                    pTemp->AI()->AttackStart(m_creature->getVictim());
+                else
+                    pTemp->Respawn();
+            }
+            if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_ZULTORE)))
+            {
+                if(pTemp->isAlive())
+                    pTemp->AI()->AttackStart(m_creature->getVictim());
+                else
+                    pTemp->Respawn();
+            }
+            if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_VISCERI)))
+            {
+                if(pTemp->isAlive())
+                    pTemp->AI()->AttackStart(m_creature->getVictim());
+                else
+                    pTemp->Respawn();
+            }
+        }
+    }
+
+    void JustReachedHome()
+    {
+        if (m_pInstance)
+        {  
+            // do this only for the first who reaches home
+            if(m_pInstance->GetData(TYPE_GRAND_CHAMPIONS) != NOT_STARTED)
+            {
+                // rewpawn dead champs
+                if(TeamInInstance == HORDE)
+                {
+                    if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_JACOB)))
+                    {
+                        if(!pTemp->isAlive())
+                            pTemp->Respawn();
+                        else
+                            pTemp->AI()->EnterEvadeMode();
+                    }
+                    if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_AMBROSE)))
+                    {
+                        if(!pTemp->isAlive())
+                            pTemp->Respawn();
+                        else
+                            pTemp->AI()->EnterEvadeMode();
+                    }
+                    if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_COLOSOS)))
+                    {
+                        if(!pTemp->isAlive())
+                            pTemp->Respawn();
+                        else
+                            pTemp->AI()->EnterEvadeMode();
+                    }
+                    if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_JAELYNE)))
+                    {
+                        if(!pTemp->isAlive())
+                            pTemp->Respawn();
+                        else
+                            pTemp->AI()->EnterEvadeMode();
+                    }
+                    if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_LANA)))
+                    {
+                        if(!pTemp->isAlive())
+                            pTemp->Respawn();
+                        else
+                            pTemp->AI()->EnterEvadeMode();
+                    }
+                }
+                else if(TeamInInstance == ALLIANCE)
+                {
+                    if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_MOKRA)))
+                    {
+                        if(!pTemp->isAlive())
+                            pTemp->Respawn();
+                        else
+                            pTemp->AI()->EnterEvadeMode();
+                    }
+                    if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_ERESSEA)))
+                    {
+                        if(!pTemp->isAlive())
+                            pTemp->Respawn();
+                        else
+                            pTemp->AI()->EnterEvadeMode();
+                    }
+                    if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_RUNOK)))
+                    {
+                        if(!pTemp->isAlive())
+                            pTemp->Respawn();
+                        else
+                            pTemp->AI()->EnterEvadeMode();
+                    }
+                    if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_ZULTORE)))
+                    {
+                        if(!pTemp->isAlive())
+                            pTemp->Respawn();
+                        else
+                            pTemp->AI()->EnterEvadeMode();
+                    }
+                    if(Creature* pTemp = (Creature*)Unit::GetUnit((*m_creature),m_pInstance->GetData64(NPC_VISCERI)))
+                    {
+                        if(!pTemp->isAlive())
+                            pTemp->Respawn();
+                        else
+                            pTemp->AI()->EnterEvadeMode();
+                    }
+                }
+
+                m_pInstance->SetData(TYPE_STAGE, 0);
+                m_pInstance->SetData(TYPE_GRAND_CHAMPIONS, NOT_STARTED);
+            }
+        }  
+    }
+
+    void UpdatePower()
+    {
+        if(m_creature->getPowerType() == POWER_MANA)
+            m_creature->ModifyPower(POWER_MANA, m_creature->GetMaxPower(POWER_MANA) / 3);
+    }
+
+    float CalculateThreat(float distance, float armor, uint32 health)
+    {
+        float dist_mod = (mAIType == AI_MELEE) ? 15.0f/(15.0f + distance) : 1.0f;
+        float armor_mod = (mAIType == AI_MELEE) ? armor / 16635.0f : 0.0f;
+        float eh = (health+1) * (1.0f + armor_mod);
+        return dist_mod * 30000.0f / eh;
+    }
+
+    void UpdateThreat()
+    {
+        ThreatList const& tList = m_creature->getThreatManager().getThreatList();
+        ThreatList::const_iterator itr;
+        bool empty = true;
+        for(itr = tList.begin(); itr!=tList.end(); ++itr)
+        {
+            Unit* pUnit = Unit::GetUnit((*m_creature), (*itr)->getUnitGuid());
+            if (pUnit && m_creature->getThreatManager().getThreat(pUnit))
+            {
+                if(pUnit->GetTypeId()==TYPEID_PLAYER)
+                {
+                    float threat = CalculateThreat(m_creature->GetDistance2d(pUnit), (float)pUnit->GetArmor(), pUnit->GetHealth());
+                    m_creature->getThreatManager().modifyThreatPercent(pUnit, -100);
+                    m_creature->AddThreat(pUnit, 1000000.0f * threat);
+                    empty = false;
+                }
+            }
+        }
+        //if(empty) 
+            //EnterEvadeMode();
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if(m_uiThreatTimer < uiDiff)
+        {
+            UpdatePower();
+            UpdateThreat();
+            m_uiThreatTimer = 4000;
+        }
+        else m_uiThreatTimer -= uiDiff;
+    }
+};
+
+// Warrior
+struct MANGOS_DLL_DECL mob_toc5_warriorAI: public toc5_champion_baseAI
+{
+    mob_toc5_warriorAI(Creature* pCreature): toc5_champion_baseAI(pCreature, AI_MELEE)
+    {
+        Reset();
+    }
+
+    uint32 m_uiMortal_Strike_Timer;
+    uint32 m_uiBladestorm_Timer;
+    uint32 m_uiRolling_Throw_Timer;
+    uint32 m_uiIntercept_Cooldown;
+
+    void Reset()
+    {
+        m_uiMortal_Strike_Timer = 6000;
+        m_uiBladestorm_Timer    = 20000;
+        m_uiRolling_Throw_Timer = 30000;
+        m_uiIntercept_Cooldown  = 2000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiMortal_Strike_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_MORTAL_STRIKE : SPELL_MORTAL_STRIKE_H);
+            m_uiMortal_Strike_Timer = 6000;
+        }
+        else
+            m_uiMortal_Strike_Timer -= uiDiff;  
+
+        if (m_uiRolling_Throw_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_ROLLING_THROW);
+            m_uiRolling_Throw_Timer = 30000;
+        }
+        else
+            m_uiRolling_Throw_Timer -= uiDiff;
+
+        if (m_uiBladestorm_Timer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_BLADESTORM);
+            m_uiBladestorm_Timer = 90000;
+        }
+        else
+            m_uiBladestorm_Timer -= uiDiff;
+
+        if (m_uiIntercept_Cooldown < uiDiff)
+        {
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+            {
+                if(m_creature->GetDistance2d(pTarget) > 10.0f)
+                {
+                    DoCast(pTarget, SPELL_INTERCEPT);
+                    m_uiIntercept_Cooldown = 15000;
+                }
+                else
+                    m_uiIntercept_Cooldown = 1000;
+            }
+        }
+        else 
+            m_uiIntercept_Cooldown -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+// Mage
+struct MANGOS_DLL_DECL mob_toc5_mageAI: public toc5_champion_baseAI
+{
+    mob_toc5_mageAI(Creature* pCreature): toc5_champion_baseAI(pCreature, AI_RANGED)
+    {
+        Reset();
+    }
+
+    uint32 m_uiFireball_Timer;
+    uint32 m_uiBlast_Wave_Timer;
+    uint32 m_uiHaste_Timer;
+    uint32 m_uiPolymorph_Timer;
+
+    void Reset()
+    {
+        m_uiFireball_Timer      = 1000;
+        m_uiBlast_Wave_Timer    = 20000;
+        m_uiHaste_Timer         = 9000;
+        m_uiPolymorph_Timer     = 15000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiFireball_Timer < uiDiff)
+        {
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_FIREBALL : SPELL_FIREBALL_H);
+            m_uiFireball_Timer = 3000;
+        }
+        else
+            m_uiFireball_Timer -= uiDiff;  
+
+        if (m_uiBlast_Wave_Timer < uiDiff)
+        {
+            DoCast(m_creature, m_bIsRegularMode ? SPELL_BLAST_WAVE : SPELL_BLAST_WAVE_H);
+            m_uiBlast_Wave_Timer = 20000;
+        }
+        else
+            m_uiBlast_Wave_Timer -= uiDiff;
+
+        if (m_uiHaste_Timer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_HASTE);
+            m_uiHaste_Timer = 10000;
+        }
+        else
+            m_uiHaste_Timer -= uiDiff;
+
+        if (m_uiPolymorph_Timer < uiDiff)
+        {
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_POLYMORPH : SPELL_POLYMORPH_H);
+            m_uiPolymorph_Timer = 15000;
+        }
+        else
+            m_uiPolymorph_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+// Shaman
+struct MANGOS_DLL_DECL mob_toc5_shamanAI: public toc5_champion_baseAI
+{
+    mob_toc5_shamanAI(Creature* pCreature): toc5_champion_baseAI(pCreature, AI_RANGED)
+    {
+        Reset();
+    }
+
+    uint32 m_uiChain_Lightning_Timer;
+    uint32 m_uiEarth_Shield_Timer;
+    uint32 m_uiHealing_Wave_Timer;
+    uint32 m_uiHex_Timer;
+
+    void Reset()
+    {
+        m_uiChain_Lightning_Timer   = 1000;
+        m_uiEarth_Shield_Timer      = 5000;
+        m_uiHealing_Wave_Timer      = 13000;
+        m_uiHex_Timer               = 10000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiChain_Lightning_Timer < uiDiff)
+        {
+            if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                DoCast(pTarget, m_bIsRegularMode ? SPELL_CHAIN_LIGHTNING : SPELL_CHAIN_LIGHTNING_H);
+            m_uiChain_Lightning_Timer = urand(5000, 10000);
+        }
+        else
+            m_uiChain_Lightning_Timer -= uiDiff;  
+
+        if (m_uiHex_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_HEX_OF_MENDING);
+            m_uiHex_Timer = 20000;
+        }
+        else
+            m_uiHex_Timer -= uiDiff;
+
+        if (m_uiHealing_Wave_Timer < uiDiff)
+        {
+            switch(urand(0, 2))
+            {
+            case 0:
+            case 1:
+                if(Unit* pTarget = DoSelectLowestHpFriendly(80.0f))
+                    DoCast(pTarget, m_bIsRegularMode ? SPELL_HEALING_WAVE : SPELL_HEALING_WAVE_H);
+                break;
+            case 2:
+                DoCast(m_creature, m_bIsRegularMode ? SPELL_HEALING_WAVE : SPELL_HEALING_WAVE_H);
+                break;
+            }
+            m_uiHealing_Wave_Timer = 8000;
+        }
+        else
+            m_uiHealing_Wave_Timer -= uiDiff;
+
+        if (m_uiEarth_Shield_Timer < uiDiff)
+        {
+            switch(urand(0, 2))
+            {
+            case 0:
+            case 1:
+                if(Unit* pTarget = DoSelectLowestHpFriendly(80.0f))
+                    DoCast(pTarget, SPELL_EARTH_SHIELD);
+            case 2:
+                DoCast(m_creature, SPELL_EARTH_SHIELD);
+                break;
+            }
+            m_uiEarth_Shield_Timer = 25000;
+        }
+        else
+            m_uiEarth_Shield_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+// Hunter
+struct MANGOS_DLL_DECL mob_toc5_hunterAI: public toc5_champion_baseAI
+{
+    mob_toc5_hunterAI(Creature* pCreature): toc5_champion_baseAI(pCreature, AI_RANGED)
+    {
+        Reset();
+    }
+
+    uint32 m_uiShoot_Timer;
+    uint32 m_uiLightning_Arrows_Timer;
+    uint32 m_uiMulti_Shot_Timer;
+    uint32 m_uiDisengage_Timer;
+
+    void Reset()
+    {
+        m_uiShoot_Timer             = 1000;
+        m_uiLightning_Arrows_Timer  = 13000;
+        m_uiMulti_Shot_Timer        = 10000;
+        m_uiDisengage_Timer         = 5000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiDisengage_Timer < uiDiff)
+        {
+            if (m_creature->IsWithinDistInMap(m_creature->getVictim(), 5))
+            {
+                DoCast(m_creature, SPELL_DISENGAGE);
+                m_uiDisengage_Timer = 15000;
+            }
+            else
+                m_uiDisengage_Timer = 5000;
+        }
+        else
+            m_uiDisengage_Timer -= uiDiff;
+
+        if (m_uiShoot_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_SHOOT);
+            m_uiShoot_Timer = 1500;
+        }
+        else
+            m_uiShoot_Timer -= uiDiff;  
+
+        if (m_uiMulti_Shot_Timer < uiDiff)
+        {
+            m_creature->InterruptNonMeleeSpells(true);
+            DoCast(m_creature->getVictim(), SPELL_MULTI_SHOT);
+            m_uiMulti_Shot_Timer = urand(7000, 10000);
+        }
+        else
+            m_uiMulti_Shot_Timer -= uiDiff;
+
+        if (m_uiLightning_Arrows_Timer < uiDiff)
+        {
+            m_creature->InterruptNonMeleeSpells(true);
+            DoCast(m_creature, SPELL_LIGHTNING_ARROWS);
+            m_uiLightning_Arrows_Timer = 25000;
+        }
+        else
+            m_uiLightning_Arrows_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+// Rogue
+struct MANGOS_DLL_DECL mob_toc5_rogueAI: public toc5_champion_baseAI
+{
+    mob_toc5_rogueAI(Creature* pCreature): toc5_champion_baseAI(pCreature, AI_MELEE)
+    {
+        Reset();
+    }
+
+    uint32 m_uiDeadlyPoisonTimer;
+    uint32 m_uiEviscerate_Timer;
+    uint32 m_uiFoK_Timer;
+    uint32 m_uiPoisonBottle_Timer;
+
+    void Reset()
+    {
+        m_uiDeadlyPoisonTimer   = 12000;
+        m_uiEviscerate_Timer    = 15000;
+        m_uiFoK_Timer           = 10000;
+        m_uiPoisonBottle_Timer  = 7000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_uiDeadlyPoisonTimer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_DEADLY_POISON : SPELL_DEADLY_POISON_H);
+            m_uiDeadlyPoisonTimer = urand(8000, 11000);
+        } 
+        else
+            m_uiDeadlyPoisonTimer -= uiDiff;
+
+        if (m_uiEviscerate_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsRegularMode ? SPELL_EVISCERATE : SPELL_EVISCERATE_H);
+            m_uiEviscerate_Timer = 10000;
+        }
+        else
+            m_uiEviscerate_Timer -= uiDiff;  
+
+        if (m_uiFoK_Timer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_FAN_OF_KNIVES);
+            m_uiFoK_Timer = 7000;
+        }
+        else
+            m_uiFoK_Timer -= uiDiff;
+
+        if (m_uiPoisonBottle_Timer < uiDiff)
+        {
+            if (Unit* target = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                DoCast(m_creature, SPELL_POISON_BOTTLE);
+            m_uiPoisonBottle_Timer = 6000;
+        }
+        else
+            m_uiPoisonBottle_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_toc5_warrior(Creature* pCreature)
+{
+    return new mob_toc5_warriorAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_toc5_mage(Creature* pCreature)
+{
+    return new mob_toc5_mageAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_toc5_shaman(Creature* pCreature)
+{
+    return new mob_toc5_shamanAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_toc5_hunter(Creature* pCreature)
+{
+    return new mob_toc5_hunterAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_toc5_rogue(Creature* pCreature)
+{
+    return new mob_toc5_rogueAI(pCreature);
+}
+
+void AddSC_boss_grand_champions()
+{
+    Script* NewScript;
+
+    NewScript = new Script;
+    NewScript->Name = "mob_toc5_warrior";
+    NewScript->GetAI = &GetAI_mob_toc5_warrior;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_toc5_mage";
+    NewScript->GetAI = &GetAI_mob_toc5_mage;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_toc5_shaman";
+    NewScript->GetAI = &GetAI_mob_toc5_shaman;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_toc5_hunter";
+    NewScript->GetAI = &GetAI_mob_toc5_hunter;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_toc5_rogue";
+    NewScript->GetAI = &GetAI_mob_toc5_rogue;
+    NewScript->RegisterSelf();
+}
diff --git a/scripts/northrend/crusaders_coliseum/trial_of_the_champion/instance_trial_of_the_champion.cpp b/scripts/northrend/crusaders_coliseum/trial_of_the_champion/instance_trial_of_the_champion.cpp
new file mode 100644
index 0000000..05a448b
--- /dev/null
+++ b/scripts/northrend/crusaders_coliseum/trial_of_the_champion/instance_trial_of_the_champion.cpp
@@ -0,0 +1,352 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: Instance_Trial_Of_the_Champion
+SD%Complete: 100
+SDComment: 
+SDCategory: Trial Of the Champion
+EndScriptData */
+
+#include "precompiled.h"
+#include "trial_of_the_champion.h"
+
+struct MANGOS_DLL_DECL instance_trial_of_the_champion : public ScriptedInstance
+{
+    instance_trial_of_the_champion(Map* pMap) : ScriptedInstance(pMap) { Initialize(); }
+
+    uint32 m_auiEncounter[MAX_ENCOUNTER];
+    std::string m_strInstData;
+
+    // grand champs
+    // aly
+    uint64 m_uiJacobGUID;
+    uint64 m_uiAmbroseGUID;
+    uint64 m_uiColososGUID;
+    uint64 m_uiJaelyneGUID;
+    uint64 m_uiLanaGUID;
+    // horde
+    uint64 m_uiMokraGUID;
+    uint64 m_uiEresseaGUID;
+    uint64 m_uiRunokGUID;
+    uint64 m_uiZultoreGUID;
+    uint64 m_uiVisceriGUID;
+    // argent challenge
+    uint64 m_uiEadricGUID;
+    uint64 m_uiEadricLootGUID;
+    uint64 m_uiPaletressGUID;
+    uint64 m_uiPaletressLootGUID;
+    uint32 m_uiArgentChallenger;
+    // black knight
+    uint64 m_uiBlackKnightGUID;
+    // announcer
+    uint64 m_uiJaerenGUID;
+    uint64 m_uiArelasGUID;
+    uint64 m_uiAnnouncerGUID;
+    uint64 m_uiChampionsLootGUID;
+    uint64 m_uiDoorGUID;
+    uint32 m_auiStage;
+
+    uint32 TeamInInstance;
+
+    void Initialize()
+    {
+        // grand champs
+        // aly
+        m_uiJacobGUID           = 0;
+        m_uiAmbroseGUID         = 0;
+        m_uiColososGUID         = 0;
+        m_uiJaelyneGUID         = 0;
+        m_uiLanaGUID            = 0;
+        // horde
+        m_uiMokraGUID           = 0;
+        m_uiEresseaGUID         = 0;
+        m_uiRunokGUID           = 0;
+        m_uiZultoreGUID         = 0;
+        m_uiVisceriGUID         = 0;
+        // argent challenge
+        m_uiEadricGUID          = 0;
+        m_uiEadricLootGUID      = 0;
+        m_uiPaletressGUID       = 0;
+        m_uiPaletressLootGUID   = 0;
+        m_uiArgentChallenger    = 0;
+        m_uiBlackKnightGUID     = 0;
+        m_uiJaerenGUID          = 0;
+        m_uiArelasGUID          = 0;
+        m_uiAnnouncerGUID       = 0;
+        m_uiChampionsLootGUID   = 0;
+        m_auiStage              = 0;
+        m_uiDoorGUID            = 0;
+
+        TeamInInstance          = GetFaction();
+
+        memset(m_auiEncounter, 0, sizeof(m_auiEncounter));
+    }
+
+    bool IsEncounterInProgress() const
+    {
+        for(uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+        {
+            if (m_auiEncounter[i] == IN_PROGRESS)
+                return true;
+        }
+
+        return false;
+    }
+
+    uint32 GetFaction()
+    {
+        Map::PlayerList const &players = instance->GetPlayers();
+        uint32 m_uiTeam = 0;
+
+        if (!players.isEmpty())
+        {
+            if (Player* pPlayer = players.begin()->getSource())
+                m_uiTeam = pPlayer->GetTeam();
+        }
+        return m_uiTeam;
+    }
+
+    void OnCreatureCreate(Creature* pCreature)
+    {
+        switch(pCreature->GetEntry())
+        {
+            // Champions of the Alliance
+            case NPC_JACOB:
+                m_uiJacobGUID = pCreature->GetGUID();
+                break;
+            case NPC_AMBROSE:
+                m_uiAmbroseGUID = pCreature->GetGUID();
+                break;
+            case NPC_COLOSOS:
+                m_uiColososGUID = pCreature->GetGUID();
+                break;
+            case NPC_JAELYNE:
+                m_uiJaelyneGUID = pCreature->GetGUID();
+                break;
+            case NPC_LANA:
+                m_uiLanaGUID = pCreature->GetGUID();
+                break;
+            // Champions of the Horde
+            case NPC_MOKRA:
+                m_uiMokraGUID = pCreature->GetGUID();
+                break;
+            case NPC_ERESSEA:
+                m_uiEresseaGUID = pCreature->GetGUID();
+                break;
+            case NPC_RUNOK:
+                m_uiRunokGUID = pCreature->GetGUID();
+                break;
+            case NPC_ZULTORE:
+                m_uiZultoreGUID = pCreature->GetGUID();
+                break;
+            case NPC_VISCERI:
+                m_uiVisceriGUID = pCreature->GetGUID();
+                break;
+
+            // Argent Challenge
+            case NPC_EADRIC:
+                m_uiEadricGUID = pCreature->GetGUID();
+                break;
+            case NPC_PALETRESS:
+                m_uiPaletressGUID = pCreature->GetGUID();
+                break;
+
+            // Black Knight
+            case NPC_BLACK_KNIGHT:
+                m_uiBlackKnightGUID = pCreature->GetGUID();
+                break;
+
+            // Coliseum Announcers
+            case NPC_JAEREN:
+                m_uiJaerenGUID = pCreature->GetGUID();
+                if (TeamInInstance == HORDE)
+                    m_uiAnnouncerGUID = pCreature->GetGUID();
+                break;
+            case NPC_ARELAS:
+                m_uiArelasGUID = pCreature->GetGUID();
+                if (TeamInInstance == ALLIANCE)
+                    m_uiAnnouncerGUID = pCreature->GetGUID();
+                break;
+        }
+    }
+
+    void OnObjectCreate(GameObject *pGo)
+    {
+        switch(pGo->GetEntry())
+        {
+            case GO_CHAMPIONS_LOOT:
+                if(instance->IsRegularDifficulty())
+                    m_uiChampionsLootGUID = pGo->GetGUID();
+            case GO_CHAMPIONS_LOOT_H:
+                if(!instance->IsRegularDifficulty())
+                    m_uiChampionsLootGUID = pGo->GetGUID();
+                break;
+            case GO_EADRIC_LOOT:
+                if(instance->IsRegularDifficulty())
+                    m_uiEadricLootGUID = pGo->GetGUID();
+            case GO_EADRIC_LOOT_H:
+                if(!instance->IsRegularDifficulty())
+                    m_uiEadricLootGUID = pGo->GetGUID();
+                break;
+            case GO_PALETRESS_LOOT:
+                if(instance->IsRegularDifficulty())
+                    m_uiPaletressLootGUID = pGo->GetGUID();
+            case GO_PALETRESS_LOOT_H:
+                if(!instance->IsRegularDifficulty())
+                    m_uiPaletressLootGUID = pGo->GetGUID();
+                break;   
+            case GO_NORTH_GATE:
+                m_uiDoorGUID = pGo->GetGUID();
+                break;
+        }
+    }
+
+    void SetData(uint32 uiType, uint32 uiData)
+    {
+        switch(uiType)
+        {
+            case TYPE_GRAND_CHAMPIONS:
+                m_auiEncounter[0] = uiData;
+                DoUseDoorOrButton(m_uiDoorGUID);
+                if (uiData == DONE)
+                    DoRespawnGameObject(m_uiChampionsLootGUID, DAY);
+                break;
+            case TYPE_ARGENT_CHALLENGE:
+                m_auiEncounter[1] = uiData;
+                DoUseDoorOrButton(m_uiDoorGUID);
+                if (uiData == DONE)
+                {
+                    if (m_uiArgentChallenger == NPC_EADRIC)
+                        DoRespawnGameObject(m_uiEadricLootGUID, DAY);
+                    if (m_uiArgentChallenger == NPC_PALETRESS)
+                        DoRespawnGameObject(m_uiPaletressLootGUID, DAY);
+                }
+                break;
+            case TYPE_BLACK_KNIGHT:
+                m_auiEncounter[2] = uiData;
+                DoUseDoorOrButton(m_uiDoorGUID);
+                if(uiData == DONE)
+                {
+                    if(TeamInInstance == ALLIANCE)
+                        DoCompleteAchievement(instance->IsRegularDifficulty() ? ACHIEV_TOC_ALY : ACHIEV_TOC_ALY_H);
+                    if(TeamInInstance == HORDE)
+                        DoCompleteAchievement(instance->IsRegularDifficulty() ? ACHIEV_TOC_HORDE : ACHIEV_TOC_HORDE_H);
+                }
+                break;
+            case TYPE_STAGE:
+                m_auiStage = uiData;
+                break;
+            case DATA_ARGENT_CHALLERGER:
+                m_uiArgentChallenger = uiData;
+                break;
+        }
+
+        if (uiData == DONE)
+        {
+            std::ostringstream saveStream;
+            saveStream << m_auiEncounter[0] << " " << m_auiEncounter[1] << " " << m_auiEncounter[2];
+            m_strInstData = saveStream.str();
+
+            OUT_SAVE_INST_DATA;
+            SaveToDB();
+            OUT_SAVE_INST_DATA_COMPLETE;
+        }
+    }
+
+    uint32 GetData(uint32 uiType)
+    {
+        switch(uiType)
+        {
+            case TYPE_GRAND_CHAMPIONS:
+                return m_auiEncounter[0];
+            case TYPE_ARGENT_CHALLENGE:
+                return m_auiEncounter[1];
+            case TYPE_BLACK_KNIGHT:
+                return m_auiEncounter[2];
+            case TYPE_STAGE:
+                return m_auiStage;
+            case DATA_ARGENT_CHALLERGER:
+                return m_uiArgentChallenger;
+        }
+        return 0;
+    }
+
+    uint64 GetData64(uint32 uiType)
+    {
+        switch(uiType)
+        {
+            // aly
+        case NPC_JACOB:     return m_uiJacobGUID;   break;
+        case NPC_AMBROSE:   return m_uiAmbroseGUID; break;
+        case NPC_COLOSOS:   return m_uiColososGUID; break;
+        case NPC_JAELYNE:   return m_uiJaelyneGUID; break;
+        case NPC_LANA:      return m_uiLanaGUID;    break;
+            // horde
+        case NPC_MOKRA:     return m_uiMokraGUID;   break;
+        case NPC_ERESSEA:   return m_uiEresseaGUID; break;
+        case NPC_RUNOK:     return m_uiRunokGUID;   break;
+        case NPC_ZULTORE:   return m_uiZultoreGUID; break;
+        case NPC_VISCERI:   return m_uiVisceriGUID; break;
+
+        case DATA_TOC_ANNOUNCER:
+            return m_uiAnnouncerGUID;
+        }
+
+        return 0;
+    }
+
+    const char* Save()
+    {
+        return m_strInstData.c_str();
+    }
+
+    void Load(const char* strIn)
+    {
+        if (!strIn)
+        {
+            OUT_LOAD_INST_DATA_FAIL;
+            return;
+        }
+
+        OUT_LOAD_INST_DATA(strIn);
+
+        std::istringstream loadStream(strIn);
+        loadStream >> m_auiEncounter[0] >> m_auiEncounter[1] >> m_auiEncounter[2];
+
+        for(uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+        {
+            if (m_auiEncounter[i] == IN_PROGRESS)
+                m_auiEncounter[i] = NOT_STARTED;
+        }
+
+        OUT_LOAD_INST_DATA_COMPLETE;
+    }
+};
+
+InstanceData* GetInstanceData_instance_trial_of_the_champion(Map* pMap)
+{
+    return new instance_trial_of_the_champion(pMap);
+}
+
+void AddSC_instance_trial_of_the_champion()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "instance_trial_of_the_champion";
+    newscript->GetInstanceData = &GetInstanceData_instance_trial_of_the_champion;
+    newscript->RegisterSelf();
+}
diff --git a/scripts/northrend/crusaders_coliseum/trial_of_the_champion/trial_of_the_champion.cpp b/scripts/northrend/crusaders_coliseum/trial_of_the_champion/trial_of_the_champion.cpp
new file mode 100644
index 0000000..5dbb669
--- /dev/null
+++ b/scripts/northrend/crusaders_coliseum/trial_of_the_champion/trial_of_the_champion.cpp
@@ -0,0 +1,664 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or
+* (at your option) any later version.
+*
+* This program is distributed in the hope that it will be useful,
+* but WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+* GNU General Public License for more details.
+*
+* You should have received a copy of the GNU General Public License
+* along with this program; if not, write to the Free Software
+* Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+
+/* ScriptData
+SDName: Trial Of the Champion
+SD%Complete: 80%
+SDComment: event script
+SDCategory: trial_of_the_champion
+EndScriptData */
+
+/* ContentData
+npc_toc5_announcer
+EndContentData */
+
+#include "precompiled.h"
+#include "trial_of_the_champion.h"
+
+enum
+{
+    // intro yells
+    SAY_TIRION_INTRO            = -1614000,
+    SAY_ANN_CHALLENGE           = -1614001,
+    SAY_ALY_SPECTATORS          = -1614002,
+    SAY_HORDE_SPECTATORS        = -1614003,
+    SAY_TIRION_BEGIN            = -1614005,
+
+    SAY_EADRIC_INTRO            = -1614010,
+    SAY_PALETRESS_INTRO1        = -1614020,
+    SAY_PALETRESS_INTRO2        = -1614021,
+
+    SAY_TIRON_INTRO_BK          = -1614030,
+    SAY_ANN_INTRO_BK            = -1614031,
+
+    // trash spells
+    // lightwielder
+    SPELL_BLAZIN_LIGHT          = 67247,
+    SPELL_BLAZIN_LIGHT_H        = 67290,
+    SPELL_CLEAVE                = 15284,
+    SPELL_UNBALANCING_STRIKE    = 67237,    // heroic only
+    // monk
+    SPELL_DIVINE_SHIELD         = 67251,    // heroic only
+    SPELL_FINAL_MEDITATION      = 67255,    // heroic only
+    SPELL_FLYRRY_BLOWS          = 67233,
+    SPELL_PUMMEL                = 67235,
+    // priestess
+    SPELL_FOUNTAIN_LIGHT        = 67194,
+    SPELL_HOLY_SMITE            = 36176,
+    SPELL_HOLY_SMITE_H          = 67289,
+    SPELL_MIND_CONTROL          = 67229,    // heroic only
+    SPELL_SHADOW_WORD_PAIN      = 34941,
+    SPELL_SHADOW_WORD_PAIN_H    = 34942,
+};
+
+struct TocMessages
+{
+    char const* name;
+    uint32 id;
+    bool state;
+    uint32 encounter;
+};
+
+static TocMessages TocGossipMessage[]=
+{ 
+    {"We are ready for the first challenge!",       GOSSIP_ACTION_INFO_DEF+1,   false,  TYPE_GRAND_CHAMPIONS},          //  summon champs
+    {"We are ready to fight the next challenge!",   GOSSIP_ACTION_INFO_DEF+2,   false,  TYPE_ARGENT_CHALLENGE},         //  summon argent challenge
+    {"We are ready to fight the next challenge!",   GOSSIP_ACTION_INFO_DEF+3,   false,  TYPE_BLACK_KNIGHT},             //  summon black knight
+    {"Arena is closed",                             GOSSIP_ACTION_INFO_DEF+4,   true,   TYPE_BLACK_KNIGHT},             //  event finished
+};
+enum
+{
+    NUM_MESSAGES = 8
+};
+
+struct Locations
+{
+    float x, y, z, o;
+    uint32 id;
+};
+ 
+static Locations SpawnLoc[]=
+{
+    {733.665771f, 650.031433f, 412.394623f, 4.698702f},  
+    {746.864441f, 650.031433f, 412.394623f, 4.698702f},    
+    {760.360779f, 650.031433f, 412.394623f, 4.698702f},      
+};
+
+const uint32 TrashEntry[3] = {NPC_ARGENT_LIGHTWIELDER, NPC_ARGENT_MONK, NPC_ARGENT_PRIESTESS};
+
+// Argent trash
+struct MANGOS_DLL_DECL mob_toc_argent_trashAI: public ScriptedAI
+{
+    mob_toc_argent_trashAI(Creature* pCreature): ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsRegularMode = pCreature->GetMap()->IsRegularDifficulty();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsRegularMode;
+
+    uint32 m_uiCreatureEntry;
+
+    // lightwielder
+    uint32 m_uiBlazinLightTimer;
+    uint32 m_uiCleaveTimer;
+    uint32 m_uiStrikeTimer;
+    // monk
+    bool m_bHasShield;
+    uint32 m_uiFinalMeditationTimer;
+    uint32 m_uiFlurryBlowsTimer;
+    uint32 m_uiPummelTimer;
+    // priestess
+    uint32 m_uiLightFountainTimer;
+    uint32 m_uiHolySmiteTimer;
+    uint32 m_uiMindControlTimer;
+    uint32 m_uiShadowWordTimer;
+
+    void Reset()
+    {
+        m_uiCreatureEntry = m_creature->GetEntry();
+        m_creature->SetRespawnDelay(DAY);
+        // lightwielder
+        m_uiBlazinLightTimer    = 8000;
+        m_uiCleaveTimer         = 5000;
+        m_uiStrikeTimer         = 11000;
+        // monk
+        m_bHasShield            = false;
+        m_uiFinalMeditationTimer = 9000;
+        m_uiFlurryBlowsTimer    = 4000;
+        m_uiPummelTimer         = 7000;
+        // priestess
+        m_uiLightFountainTimer  = 11000;
+        m_uiHolySmiteTimer      = 5000;
+        m_uiMindControlTimer    = 9000;
+        m_uiShadowWordTimer     = 7000;
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostileTarget() || !m_creature->getVictim())
+            return;
+
+        switch(m_uiCreatureEntry)
+        {
+        case NPC_ARGENT_LIGHTWIELDER:
+            {
+                if(m_uiBlazinLightTimer < uiDiff)
+                {
+                    if(Unit* pTarget = DoSelectLowestHpFriendly(50.0f))
+                        DoCast(pTarget, m_bIsRegularMode ? SPELL_BLAZIN_LIGHT : SPELL_BLAZIN_LIGHT_H);
+                    m_uiBlazinLightTimer = urand(8000, 11000);
+                }
+                else m_uiBlazinLightTimer -= uiDiff;
+
+                if(m_uiCleaveTimer < uiDiff)
+                {
+                    DoCast(m_creature->getVictim(), SPELL_CLEAVE);
+                    m_uiCleaveTimer = urand(5000, 8000);
+                }
+                else m_uiCleaveTimer -= uiDiff;
+
+                if(m_uiStrikeTimer -= uiDiff && !m_bIsRegularMode)
+                {
+                    DoCast(m_creature->getVictim(), SPELL_UNBALANCING_STRIKE);
+                    m_uiStrikeTimer = urand(11000, 14000);
+                }
+                else m_uiStrikeTimer -= uiDiff;
+
+                break;
+            }
+        case NPC_ARGENT_MONK:
+            {
+                if(m_creature->GetHealthPercent() < 10.0f && !m_bHasShield && !m_bIsRegularMode)
+                {
+                    DoCast(m_creature, SPELL_DIVINE_SHIELD);
+                    m_bHasShield = true;
+                }
+
+                if(m_uiFinalMeditationTimer < uiDiff && !m_bIsRegularMode)
+                {
+                    if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                        DoCast(pTarget, SPELL_FINAL_MEDITATION);
+                    m_uiFinalMeditationTimer = urand(9000, 13000);
+                }
+                else m_uiFinalMeditationTimer -= uiDiff;
+
+                if(m_uiFlurryBlowsTimer < uiDiff)
+                {
+                    DoCast(m_creature->getVictim(), SPELL_FLYRRY_BLOWS);
+                    m_uiFlurryBlowsTimer = urand(4000, 8000);
+                }
+                else m_uiFlurryBlowsTimer -= uiDiff;
+
+                if(m_uiPummelTimer < uiDiff)
+                {
+                    DoCast(m_creature->getVictim(), SPELL_PUMMEL);
+                    m_uiPummelTimer = urand(4000, 8000);
+                }
+                else m_uiPummelTimer -= uiDiff;
+
+                break;
+            }
+        case NPC_ARGENT_PRIESTESS:
+            {
+                if(m_uiLightFountainTimer < uiDiff)
+                {
+                    DoCast(m_creature, SPELL_FOUNTAIN_LIGHT);
+                    m_uiLightFountainTimer = urand(15000, 20000);
+                }
+                else m_uiLightFountainTimer -= uiDiff;
+
+                if(m_uiHolySmiteTimer < uiDiff)
+                {
+                    if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                        DoCast(pTarget, m_bIsRegularMode ? SPELL_HOLY_SMITE : SPELL_HOLY_SMITE_H);
+                    m_uiHolySmiteTimer = urand(4000, 8000);
+                }
+                else m_uiHolySmiteTimer -= uiDiff;
+
+                if(m_uiMindControlTimer < uiDiff && !m_bIsRegularMode)
+                {
+                    if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                        DoCast(pTarget, SPELL_MIND_CONTROL);
+                    m_uiMindControlTimer = urand(15000, 20000);
+                }
+                else m_uiMindControlTimer -= uiDiff;
+
+                if(m_uiShadowWordTimer < uiDiff)
+                {
+                    if (Unit* pTarget = m_creature->SelectAttackingTarget(ATTACKING_TARGET_RANDOM, 0))
+                        DoCast(pTarget, m_bIsRegularMode ? SPELL_SHADOW_WORD_PAIN : SPELL_SHADOW_WORD_PAIN_H);
+                    m_uiShadowWordTimer = urand(6000, 9000);
+                }
+                else m_uiShadowWordTimer -= uiDiff;
+
+                break;
+            }
+        }
+
+        DoMeleeAttackIfReady();
+    }
+};
+/*######
+## npc_toc5_announcer
+######*/
+struct MANGOS_DLL_DECL npc_toc5_announcerAI: public ScriptedAI
+{
+    npc_toc5_announcerAI(Creature* pCreature): ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+
+    uint32 m_uiIntroTimer;
+    uint32 m_uiIntroStep;
+
+    bool m_bIsIntro;
+
+    uint32 m_uiChamp1Entry;
+    uint32 m_uiChamp2Entry;
+    uint32 m_uiChamp3Entry;
+    uint32 m_uiGrandChampEntry;
+
+    uint64 m_uiChamp1GUID;
+    uint64 m_uiChamp2GUID;
+    uint64 m_uiChamp3GUID;
+    uint64 m_uiGrandChampGUID;
+
+    void Reset()
+    {
+        m_uiIntroTimer      = 1000;
+        m_uiIntroStep       = 0;
+        m_bIsIntro          = false;
+        m_uiChamp1Entry     = 0;
+        m_uiChamp2Entry     = 0;
+        m_uiChamp3Entry     = 0;
+        m_uiChamp1GUID      = 0;
+        m_uiChamp2GUID      = 0;
+        m_uiChamp3GUID      = 0;
+        m_uiGrandChampGUID  = 0;
+        // set the random encounters
+        SetChamps();
+    }
+
+    void SetChamps()
+    {
+        std::vector<uint32> ChampionEntries;
+        ChampionEntries.reserve(5);
+
+        switch(m_creature->GetEntry())
+        {
+        case NPC_ARELAS:
+            {
+                ChampionEntries.push_back(NPC_MOKRA);
+                ChampionEntries.push_back(NPC_ERESSEA);
+                ChampionEntries.push_back(NPC_RUNOK);
+                ChampionEntries.push_back(NPC_ZULTORE);
+                ChampionEntries.push_back(NPC_VISCERI);
+                break;
+            }
+        case NPC_JAEREN:
+            {
+                ChampionEntries.push_back(NPC_JACOB);
+                ChampionEntries.push_back(NPC_AMBROSE);
+                ChampionEntries.push_back(NPC_COLOSOS);
+                ChampionEntries.push_back(NPC_JAELYNE);
+                ChampionEntries.push_back(NPC_LANA);
+                break;
+            }
+        }
+
+        if (!ChampionEntries.empty())
+        {
+            std::random_shuffle(ChampionEntries.begin(), ChampionEntries.end());
+            m_uiChamp1Entry = ChampionEntries[0];
+            m_uiChamp2Entry = ChampionEntries[1];
+            m_uiChamp3Entry = ChampionEntries[2];
+        }
+    }
+
+    void StartEvent()
+    {
+        m_bIsIntro          = true;
+        m_uiIntroTimer      = 1000;
+        m_uiIntroStep       = 0;
+    }
+
+    void SummmonTrash()
+    {
+        for(int i = 0; i < 3; ++i)
+        {
+            for(int j = 0; j < 3; ++j)
+            {
+                float angle = (float) rand()*360/RAND_MAX + 1;
+                float homeX = SpawnLoc[i].x + 3*cos(angle*(M_PI/180));
+                float homeY = SpawnLoc[i].y + 3*sin(angle*(M_PI/180));
+                m_creature->SummonCreature(TrashEntry[j], homeX, homeY, SpawnLoc[i].z, SpawnLoc[i].o, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 10000);
+            }
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        switch(m_pInstance->GetData(TYPE_STAGE))
+        {
+        case 0:
+            // blank
+            break;
+        case 1:
+            {
+                // champs
+                if (m_bIsIntro)
+                {
+                    if(m_uiIntroTimer < uiDiff)
+                    {
+                        switch(m_uiIntroStep)
+                        {
+                        case 0:
+                            // some intro here
+                            // vehicles event here
+                            ++m_uiIntroStep;
+                            m_uiIntroTimer = 1000;
+                            break;
+                        case 1:
+                            if(Creature* pTemp = m_creature->SummonCreature(m_uiChamp1Entry, 738.665771f, 661.031433f, 412.394623f, 4.698702f, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 60000))
+                                m_uiChamp1GUID = pTemp->GetGUID();
+                            if(Creature* pTemp = m_creature->SummonCreature(m_uiChamp2Entry, 746.864441f, 660.918762f, 411.695465f, 4.698700f, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 60000))
+                                m_uiChamp2GUID = pTemp->GetGUID();
+                            if(Creature* pTemp = m_creature->SummonCreature(m_uiChamp3Entry, 754.360779f, 660.816162f, 412.395996f, 4.698700f, TEMPSUMMON_CORPSE_TIMED_DESPAWN, 60000))
+                                m_uiChamp3GUID = pTemp->GetGUID();
+                            ++m_uiIntroStep;
+                            m_uiIntroTimer = 2000;
+                            break;
+                        case 2:
+                            m_bIsIntro = false;
+                            ++m_uiIntroStep;
+                            m_uiIntroTimer = 3000;
+                            break;
+                        }
+                    }else m_uiIntroTimer -= uiDiff;
+                }
+
+                // check if champs are dead
+                if(!m_bIsIntro)
+                {
+                    Creature* pChamp1 = m_pInstance->instance->GetCreature(m_uiChamp1GUID);
+                    Creature* pChamp2 = m_pInstance->instance->GetCreature(m_uiChamp2GUID);
+                    Creature* pChamp3 = m_pInstance->instance->GetCreature(m_uiChamp3GUID);
+
+                    if(pChamp1 && pChamp2 && pChamp3)
+                    {
+                        if(!pChamp1->isAlive() && !pChamp2->isAlive() && !pChamp3->isAlive())
+                        {
+                            m_pInstance->SetData(TYPE_STAGE, 0);
+                            m_pInstance->SetData(TYPE_GRAND_CHAMPIONS, DONE);
+                            m_creature->SetVisibility(VISIBILITY_ON);
+                            m_creature->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);        
+                        }
+                    }
+                }
+                break;
+            }
+        case 2:
+            {
+                // argent challenge
+                if (m_bIsIntro)
+                {
+                    if(m_uiIntroTimer < uiDiff)
+                    {
+                        switch(m_uiIntroStep)
+                        {
+                        case 0:
+                            // tirion
+                            if(Creature* pTirion = GetClosestCreatureWithEntry(m_creature, NPC_TIRION, 180.0f))
+                                DoScriptText(SAY_TIRION_INTRO, pTirion);
+
+                            switch(urand(0, 1))
+                            {
+                            case 0: m_uiGrandChampEntry = NPC_EADRIC; break;
+                            case 1: m_uiGrandChampEntry = NPC_PALETRESS; break;
+                            }
+
+                            if(m_pInstance)
+                                m_pInstance->SetData(DATA_ARGENT_CHALLERGER, m_uiGrandChampEntry);
+                            ++m_uiIntroStep;
+                            m_uiIntroTimer = 7000;
+                            break;
+                        case 1:
+                            // announcer
+                            if(m_uiGrandChampEntry == NPC_PALETRESS)
+                                DoScriptText(SAY_ANN_CHALLENGE, m_creature);
+                            ++m_uiIntroStep;
+                            m_uiIntroTimer = 3000;
+                            break;
+                        case 2:
+                            // spectators
+                            if(m_uiGrandChampEntry == NPC_PALETRESS)
+                            {
+                                switch(m_creature->GetEntry())
+                                {
+                                case NPC_ARELAS:
+                                    DoScriptText(SAY_HORDE_SPECTATORS, m_creature);
+                                    break;
+                                case NPC_JAEREN:
+                                    DoScriptText(SAY_ALY_SPECTATORS, m_creature);
+                                    break;
+                                }
+                            }
+                            m_creature->SetVisibility(VISIBILITY_OFF);
+                            if(Creature* pTemp = m_creature->SummonCreature(m_uiGrandChampEntry, 746.864441f, 660.918762f, 411.695465f, 4.698700f, TEMPSUMMON_CORPSE_DESPAWN, 10000))
+                            {
+                                m_uiGrandChampGUID = pTemp->GetGUID();
+                                pTemp->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                            }
+                            ++m_uiIntroStep;
+                            m_uiIntroTimer = 1000;
+                            break;
+                        case 3:
+                            // intro 1
+                            if(m_uiGrandChampEntry == NPC_PALETRESS)
+                            {
+                                if(Creature* pTemp = m_pInstance->instance->GetCreature(m_uiGrandChampGUID))
+                                    DoScriptText(SAY_PALETRESS_INTRO1, pTemp);
+                            }
+                            else if (m_uiGrandChampEntry == NPC_EADRIC)
+                            {
+                                if(Creature* pTemp = m_pInstance->instance->GetCreature(m_uiGrandChampGUID))
+                                    DoScriptText(SAY_EADRIC_INTRO, pTemp);
+                            }
+                            ++m_uiIntroStep;
+                            m_uiIntroTimer = 5000;
+                            break;
+                        case 4:
+                            // intro 2
+                            if(m_uiGrandChampEntry == NPC_PALETRESS)
+                            {
+                                if(Creature* pTemp = m_pInstance->instance->GetCreature(m_uiGrandChampGUID))
+                                    DoScriptText(SAY_PALETRESS_INTRO2, pTemp);
+                                m_uiIntroTimer = 6000;
+                            }
+                            else if (m_uiGrandChampEntry == NPC_EADRIC)
+                                m_uiIntroTimer = 1000;
+                            ++m_uiIntroStep;
+                            break;
+                        case 5:
+                            // begin
+                            if(Creature* pTirion = GetClosestCreatureWithEntry(m_creature, NPC_TIRION, 180.0f))
+                                DoScriptText(SAY_TIRION_BEGIN, pTirion);
+                            ++m_uiIntroStep;
+                            m_uiIntroTimer = 2000;
+                            break;
+                        case 6:
+                            // summon trash
+                            SummmonTrash();
+                            m_bIsIntro = false;
+                            ++m_uiIntroStep;
+                            m_uiIntroTimer = 3000;
+                            break;
+                        }
+                    }else m_uiIntroTimer -= uiDiff;
+                }
+
+                break;
+            }
+        case 3:
+            {
+                // black knight
+                if (m_bIsIntro)
+                {
+                    if(m_uiIntroTimer < uiDiff)
+                    {
+                        switch(m_uiIntroStep)
+                        {
+                        case 0:
+                            // tirion
+                            if(Creature* pTirion = GetClosestCreatureWithEntry(m_creature, NPC_TIRION, 180.0f))
+                                DoScriptText(SAY_TIRON_INTRO_BK, pTirion);
+                            ++m_uiIntroStep;
+                            m_uiIntroTimer = 4000;
+                            break;
+                        case 1:
+                            // announcer
+                            DoScriptText(SAY_ANN_INTRO_BK, m_creature);
+                            ++m_uiIntroStep;
+                            m_uiIntroTimer = 2000;
+                            break;
+                        case 2:
+                            // summmon 
+                            if(Creature* pTemp = m_creature->SummonCreature(NPC_BLACK_KNIGHT, 746.864441f, 660.918762f, 411.695465f, 4.698700f, TEMPSUMMON_MANUAL_DESPAWN, 0))
+                            {
+                                pTemp->GetMotionMaster()->MovePoint(0, m_creature->GetPositionX(), m_creature->GetPositionY() + 10, m_creature->GetPositionZ());
+                                pTemp->RemoveSplineFlag(SPLINEFLAG_WALKMODE);
+                            }
+                            m_bIsIntro = false;
+                            ++m_uiIntroStep;
+                            m_uiIntroTimer = 3000;
+                            break;
+                        }
+                    }else m_uiIntroTimer -= uiDiff;
+                }
+                break;
+            }
+        }
+    }
+};
+
+CreatureAI* GetAI_npc_toc5_announcer(Creature* pCreature)
+{
+    return new npc_toc5_announcerAI(pCreature);
+}
+
+bool GossipHello_npc_toc5_announcer(Player* pPlayer, Creature* pCreature)
+{
+    ScriptedInstance* m_pInstance;
+    m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+
+    if (!m_pInstance) return false;
+
+    if(!pPlayer->getAttackers().empty()) return true;
+
+    for(uint8 i = 0; i < 4; i++) 
+    {
+        if (!TocGossipMessage[i].state && (m_pInstance->GetData(TocGossipMessage[i].encounter) == NOT_STARTED || m_pInstance->GetData(TocGossipMessage[i].encounter) == IN_PROGRESS || m_pInstance->GetData(TocGossipMessage[i].encounter) == FAIL)) 
+        {
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, TocGossipMessage[i].name, GOSSIP_SENDER_MAIN,TocGossipMessage[i].id);
+            break;
+        }
+        if (TocGossipMessage[i].state && m_pInstance->GetData(TocGossipMessage[i].encounter) == DONE)
+            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, TocGossipMessage[i].name, GOSSIP_SENDER_MAIN,TocGossipMessage[i].id);
+    };
+
+    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+    return true;
+}
+
+bool GossipSelect_npc_toc5_announcer(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    ScriptedInstance* m_pInstance;
+    m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+
+    pPlayer->CLOSE_GOSSIP_MENU();
+
+    switch(uiAction) 
+    {
+    case GOSSIP_ACTION_INFO_DEF+1: 
+        {
+            m_pInstance->SetData(TYPE_STAGE, 1);
+            ((npc_toc5_announcerAI*)pCreature->AI())->StartEvent();
+            pCreature->SetVisibility(VISIBILITY_OFF);
+            pCreature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+
+            //if(GameObject* pMainGate = m_pInstance->instance->GetGameObject(m_pInstance->GetData64(DATA_MAIN_GATE)))
+                //m_pInstance->DoUseDoorOrButton(pMainGate->GetGUID());
+
+            break;
+        };
+
+    case GOSSIP_ACTION_INFO_DEF+2: 
+        {
+            m_pInstance->SetData(TYPE_STAGE,2);
+            ((npc_toc5_announcerAI*)pCreature->AI())->StartEvent();
+            pCreature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+
+            //if(GameObject* pMainGate = m_pInstance->instance->GetGameObject(m_pInstance->GetData64(DATA_MAIN_GATE)))
+                //m_pInstance->DoUseDoorOrButton(pMainGate->GetGUID());
+            break;
+        };
+
+    case GOSSIP_ACTION_INFO_DEF+3: 
+        {
+            m_pInstance->SetData(TYPE_STAGE,3);
+            ((npc_toc5_announcerAI*)pCreature->AI())->StartEvent();
+            pCreature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+            break;
+        };
+
+    case GOSSIP_ACTION_INFO_DEF+4:
+        {
+            m_pInstance->SetData(TYPE_STAGE,0);
+            pCreature->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+            break;
+        };
+    };
+
+    return true;
+}
+
+CreatureAI* GetAI_mob_toc_argent_trash(Creature* pCreature)
+{
+    return new mob_toc_argent_trashAI(pCreature);
+}
+
+void AddSC_trial_of_the_champion()
+{
+    Script* NewScript;
+
+    NewScript = new Script;
+    NewScript->Name = "npc_toc5_announcer";
+    NewScript->GetAI = &GetAI_npc_toc5_announcer;
+    NewScript->pGossipHello = &GossipHello_npc_toc5_announcer;
+    NewScript->pGossipSelect = &GossipSelect_npc_toc5_announcer;
+    NewScript->RegisterSelf();
+
+    NewScript = new Script;
+    NewScript->Name = "mob_toc_argent_trash";
+    NewScript->GetAI = &GetAI_mob_toc_argent_trash;
+    NewScript->RegisterSelf();
+}
diff --git a/scripts/northrend/crusaders_coliseum/trial_of_the_champion/trial_of_the_champion.h b/scripts/northrend/crusaders_coliseum/trial_of_the_champion/trial_of_the_champion.h
new file mode 100644
index 0000000..d798fe8
--- /dev/null
+++ b/scripts/northrend/crusaders_coliseum/trial_of_the_champion/trial_of_the_champion.h
@@ -0,0 +1,98 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+* This program is free software licensed under GPL version 2
+* Please see the included DOCS/LICENSE.TXT for more information */
+
+#ifndef DEF_TOC_H
+#define DEF_TOC_H
+
+enum
+{
+    MAX_ENCOUNTER               = 3,
+
+    TYPE_GRAND_CHAMPIONS        = 0,
+    TYPE_ARGENT_CHALLENGE       = 1,
+    TYPE_BLACK_KNIGHT           = 2,
+    TYPE_STAGE                  = 3,
+
+    DATA_TOC_ANNOUNCER          = 4,
+    DATA_ARGENT_CHALLERGER      = 5,
+
+    // aly champs
+    NPC_JACOB                   = 34705,
+    NPC_AMBROSE                 = 34702,
+    NPC_COLOSOS                 = 34701,
+    NPC_JAELYNE                 = 34657,
+    NPC_LANA                    = 34703,
+    // horde champs
+    NPC_MOKRA                   = 35572,
+    NPC_ERESSEA                 = 35569,
+    NPC_RUNOK                   = 35571,
+    NPC_ZULTORE                 = 35570,
+    NPC_VISCERI                 = 35617,
+    // argent challegers
+    // trash
+    NPC_ARGENT_LIGHTWIELDER     = 35309,
+    NPC_ARGENT_MONK             = 35305,
+    NPC_ARGENT_PRIESTESS        = 35307,
+    // boss
+    NPC_EADRIC                  = 35119,
+    NPC_PALETRESS               = 34928,
+    // black knight
+    NPC_BLACK_KNIGHT            = 35451,
+    NPC_RISEN_JAEREN            = 35545,
+    NPC_RISEN_ARELAS            = 35564,
+    NPC_RISEN_CHAMPION          = 35590,
+    // announcer
+    NPC_JAEREN                  = 35004,
+    NPC_ARELAS                  = 35005,
+    NPC_TIRION                  = 34996,
+
+    // memories
+    MEMORY_ALGALON              = 35052,
+    MEMORY_ARCHIMONDE           = 35041,
+    MEMORY_CHROMAGGUS           = 35033,
+    MEMORY_CYANIGOSA            = 35046,
+    MEMORY_DELRISSA             = 35043,
+    MEMORY_ECK                  = 35047,
+    MEMORY_ENTROPIUS            = 35044,
+    MEMORY_GRUUL                = 35039,
+    MEMORY_HAKKAR               = 35034,
+    MEMORY_HEIGAN               = 35049,
+    MEMORY_HEROD                = 35030,
+    MEMORY_HOGGER               = 34942,
+    MEMORY_IGNIS                = 35050,
+    MEMORY_ILLIDAN              = 35042,
+    MEMORY_INGVAR               = 35045,
+    MEMORY_KALITHRESH           = 35037,
+    MEMORY_LUCIFRON             = 35031,
+    MEMORY_MALCHEZAAR           = 35038,
+    MEMORY_MUTANUS              = 35029,
+    MEMORY_ONYXIA               = 35048,
+    MEMORY_THUNDERAAN           = 35032,
+    MEMORY_VANCLEEF             = 35028,
+    MEMORY_VASHJ                = 35040,
+    MEMORY_VEKNILASH            = 35036,
+    MEMORY_VEZAX                = 35051,
+
+    // doors
+    GO_MAIN_GATE                = 195647,
+    GO_WEST_GATE                = 195589,
+    GO_SOUTH_GATE               = 195590,
+    GO_NORTH_GATE               = 195650,
+
+    // loot
+    GO_CHAMPIONS_LOOT           = 195709,
+    GO_CHAMPIONS_LOOT_H         = 195710,
+    GO_EADRIC_LOOT              = 195374,
+    GO_EADRIC_LOOT_H            = 195375,
+    GO_PALETRESS_LOOT           = 195323,
+    GO_PALETRESS_LOOT_H         = 195324,
+
+    // achievs
+    ACHIEV_TOC_ALY_H            = 4298,
+    ACHIEV_TOC_HORDE_H          = 4297,
+    ACHIEV_TOC_ALY              = 4296,
+    ACHIEV_TOC_HORDE            = 3778,
+};
+
+#endif
diff --git a/sql/Custom_Updates/Mangos/Northrend/TrialOfTheChampion_Mangos.sql b/sql/Custom_Updates/Mangos/Northrend/TrialOfTheChampion_Mangos.sql
new file mode 100644
index 0000000..0468bee
--- /dev/null
+++ b/sql/Custom_Updates/Mangos/Northrend/TrialOfTheChampion_Mangos.sql
@@ -0,0 +1,25 @@
+-- instance
+UPDATE instance_template SET script = 'instance_trial_of_the_champion' WHERE map = 650;
+
+-- announcers
+UPDATE creature_template SET npcflag = 1, ScriptName = 'npc_toc5_announcer' WHERE entry IN (35004, 35005);
+
+-- grand champions
+UPDATE creature_template SET ScriptName = 'mob_toc5_warrior' WHERE entry IN (34705, 35572);
+UPDATE creature_template SET ScriptName = 'mob_toc5_mage' WHERE entry IN (34702, 35569);
+UPDATE creature_template SET ScriptName = 'mob_toc5_shaman' WHERE entry IN (34701, 35571);
+UPDATE creature_template SET ScriptName = 'mob_toc5_hunter' WHERE entry IN (34657, 35570);
+UPDATE creature_template SET ScriptName = 'mob_toc5_rogue' WHERE entry IN (34703, 35617);
+
+-- argent challenge
+UPDATE creature_template SET ScriptName = 'boss_eadric' WHERE entry = 35119;
+UPDATE creature_template SET ScriptName = 'boss_paletress' WHERE entry = 34928;
+UPDATE creature_template SET ScriptName = 'mob_toc_memory' WHERE entry IN
+(35052, 35041, 35033, 35046, 35043, 35047, 35044, 35039, 35034, 35049, 35030, 34942, 35050,
+ 35042, 35045, 35037, 35031, 35038, 35029, 35048, 35032, 35028, 35040, 35036, 35051);
+ UPDATE creature_template SET ScriptName = 'mob_toc_argent_trash' WHERE entry in (35309, 35305, 35307);
+
+-- black knight
+UPDATE creature_template SET ScriptName = 'mob_toc_risen_ghoul' WHERE entry IN (35545, 35564, 35590);
+UPDATE creature_template SET ScriptName = 'boss_black_knight' WHERE entry = 35451;
+UPDATE creature_template SET ScriptName = 'mob_toc_desecration_bunny' WHERE entry = 35614;
diff --git a/sql/Custom_Updates/ScriptDev2/Northrend/TrialOfTheChampion_Script.sql b/sql/Custom_Updates/ScriptDev2/Northrend/TrialOfTheChampion_Script.sql
new file mode 100644
index 0000000..5574927
--- /dev/null
+++ b/sql/Custom_Updates/ScriptDev2/Northrend/TrialOfTheChampion_Script.sql
@@ -0,0 +1,45 @@
+/* TRIAL OF THE CRUSADER */
+delete from `script_texts` where `entry` between -1614050 and -1614000;
+INSERT INTO `script_texts` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`, `sound`, `type`, `language`, `emote`, `comment`) VALUES 
+-- Intro:
+-- Encounter 2 intro:
+(-1614000,"Well fought! Your next challenge comes from the Crusade's own ranks. You will be tested against their considerable prowess.","","","","","","","","",0,1,0,0,"tirion intro"),
+(-1614001,"The next combatant is second to none in her passion for upholding the Light. I give you Argent Confessor Paletress!","","","","","","","","",0,1,0,0,"announcer paletress intro"),
+(-1614002,"The Alliance spectators cheer for Argent Confessor Paletress.","","","","","","","","",0,2,0,0,"aly intro"),
+(-1614003,"The Horde spectators cheer for Argent Confessor Paletress.","","","","","","","","",0,2,0,0,"horde intro"),
+(-1614005,"You may begin!","","","","","","","","",0,1,0,0,"tirion begin"),
+-- Eadric:
+(-1614010,"Are you up to the challenge? I will not hold back!","","","","","","","","",16134,0,0,0,"eadric intro"),
+(-1614011,"Prepare yourselves!","","","","","","","","",16135,1,0,0,"eadric aggro"),
+(-1614012,"Hammer of the Righteous!","","","","","","","","",16136,1,0,0,"eadric hammer"),
+(-1614013,"You... You need more practice.","","","","","","","","",16137,1,0,0,"eadric kill1"),
+(-1614014,"Neigh! Neigh! And I say yet again NEIGH! Not good enough!","","","","","","","","",16138,1,0,0,"eadric kill2"),
+(-1614015,"I yield! I submit. Excellent work. May I run away now?","","","","","","","","",16139,1,0,0,"eadric defeat"),
+-- Paletress:
+(-1614020,"Thank you, good herald. Your words are too kind.","","","","","","","","",16245,0,0,0,"paletress intro1"),
+(-1614021,"May the Light give me strength to provide a worthy challenge.","","","","","","","","",16246,0,0,0,"paletress intro2"),
+(-1614022,"Well then, let us begin.","","","","","","","","",16247,1,0,0,"paletress aggro"),
+(-1614023,"Take this time to consider your past deeds.","","","","","","","","",16248,1,0,0,"summon memory"),
+(-1614024,"Even the darkest memory fades when confronted.","","","","","","","","",16249,1,0,0,"paletress memory dies"),
+(-1614025,"Take your rest.","","","","","","","","",16250,1,0,0,"paletress kill1"),
+(-1614026,"Be at ease.","","","","","","","","",16251,1,0,0,"paletress kill2"),
+(-1614027,"Excellent work!","","","","","","","","",16252,1,0,0,"paletress defeat"),
+-- Black Knight:
+(-1614030,"Well done. You have proven yourself today-","","","","","","","","",0,1,0,0,"tirion intro1"),
+(-1614031,"What's that, up near the rafters?","","","","","","","","",0,0,0,0,"announcer intro"),
+(-1614032,"You spoiled my grand entrance, rat.","","","","","","","","",16256,0,0,0,"dk intro"),
+(-1614033,"The Black Knight casts Death's Respite on the herald, killing him.","","","","","","","","",0,2,0,0,"dk intro2"),
+(-1614034,"What is the meaning of this?","","","","","","","","",0,1,0,0,"tirion intro2"),
+(-1614035,"Did you honestly think that an agent of the Lich King would be bested on the field of your pathetic little tournament?","","","","","","","","",16257,0,0,0,"dk intro2"),
+(-1614036,"I've come to finish my task.","","","","","","","","",16258,0,0,0,"dk intro 3"),
+(-1614037,"This farce ends here!","","","","","","","","",16259,1,0,0,"dk aggro"),
+(-1614038,"Don't just stand there; kill him!","","","","","","","","",0,1,0,0,"king intro"),
+(-1614039,"My rotting flesh was just getting in the way!","","","","","","","","",16262,1,0,0,"dk phase2"),
+(-1614040,"I have no need for bones to best you!","","","","","","","","",16263,1,0,0,"dk phase 3"),
+(-1614041,"A waste of flesh.","","","","","","","","",16260,1,0,0,"dk kill1"),
+(-1614042,"Pathetic.","","","","","","","","",16261,1,0,0,"dk kill2"),
+(-1614043,"No! I must not fail... again...","","","","","","","","",16264,1,0,0,"dk dies"),
+(-1614044,"My congratulations, champions. Through trials both planned and unexpected, you have triumphed.","","","","","","","","",0,1,0,0,"tirion outro1"),
+(-1614045,"Go now and rest; you've earned it.!","","","","","","","","",0,1,0,0,"tirion outro2"),
+(-1614046,"You fought well.","","","","","","","","",0,1,0,0,"varian outro"),
+(-1614047,"Well done Horde!","","","","","","","","",0,1,0,0,"gorash outro");
\ No newline at end of file
diff --git a/system/ScriptLoader.cpp b/system/ScriptLoader.cpp
index 742e15d..b9cd1e6 100644
--- a/system/ScriptLoader.cpp
+++ b/system/ScriptLoader.cpp
@@ -291,6 +291,11 @@ extern void AddSC_boss_anubarak();                          //azjol-nerub
 extern void AddSC_boss_hadronox();
 extern void AddSC_boss_krikthir();
 extern void AddSC_instance_azjol_nerub();
+extern void AddSC_boss_argent_challenge();                  //Crusaders' coliseum, trial_of_the_champion
+extern void AddSC_boss_black_knight();
+extern void AddSC_boss_grand_champions();
+extern void AddSC_instance_trial_of_the_champion();
+extern void AddSC_trial_of_the_champion();
 extern void AddSC_northrend_beasts();                       //Crusaders' Coliseum, trial_of_the_crusader
 extern void AddSC_boss_jaraxxus();
 extern void AddSC_boss_anubarak_trial();
@@ -783,6 +788,11 @@ void AddScripts()
     AddSC_boss_hadronox();
     AddSC_boss_krikthir();
     AddSC_instance_azjol_nerub();
+    AddSC_boss_argent_challenge();                          //Crusaders' coliseum, trial_of_the_champion
+    AddSC_boss_black_knight();
+    AddSC_boss_grand_champions();
+    AddSC_instance_trial_of_the_champion();
+    AddSC_trial_of_the_champion();
     AddSC_northrend_beasts();                               //Crusaders' Coliseum, trial_of_the_crusader
     AddSC_boss_jaraxxus();
     AddSC_boss_anubarak_trial();
